<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taska Elite - Student Tasks</title>
    <link rel="stylesheet" href="css/tasks.css">
    <link rel="stylesheet" href="../css/reset.css">
    <link rel="stylesheet" href="../css/global.css">
    <link rel="stylesheet" href="../css/classified-navbar.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        /* Confirmation Dialog Styles */
        .confirmation-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        .confirmation-dialog.active {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .confirmation-dialog .dialog-box {
            background: #fff;
            padding: 2rem;
            border-radius: 16px;
            width: 90%;
            max-width: 450px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border: 1px solid #e0e0e0;
            animation: slideInUp 0.3s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .confirmation-dialog .dialog-box h3 {
            margin: 0 0 1rem;
            color: #1a1a1a;
            font-size: 1.4rem;
            font-weight: 600;
        }

        .confirmation-dialog .dialog-box p {
            margin: 0 0 2rem;
            color: #666;
            font-size: 1rem;
            line-height: 1.5;
        }

        .confirmation-dialog .dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .confirmation-dialog .dialog-actions button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
            font-family: 'Poppins', sans-serif;
        }

        .confirmation-dialog .dialog-actions .cancel {
            background: #f5f5f5;
            color: #666;
            border: 1px solid #e0e0e0;
        }

        .confirmation-dialog .dialog-actions .cancel:hover {
            background: #e9ecef;
            color: #333;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .confirmation-dialog .dialog-actions .confirm {
            background: #4CAF50;
            color: #fff;
        }

        .confirmation-dialog .dialog-actions .confirm:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .confirmation-dialog .dialog-actions .delete {
            background: #FF5252;
            color: #fff;
        }

        .confirmation-dialog .dialog-actions .delete:hover {
            background: #e04848;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 82, 82, 0.3);
        }

        /* Success Modal Styles */
        .success-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        .success-modal.active {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        .success-modal .modal-content {
            background: #fff;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border: 1px solid #e0e0e0;
            animation: slideInUp 0.3s ease-out;
        }

        .success-modal .modal-header {
            padding: 1.5rem 2rem 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .success-modal .modal-header h3 {
            margin: 0;
            color: #1a1a1a;
            font-size: 1.3rem;
            font-weight: 600;
        }

        .success-modal .modal-header button {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #666;
            cursor: pointer;
            padding: 0;
        }

        .success-modal .modal-body {
            padding: 1rem 2rem;
        }

        .success-modal .modal-actions {
            padding: 0 2rem 1.5rem;
            display: flex;
            justify-content: center;
        }

        .success-modal .success-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .success-modal .success-btn:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        /* Success Content Styles */
        .success-content {
            text-align: center;
            padding: 1rem 0;
        }

        .success-content i {
            font-size: 2.5rem;
            color: #16a34a;
            margin-bottom: 0.75rem;
        }

        .success-content h4 {
            font-size: 1.1rem;
            color: #333;
            margin: 0 0 0.75rem 0;
            font-weight: 600;
        }

        .success-content p {
            color: #666;
            margin: 0.25rem 0;
            line-height: 1.4;
            font-size: 0.9rem;
        }

        /* Task Acceptance Modal Styles */
        .task-acceptance-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        .task-acceptance-modal.active {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        .task-acceptance-modal .modal-content {
            background: #fff;
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border: 1px solid #e0e0e0;
            animation: slideInUp 0.3s ease-out;
        }

        .task-acceptance-modal .modal-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .task-acceptance-modal .modal-header h3 {
            margin: 0;
            color: #1a1a1a;
            font-size: 1.3rem;
            font-weight: 600;
        }

        .task-acceptance-modal .modal-header button {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #666;
            cursor: pointer;
            padding: 0;
        }

        .task-acceptance-modal .modal-body {
            padding: 2rem;
        }

        .task-acceptance-modal .form-group {
            margin-bottom: 1.5rem;
        }

        .task-acceptance-modal .form-group label {
            display: block;
            font-weight: 500;
            color: #333;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }

        .task-acceptance-modal .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.9rem;
            font-family: 'Poppins', sans-serif;
            resize: vertical;
            min-height: 100px;
            box-sizing: border-box;
        }

        .task-acceptance-modal .form-group textarea:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        .task-acceptance-modal .modal-actions {
            padding: 1.5rem 2rem;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }

        .task-acceptance-modal .cancel-btn {
            background: #f5f5f5;
            color: #666;
            border: 1px solid #e0e0e0;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .task-acceptance-modal .cancel-btn:hover {
            background: #e9ecef;
            color: #333;
        }

        .task-acceptance-modal .accept-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .task-acceptance-modal .accept-btn:hover {
            background: #45a049;
        }

        .task-acceptance-modal .accept-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Promotion Notification Styles */
        .promotion-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            max-width: 350px;
            animation: slideInRight 0.3s ease-out;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .notification-content i.fa-arrow-up {
            font-size: 1.2rem;
            color: #fff;
        }

        .notification-text {
            flex: 1;
        }

        .notification-text strong {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
        }

        .notification-text p {
            margin: 0;
            font-size: 0.85rem;
            opacity: 0.9;
        }

        .notification-close {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .notification-close:hover {
            background: rgba(255,255,255,0.2);
        }

        /* ... existing code ... */

        /* Hide Assigned Task Modal by default */
        .assigned-task-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            background: rgba(0,0,0,0.5);
        }
        .assigned-task-modal.active {
            display: flex;
        }

        /* File Upload Area Styles */
        .file-upload-area {
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fafafa;
            position: relative;
        }

        .file-upload-area:hover {
            border-color: #4CAF50;
            background: #f0f8f0;
        }

        .file-upload-area.drag-over {
            border-color: #4CAF50;
            background: #e8f5e8;
            transform: scale(1.02);
        }

        .file-upload-area input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .upload-placeholder {
            pointer-events: none;
        }

        .upload-placeholder i {
            font-size: 2rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .upload-placeholder p {
            color: #666;
            margin: 0;
            font-size: 0.9rem;
        }

        .uploaded-files {
            margin-top: 1rem;
        }

        .uploaded-file {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: #f5f5f5;
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        .uploaded-file i {
            color: #666;
        }

        .uploaded-file span {
            flex: 1;
            font-size: 0.9rem;
            color: #333;
        }

        .remove-file {
            background: none;
            border: none;
            color: #ff5252;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .remove-file:hover {
            background: #ffe6e6;
        }

        /* Add CSS for .upload-btn */
        .upload-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
        }
        .upload-btn:hover {
            background: #45a049;
        }

        /* Task Rejection Modal Styles */
        .task-rejection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        .task-rejection-modal.active {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        .task-rejection-modal .modal-content {
            background: #fff;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border: 1px solid #e0e0e0;
            animation: slideInUp 0.3s ease-out;
        }

        .task-rejection-modal .modal-header {
            padding: 1.5rem 2rem 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e0e0e0;
        }

        .task-rejection-modal .modal-header h3 {
            margin: 0;
            color: #1a1a1a;
            font-size: 1.3rem;
            font-weight: 600;
        }

        .task-rejection-modal .modal-header button {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #666;
            cursor: pointer;
            padding: 0;
        }

        .task-rejection-modal .modal-body {
            padding: 1.5rem 2rem;
        }

        .task-rejection-modal .form-group {
            margin-bottom: 1.5rem;
        }

        .task-rejection-modal .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #1a1a1a;
        }

        .task-rejection-modal .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.95rem;
            resize: vertical;
            min-height: 100px;
        }

        .task-rejection-modal .form-group textarea:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        .task-rejection-modal .rejection-notice {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .task-rejection-modal .rejection-notice i {
            color: #856404;
            font-size: 1.1rem;
            margin-top: 0.1rem;
        }

        .task-rejection-modal .rejection-notice p {
            margin: 0;
            color: #856404;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .task-rejection-modal .modal-actions {
            padding: 0 2rem 1.5rem;
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        .task-rejection-modal .cancel-btn {
            background: #f5f5f5;
            color: #666;
            border: 1px solid #e0e0e0;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .task-rejection-modal .cancel-btn:hover {
            background: #e9ecef;
            color: #333;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .task-rejection-modal .reject-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .task-rejection-modal .reject-btn:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        /* Submission Modal Styles - macOS Style */
        .submission-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.4);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(8px);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .submission-modal.active {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        .submission-modal .modal-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3), 0 8px 25px rgba(0,0,0,0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(20px);
            animation: slideInUp 0.3s ease-out;
        }

        .submission-modal .modal-header {
            background: rgba(248, 249, 250, 0.8);
            padding: 16px 24px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        .submission-modal .modal-header h3 {
            margin: 0;
            color: #1d1d1f;
            font-size: 18px;
            font-weight: 600;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .submission-modal .modal-header .close-modal {
            background: none;
            border: none;
            font-size: 20px;
            color: #6e6e73;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .submission-modal .modal-header .close-modal:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #1d1d1f;
        }

        .submission-modal .modal-body {
            padding: 24px;
            background: rgba(255, 255, 255, 0.8);
        }

        .submission-modal .form-group {
            margin-bottom: 20px;
        }

        .submission-modal .form-group label {
            display: block;
            font-weight: 500;
            color: #1d1d1f;
            margin-bottom: 8px;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .submission-modal .form-group textarea {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            resize: vertical;
            min-height: 100px;
            box-sizing: border-box;
            background: rgba(248, 249, 250, 0.8);
            color: #1d1d1f;
            transition: all 0.2s ease;
            outline: none;
        }

        .submission-modal .form-group textarea:focus {
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
            background: rgba(255, 255, 255, 0.95);
        }

        .submission-modal .form-group textarea::placeholder {
            color: #8e8e93;
        }

        .submission-modal .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(248, 249, 250, 0.8);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            backdrop-filter: blur(10px);
        }

        .submission-modal .btn-secondary {
            background: rgba(142, 142, 147, 0.1);
            color: #1d1d1f;
            border: 1px solid rgba(142, 142, 147, 0.2);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .submission-modal .btn-secondary:hover {
            background: rgba(142, 142, 147, 0.2);
            border-color: rgba(142, 142, 147, 0.3);
            transform: translateY(-1px);
        }

        .submission-modal .btn-primary {
            background: #007aff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .submission-modal .btn-primary:hover {
            background: #0056cc;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
        }

        .submission-modal .btn-primary:disabled {
            background: rgba(142, 142, 147, 0.3);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .submission-modal .btn-primary.loading {
            background: #007aff;
            cursor: not-allowed;
            position: relative;
            color: transparent;
        }

        .submission-modal .btn-primary.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            margin: -8px 0 0 -8px;
            border: 2px solid transparent;
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Upload Button macOS Style */
        .submission-modal .upload-btn {
            background: #007aff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 16px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .submission-modal .upload-btn:hover {
            background: #0056cc;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
        }

        .submission-modal .upload-btn i {
            font-size: 14px;
        }

        /* Uploaded Files macOS Style */
        .submission-modal .uploaded-files {
            margin-top: 16px;
        }

        .submission-modal .uploaded-file {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: rgba(248, 249, 250, 0.8);
            border-radius: 8px;
            margin-bottom: 8px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }

        .submission-modal .uploaded-file:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 122, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .submission-modal .uploaded-file i {
            color: #8e8e93;
            font-size: 16px;
            width: 20px;
            text-align: center;
        }

        .submission-modal .uploaded-file span {
            flex: 1;
            font-size: 14px;
            color: #1d1d1f;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .submission-modal .remove-file {
            background: rgba(255, 59, 48, 0.1);
            border: none;
            color: #ff3b30;
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
        }

        .submission-modal .remove-file:hover {
            background: rgba(255, 59, 48, 0.2);
            transform: scale(1.1);
        }

        .submission-modal .remove-file i {
            font-size: 12px;
        }

        /* Timeline Approval Status Styles */
        .timeline-item.approved {
            border-left: 3px solid #4CAF50;
        }

        .timeline-item.pending {
            border-left: 3px solid #FFC107;
        }

        .submission-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            margin-right: 12px;
        }

        .submission-status i {
            font-size: 14px;
        }

        .approval-feedback {
            margin-top: 16px;
            padding: 12px 16px;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.2);
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }

        .feedback-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .feedback-header i {
            font-size: 16px;
        }

        .feedback-content {
            color: #333;
            font-size: 14px;
            line-height: 1.5;
            margin-left: 24px;
        }

        .feedback-content:empty {
            display: none;
        }
    </style>
</head>
<body>
    <nav class="navbar_classified">
        <a href="../index.html">
            <div class="logo"><img src="../assets/logo.png" alt="Taska Logo" style="height:48px;vertical-align:middle;"></div>
        </a>
        <ul class="nav-menu">
            <li><a href="tasks.html" class="active">Workplace</a></li>
            <li><a href="profile.html">Account</a></li>
        </ul>
        <div class="hamburger">â˜°</div>
    </nav>

    <!-- Mobile Sidebar Toggle Button -->
    <button class="sidebar-toggle" id="sidebar-toggle" onclick="toggleSidebar()">
        <i class="fas fa-chevron-right"></i>
    </button>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebar-overlay" onclick="closeSidebar()"></div>

    <div class="dashboard-content">
        <div class="sidebar-left">
            <!-- Assigned Tasks Section -->
            <div class="assigned-tasks-section" id="assigned-tasks-section" style="display: none;">
                <h3>Assigned Tasks</h3>
                <div id="assigned-tasks-list" class="assigned-tasks-list">
                    <!-- Assigned tasks will be populated here -->
                </div>
            </div>
            
            <!-- Connections Section -->
            <div class="connections-section">
                <h3>Connections</h3>
                <div id="connections-list" class="skeleton-loading">
                    <div class="skeleton-user-item"></div>
                    <div class="skeleton-user-item"></div>
                    <div class="skeleton-user-item"></div>
                </div>
                <div class="pending-requests" style="display: none;">
                    <h3>Pending Requests</h3>
                    <div id="pending-requests-list"></div>
                </div>
            </div>
        </div>
        <div class="sidebar-right" id="workflow-area" style="display: none;">
            <h3>Tasks</h3>
            <div id="workflow-list" class="skeleton-loading">
                <div class="skeleton-task-item"></div>
                <div class="skeleton-task-item"></div>
            </div>
        </div>
        
        <!-- Choose Connection Message -->
        <div class="sidebar-right" id="choose-connection-message">
            <div class="choose-connection-content">
                
                <h3>Choose a Connection</h3>
                <p>Select a professional from your connections to view and work on tasks together.</p>
                
                <div class="connection-steps">
                    <div class="step">
                        <div class="step-number">1</div>
                        <div class="step-text">Browse your connections in the left sidebar</div>
                    </div>
                    <div class="step">
                        <div class="step-number">2</div>
                        <div class="step-text">Click on a professional to start collaborating</div>
                    </div>
                    <div class="step">
                        <div class="step-number">3</div>
                        <div class="step-text">View tasks and chat with your selected connection</div>
                    </div>
                </div>
                
                <!-- Invite to Connect Button - moved to bottom -->
                <div style="text-align: center; margin-top: 3rem; padding-top: 2rem; border-top: 1px solid #e0e0e0;">
                    <button id="invite-connect-btn-tasks" style="
                        font-size: 14px; 
                        padding: 10px 20px; 
                        background: #f8f9fa; 
                        border: 1px solid #dee2e6; 
                        color: #495057;
                        border-radius: 6px;
                        font-weight: 400;
                        cursor: pointer;
                        transition: all 0.2s;
                        font-family: 'Poppins', sans-serif;
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                    " onmouseover="this.style.background='#e9ecef'; this.style.borderColor='#adb5bd'" onmouseout="this.style.background='#f8f9fa'; this.style.borderColor='#dee2e6'">
                        <i class="fas fa-share-alt" style="font-size: 12px;"></i> Invite to Connect
                    </button>
                </div>
            </div>
        </div>
        <div class="chat-area" id="chat-area" style="display: none;">
            <div class="chat-header skeleton-loading" id="chat-header">
                <div class="skeleton-header"></div>
            </div>
            <div class="messages skeleton-loading" id="chat-messages">
                <div class="skeleton-message"></div>
                <div class="skeleton-message"></div>
            </div>
            <div class="chat-input">
                <div class="input-container">
                    <div class="upload-progress" id="upload-progress">
                        <div class="upload-progress-bar" id="upload-progress-bar"></div>
                    </div>
                    <textarea id="chat-input" placeholder="Type a message..." rows="1"></textarea>
                    <i class="fas fa-at mention-icon" id="mention-icon"></i>
                    <label for="file-input" class="file-input-label"><i class="fas fa-paperclip"></i></label>
                    <input type="file" id="file-input" class="file-input">
                    <div class="task-dropdown" id="task-dropdown"></div>
                </div>
                <button onclick="sendMessage()"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
        
        <!-- Chat Toggle Button (appears when chat is hidden) -->
        
    </div>
    <div class="chat-toggle-btn" id="chat-toggle-btn" style="display: none;">
        <i class="fas fa-comments"></i>
        <span>Chat</span>
    </div>

    <div class="confirmation-dialog" id="confirmation-dialog">
        <div class="dialog-box">
            <h3 id="dialog-title"></h3>
            <p id="dialog-message"></p>
            <div class="dialog-actions">
                <button class="cancel" onclick="closeConfirmation()">Cancel</button>
                <button id="confirm-button" class="confirm"></button>
            </div>
        </div>
    </div>

    <!-- File Viewer Modal -->
    <div class="file-viewer-modal" id="file-viewer-modal">
        <div class="modal-content">
            <button class="close-modal" onclick="closeFileViewer()">
                <i class="fas fa-times"></i>
            </button>
            <div class="file-content" id="file-content"></div>
        </div>
    </div>

    <!-- Submission Modal -->
    <div class="submission-modal" id="submission-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add Submission</h3>
                <button class="close-modal" onclick="closeSubmissionModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="submission-comment">Comment (Optional)</label>
                    <textarea id="submission-comment" placeholder="Add a comment about this submission..." rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label for="submission-files">Upload Files</label>
                    <button type="button" class="upload-btn" id="upload-btn">Upload Files</button>
                    <input type="file" id="submission-files" multiple accept="*/*" style="display:none;">
                    <div class="uploaded-files" id="uploaded-files"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeSubmissionModal()">Cancel</button>
                <button class="btn-primary" onclick="submitWork()">Submit Work</button>
            </div>
        </div>
    </div>

    <!-- Comment Modal -->
    <div class="comment-modal" id="comment-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add Comment</h3>
                <button class="close-modal" onclick="closeCommentModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="comment-text">Comment</label>
                    <textarea id="comment-text" placeholder="Add your comment..." rows="5"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeCommentModal()">Cancel</button>
                <button class="btn-primary" onclick="submitComment()">Add Comment</button>
            </div>
        </div>
    </div>

    <!-- Files Popup -->
    <div class="files-popup" id="files-popup">
        <div class="popup-content">
            <div class="popup-header">
                <h4>Attached Files</h4>
                <button class="close-popup" onclick="closeFilesPopup()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="popup-body" id="files-popup-body">
                <!-- Files will be populated here -->
            </div>
        </div>
    </div>

    <!-- Assigned Task Details Modal -->
    <div class="assigned-task-modal" id="assigned-task-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="assigned-task-title">Task Details</h3>
                <button onclick="closeAssignedTaskModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body" id="assigned-task-body">
                <!-- Task details will be populated here -->
            </div>
            <div class="modal-actions" id="assigned-task-actions">
                <!-- Action buttons will be populated here -->
            </div>
        </div>
    </div>

    <!-- Success Modal -->
    <div class="success-modal" id="success-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="success-title">Success!</h3>
                <button onclick="closeSuccessModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="success-message" id="success-message">
                    <!-- Success message will be populated here -->
                </div>
            </div>
            <div class="modal-actions">
                <button class="success-btn" onclick="closeSuccessModal()">Continue</button>
            </div>
        </div>
    </div>

    <!-- Task Acceptance Modal -->
    <div class="task-acceptance-modal" id="task-acceptance-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Accept Task</h3>
                <button onclick="closeTaskAcceptanceModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="task-plan">Your Plan & Approach</label>
                    <textarea id="task-plan" placeholder="Describe your plan for completing this task, your approach, and any initial thoughts..."></textarea>
                </div>
                <div class="form-group">
                    <label for="task-questions">Questions & Clarifications</label>
                    <textarea id="task-questions" placeholder="Ask any questions you have about the task, request clarifications, or discuss requirements..."></textarea>
                </div>
                <div class="form-group">
                    <label for="task-timeline">Timeline & Milestones</label>
                    <textarea id="task-timeline" placeholder="Outline your proposed timeline, key milestones, and when you expect to deliver the work..."></textarea>
                </div>
            </div>
            <div class="modal-actions">
                <button class="cancel-btn" onclick="closeTaskAcceptanceModal()">Cancel</button>
                <button class="accept-btn" id="confirm-accept-btn" onclick="confirmAcceptTask()">Accept Task</button>
            </div>
        </div>
    </div>

    <!-- Task Rejection Modal -->
    <div class="task-rejection-modal" id="task-rejection-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Reject Task</h3>
                <button onclick="closeTaskRejectionModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="rejection-reason">Reason for Rejection</label>
                    <textarea id="rejection-reason" placeholder="Please provide a reason for rejecting this task. This helps us improve our task matching process..." rows="4" required></textarea>
                </div>
            </div>
            <div class="modal-actions">
                <button class="cancel-btn" onclick="closeTaskRejectionModal()">Cancel</button>
                <button class="reject-btn" id="confirm-reject-btn" onclick="submitTaskRejection()">Submit Rejection</button>
            </div>
        </div>
    </div>

    <audio id="message-ding" src="../assets/ding.mp3"></audio>

    <script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
import { getDatabase, ref, get, push, set, onValue, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";
import { getAuth } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
import { getStorage, ref as storageRef, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-storage.js";

const firebaseConfig = {
    apiKey: "AIzaSyDZIDlEtaNRxODoFhRw0xF2yYFBqqBexqo",
    authDomain: "taska-45011.firebaseapp.com",
    databaseURL: "https://taska-45011-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "taska-45011",
    storageBucket: "gs://taska-45011.firebasestorage.app",
    messagingSenderId: "205487498813",
    appId: "1:205487498813:web:0de2c9eab567482781ec54",
    measurementId: "G-G0G1F6GQ9B"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);
const storage = getStorage(app);

let userId = null;
let selectedProfessionalId = null;
let professionalData = null;
let currentUserProfile = null;
let uploadedTaskFiles = [];
let submissionFiles = []; // Add missing variable declaration
let isDataLoaded = { connections: false, chats: false, tasks: false };
let currentTaskId = null;
let editingTaskId = null;
let currentChatListener = null;

// Add message cache
let messageCache = new Map(); // Cache for messages by chatId
let lastMessageTimestamps = new Map(); // Track last message timestamps by chatId

const elements = {
    connectionsList: document.getElementById('connections-list'),
    pendingRequestsList: document.getElementById('pending-requests-list'),
    chatArea: document.getElementById('chat-area'),
    chatHeader: document.getElementById('chat-header'),
    chatMessages: document.getElementById('chat-messages'),
    chatInput: document.getElementById('chat-input'),
    workflowArea: document.getElementById('workflow-area'),
    workflowList: document.getElementById('workflow-list'),
    completedTasksList: document.getElementById('completed-tasks-list'),
    confirmationDialog: document.getElementById('confirmation-dialog'),
    dialogTitle: document.getElementById('dialog-title'),
    dialogMessage: document.getElementById('dialog-message'),
    confirmButton: document.getElementById('confirm-button'),
    messageDing: document.getElementById('message-ding'),
    fileInput: document.getElementById('file-input'),
    uploadProgress: document.getElementById('upload-progress'),
    uploadProgressBar: document.getElementById('upload-progress-bar'),
    mentionIcon: document.getElementById('mention-icon'),
    taskDropdown: document.getElementById('task-dropdown'),
    chatToggleBtn: document.getElementById('chat-toggle-btn'),
    fileViewerModal: document.getElementById('file-viewer-modal'),
    fileContent: document.getElementById('file-content'),
    submissionModal: document.getElementById('submission-modal'),
    commentModal: document.getElementById('comment-modal'),
    assignedTasksList: document.getElementById('assigned-tasks-list'),
    assignedTaskModal: document.getElementById('assigned-task-modal'),
    assignedTaskTitle: document.getElementById('assigned-task-title'),
    assignedTaskBody: document.getElementById('assigned-task-body'),
    assignedTaskActions: document.getElementById('assigned-task-actions'),
    successModal: document.getElementById('success-modal'),
    successTitle: document.getElementById('success-title'),
    successMessage: document.getElementById('success-message'),
    taskRejectionModal: document.getElementById('task-rejection-modal'),
    rejectionReason: document.getElementById('rejection-reason')
};

// Function to load profile image from Firebase Storage
async function loadProfileImage(userId) {
    try {
        const profilePhotoRef = storageRef(storage, `profile/${userId}.webp`);
        const profilePhotoUrl = await getDownloadURL(profilePhotoRef);
        return profilePhotoUrl;
    } catch (error) {
        console.log(`No profile photo found for user ${userId}, using default avatar`);
        return "../assets/avatar/1.png";
    }
}

async function fetchProfessionalData() {
    if (professionalData) return professionalData;
    try {
        const snapshot = await get(ref(db, 'professionalslist'));
        const data = snapshot.val() || {};
        professionalData = Object.keys(data).map(id => ({
            id,
            ...data[id],
            personal: data[id].personal || {},
            education: data[id].education || {},
            skills: data[id].skills || '',
            profiles: data[id].profiles || {},
            portfolio: data[id].portfolio || []
        }));
        return professionalData;
    } catch (error) {
        console.error('Error fetching professional data:', error);
        return [];
    }
}

async function fetchCurrentUserProfile() {
    if (currentUserProfile) return currentUserProfile;
    try {
        const snapshot = await get(ref(db, `studentslist/${userId}`));
        const user = snapshot.val() || {};
        const profilePic = await loadProfileImage(userId);
        currentUserProfile = {
            name: user.personal?.name || "Unnamed",
            profilePic: profilePic
        };
        return currentUserProfile;
    } catch (error) {
        console.error('Error fetching current user profile:', error);
        return { name: "Unnamed", profilePic: "../assets/avatar/1.png" };
    }
}

function confirmAction(action, title, message, actionParams = {}) {
    elements.dialogTitle.textContent = title;
    elements.dialogMessage.textContent = message;
    elements.confirmationDialog.classList.add('active');
    elements.confirmButton.textContent = title.includes('Delete') ? 'Delete' : 'Confirm';
    elements.confirmButton.className = title.includes('Delete') ? 'delete' : 'confirm';
    elements.confirmButton.onclick = () => {
        window[action](actionParams);
        closeConfirmation();
    };
}

function closeConfirmation() {
    elements.confirmationDialog.classList.remove('active');
}

function getFileIconClass(type) {
    if (type.includes('pdf')) return 'fas fa-file-pdf';
    if (type.includes('image')) return 'fas fa-file-image';
    if (type.includes('video')) return 'fas fa-file-video';
    if (type.includes('excel') || type.includes('spreadsheet')) return 'fas fa-file-excel';
    if (type.includes('word') || type.includes('doc')) return 'fas fa-file-word';
    return 'fas fa-file';
}

function getFileIconColor(type) {
    if (type.includes('pdf')) return '#FF5252';
    if (type.includes('image')) return '#4CAF50';
    if (type.includes('video')) return '#2196F3';
    if (type.includes('excel') || type.includes('spreadsheet')) return '#2E7D32';
    if (type.includes('word') || type.includes('doc')) return '#1976D2';
    return '#6c757d';
}

function isImageFile(type) {
    return type.startsWith('image/');
}

function isVideoFile(type) {
    return type.startsWith('video/');
}

// Helper function to truncate file names
function truncateFileName(fileName, maxLength = 25) {
    if (fileName.length <= maxLength) return fileName;
    const extension = fileName.split('.').pop();
    const nameWithoutExt = fileName.substring(0, fileName.lastIndexOf('.'));
    const maxNameLength = maxLength - extension.length - 4; // 4 for "..."
    return nameWithoutExt.substring(0, maxNameLength) + '...' + extension;
}

function generateFileThumbnail(file) {
    if (isImageFile(file.type)) {
        return `
            <div class="file-thumbnail image-thumbnail">
                <img src="${file.url}" alt="${file.name}" loading="lazy">
                <div class="file-overlay">
                    <i class="fas fa-eye"></i>
                </div>
            </div>
        `;
    } else if (isVideoFile(file.type)) {
        return `
            <div class="file-thumbnail video-thumbnail">
                <video src="${file.url}" preload="metadata"></video>
                <div class="file-overlay">
                    <i class="fas fa-play"></i>
                </div>
            </div>
        `;
    } else {
        return `
            <a href="${file.url}" download="${file.name}" class="file-icon-container" title="${file.name}">
                <i class="${getFileIconClass(file.type)} file-icon" style="color: ${getFileIconColor(file.type)};"></i>
            </a>
        `;
    }
}

function checkAllDataLoaded() {
    if (isDataLoaded.connections && isDataLoaded.chats && isDataLoaded.tasks) {
        elements.connectionsList.classList.remove('skeleton-loading');
        elements.chatArea.classList.remove('skeleton-loading');
        elements.chatHeader.classList.remove('skeleton-loading');
        elements.chatMessages.classList.remove('skeleton-loading');
        elements.workflowList.classList.remove('skeleton-loading');
    }
}

// Initialize the app
async function init() {
    document.addEventListener('DOMContentLoaded', async () => {
        await fetchProfessionalData();
        setupEventListeners();
        
        // Show choose connection message by default
        const chooseConnectionMessage = document.getElementById('choose-connection-message');
        if (chooseConnectionMessage) {
            chooseConnectionMessage.style.display = 'flex';
        }
        
        // Hide workflow area initially
        if (elements.workflowArea) {
            elements.workflowArea.style.display = 'none';
        }
        
        // Add page unload event listener for cache cleanup
        window.addEventListener('beforeunload', () => {
            clearMessageCache();
            if (currentChatListener) {
                currentChatListener();
            }
        });
        
        // Add visibility change listener to manage cache when tab becomes hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                manageCacheSize();
            }
        });
        
        auth.onAuthStateChanged(async user => {
            if (user) {
                userId = user.uid;
                await fetchCurrentUserProfile();
                loadAssignedTasks();
                loadConnections();
                loadPendingRequests();
                // Remove loadWorkflows() and checkAndShowWorkflowArea() calls
                // Workflow area will be shown only when a professional is selected
                // Start real-time monitoring for promotions
                startRealTimeMonitoring();
            } else {
                console.error("User not authenticated");
                window.location.href = "../index.html";
            }
        });
    });
}

// Start real-time monitoring for student assignment changes
function startRealTimeMonitoring() {
    const assignedTasksRef = ref(db, `students/${userId}/assignedTasks`);
    onValue(assignedTasksRef, (snapshot) => {
        if (snapshot.exists()) {
            const tasks = snapshot.val();
            // Check for newly promoted tasks
            for (const taskId in tasks) {
                const task = tasks[taskId];
                if (task.promotedAt && task.assignmentType === 'primary' && task.status === 'pending') {
                    // This is a newly promoted task
                    showPromotionNotification(task);
                }
            }
        }
    });
    
    // Start real-time monitoring for pending connection requests
    const connectionsRef = ref(db, `users/${userId}/connections`);
    onValue(connectionsRef, (snapshot) => {
        if (snapshot.exists()) {
            const connections = snapshot.val();
            // Check for new pending requests
            for (const requesterId in connections) {
                const connection = connections[requesterId];
                if (connection.status === 'pending' && connection.timestamp) {
                    // Check if this is a new request (within last 5 seconds)
                    const requestTime = new Date(connection.timestamp);
                    const now = new Date();
                    const timeDiff = (now - requestTime) / 1000; // in seconds
                    
                    if (timeDiff < 5) {
                        // This is a new request, show notification
                        showConnectionRequestNotification(requesterId, connection);
                    }
                }
            }
        }
    });
}

// Show notification when student is promoted from waitlist to primary
function showPromotionNotification(task) {
    // Create a temporary notification element
    const notification = document.createElement('div');
    notification.className = 'promotion-notification';
    notification.innerHTML = `
        <div class="notification-content">
            <i class="fas fa-arrow-up"></i>
            <div class="notification-text">
                <strong>You've been promoted!</strong>
                <p>You are now the primary student for "${task.title}"</p>
            </div>
            <button class="notification-close" onclick="this.parentElement.parentElement.remove()">
                <i class="fas fa-times"></i>
            </button>
        </div>
    `;
    
    // Add to page
    document.body.appendChild(notification);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.remove();
        }
    }, 10000);
    
    // Reload assigned tasks to show the new primary assignment
    loadAssignedTasks();
}

// Show notification when new connection request arrives
async function showConnectionRequestNotification(requesterId, connection) {
    try {
        // Fetch requester details
        const professionals = await fetchProfessionalData();
        const studentsRef = ref(db, 'studentslist');
        const studentsSnapshot = await get(studentsRef);
        const students = studentsSnapshot.exists() ? studentsSnapshot.val() : {};
        
        const professional = professionals.find(p => p.id === requesterId);
        const student = students[requesterId];
        
        let userName = "Someone";
        let userRole = "user";
        
        if (professional) {
            userName = professional.personal?.name || "A Professional";
            userRole = "professional";
        } else if (student) {
            userName = student.personal?.name || "A Student";
            userRole = "student";
        }
        
        // Create notification element
        const notification = document.createElement('div');
        notification.className = 'promotion-notification';
        notification.innerHTML = `
            <div class="notification-content">
                <i class="fas fa-user-plus"></i>
                <div class="notification-text">
                    <strong>New Connection Request!</strong>
                    <p>${userName} (${userRole}) wants to connect with you on Taska. Would you like to accept this connection request?</p>
                </div>
                <button class="notification-close" onclick="this.parentElement.parentElement.remove()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;
        
        // Add to page
        document.body.appendChild(notification);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 10000);
        
        // Reload pending requests to show the new request
        loadPendingRequests();
        
    } catch (error) {
        console.error('Error showing connection request notification:', error);
    }
}

function setupEventListeners() {
    // Setup hamburger menu
    const hamburger = document.querySelector('.navbar_classified .hamburger');
    const navMenu = document.querySelector('.navbar_classified .nav-menu');
    if (hamburger && navMenu) {
        hamburger.addEventListener('click', () => navMenu.classList.toggle('active'));
    }

    // Setup event listeners for the workplace
    document.addEventListener('click', (e) => {
        // Handle task menu dropdowns
        if (!e.target.closest('.task-menu')) {
            document.querySelectorAll('.task-menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        if (!e.target.closest('.message-menu')) {
            document.querySelectorAll('.message-menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        // --- Chat header menu (three-dot) event delegation ---
        if (!e.target.closest('.chat-header .menu')) {
            document.querySelectorAll('.chat-header .menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        if (e.target.matches('.chat-header .menu-icon')) {
            const dropdown = e.target.closest('.menu').querySelector('.menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (e.target.matches('.chat-header .menu-dropdown button')) {
            const action = e.target.dataset.action;
            if (action === 'deleteConnection') {
                confirmAction('deleteConnection', 'Delete Connection', 'Are you sure you want to delete this connection?', { professionalId: selectedProfessionalId });
            }
        }
        // --- End chat header menu fix ---
        if (!e.target.closest('.input-container')) {
            elements.taskDropdown.classList.remove('active');
        }

        // --- Fix: Task menu (three-dot) event delegation ---
        if (e.target.matches('.task-menu-icon')) {
            const dropdown = e.target.closest('.task-menu').querySelector('.task-menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (e.target.matches('.task-menu-dropdown button')) {
            const action = e.target.dataset.action;
            const taskId = e.target.closest('.workflow-item').dataset.taskId;
            if (action === 'deleteTask') {
                openTaskRejectionModal(taskId);
            }
        }
        // --- End fix ---

        // Handle connection clicks
        if (e.target.closest('.user-item')) {
            console.log('Connection item clicked');
            const userItem = e.target.closest('.user-item');
            const connectionId = userItem.dataset.connectionId;
            const connectionType = userItem.dataset.connectionType;
            console.log('Connection ID from dataset:', connectionId, 'Type:', connectionType);
            if (connectionId) {
                if (connectionType === 'professional') {
                    console.log('Calling selectProfessional with:', connectionId);
                    selectProfessional(connectionId);
                } else if (connectionType === 'student') {
                    console.log('Student connection clicked - not yet implemented for collaboration');
                    alert('Student connections are not yet fully implemented for collaboration.');
                }
            }
        }
        
        // Handle chat toggle button clicks
        if (e.target.closest('.chat-toggle-btn')) {
            console.log('Chat toggle button clicked');
            showChat();
        }
        
        // Hide chat when clicking outside
        if (elements.chatArea && elements.chatArea.style.display === 'block' && 
            !e.target.closest('.chat-area') && 
            !e.target.closest('.chat-toggle-btn') &&
            !e.target.closest('.confirmation-dialog')) {
            hideChat();
        }

        // Add event delegation for .reaction-icon
        if (e.target.matches('.reaction-icon')) {
            const messageId = e.target.closest('.message').dataset.messageId;
            const reaction = e.target.dataset.reaction;
            toggleReaction(messageId, reaction);
        }

        // Message menu (three-dot) event delegation
        if (e.target.matches('.message-menu-icon')) {
            const dropdown = e.target.closest('.message-menu').querySelector('.message-menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (e.target.matches('.message-menu-dropdown button')) {
            const action = e.target.dataset.action;
            const messageId = e.target.closest('.message').dataset.messageId;
            if (action === 'deleteMessage') {
                confirmAction('deleteMessage', 'Delete Message', 'Are you sure you want to delete this message?', { messageId });
            }
        }
        if (!e.target.closest('.message-menu')) {
            document.querySelectorAll('.message-menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
    });

    // Add file input event listeners for submission modal
    const submissionFileInput = document.getElementById('submission-files');
    const fileUploadArea = document.getElementById('file-upload-area');
    
    console.log('Setting up file upload listeners...');
    console.log('submissionFileInput:', submissionFileInput);
    console.log('fileUploadArea:', fileUploadArea);
    
    if (submissionFileInput) {
        submissionFileInput.addEventListener('change', handleSubmissionFileSelect);
        console.log('Added change listener to submissionFileInput');
    } else {
        console.error('submissionFileInput not found!');
    }
    
    if (fileUploadArea) {
        // Drag and drop functionality
        fileUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileUploadArea.classList.add('drag-over');
        });
        
        fileUploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            fileUploadArea.classList.remove('drag-over');
        });
        
        fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUploadArea.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files);
            handleSubmissionFiles(files);
        });
        
        // Click to browse
        fileUploadArea.addEventListener('click', () => {
            console.log('File upload area clicked, triggering file input...');
            submissionFileInput.click();
        });
        
        console.log('Added all listeners to fileUploadArea');
    } else {
        console.error('fileUploadArea not found!');
    }

    // Add file input event listeners for chat
    if (elements.fileInput) {
        elements.fileInput.addEventListener('change', handleChatFileSelect);
    }

    // Add mention functionality
    if (elements.mentionIcon) {
        elements.mentionIcon.addEventListener('click', () => {
            elements.taskDropdown.classList.toggle('active');
            populateTaskDropdown();
        });
    }

    if (elements.chatInput) {
        elements.chatInput.addEventListener('input', () => {
            const value = elements.chatInput.value;
            const lastAtIndex = value.lastIndexOf('@');
            if (lastAtIndex >= 0) {
                const afterAt = value.substring(lastAtIndex + 1);
                if (afterAt.length > 0) {
                    populateTaskDropdown();
                    elements.taskDropdown.classList.add('active');
                } else {
                    elements.taskDropdown.classList.remove('active');
                }
            } else {
                elements.taskDropdown.classList.remove('active');
            }
            
            // Auto-resize textarea
            elements.chatInput.style.height = 'auto';
            elements.chatInput.style.height = `${Math.min(elements.chatInput.scrollHeight, 100)}px`;
        });

        elements.chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    }
}

// Add these new functions for file handling
function handleSubmissionFileSelect(event) {
    console.log('handleSubmissionFileSelect called!');
    console.log('Files selected:', event.target.files);
    const files = Array.from(event.target.files);
    handleSubmissionFiles(files);
    event.target.value = '';
}

function handleSubmissionFiles(files) {
    files.forEach(file => {
        // Check if file is already added
        const isDuplicate = submissionFiles.some(existingFile => 
            existingFile.name === file.name && existingFile.size === file.size
        );
        
        if (!isDuplicate) {
            submissionFiles.push(file);
        }
    });
    updateUploadedFiles();
}

function handleChatFileSelect(event) {
    const file = event.target.files[0];
    if (file) {
        sendFileMessage(file);
    }
    // Reset the input
    event.target.value = '';
}

async function loadPendingRequests() {
    if (!elements.pendingRequestsList) return;
    try {
        const connectionsRef = ref(db, `users/${userId}/connections`);
        const snapshot = await get(connectionsRef);
        elements.pendingRequestsList.innerHTML = '';
        const pendingRequestsSection = document.querySelector('.pending-requests');
        
        if (snapshot.exists()) {
            const connections = snapshot.val();
            let hasPending = false;
            
            // Fetch both professional and student data to handle requests from both
            const professionals = await fetchProfessionalData();
            const studentsRef = ref(db, 'studentslist');
            const studentsSnapshot = await get(studentsRef);
            const students = studentsSnapshot.exists() ? studentsSnapshot.val() : {};
            
            for (const requesterId in connections) {
                if (connections[requesterId].status === "pending") {
                    hasPending = true;
                    
                    // Determine if requester is a professional or student
                    const professional = professionals.find(p => p.id === requesterId);
                    const student = students[requesterId];
                    
                    let userName = "Unnamed";
                    let userRole = "user";
                    
                    if (professional) {
                        userName = professional.personal?.name || "Unnamed Employer";
                        userRole = "professional";
                    } else if (student) {
                        userName = student.personal?.name || "Unnamed Student";
                        userRole = "student";
                    }
                    
                    const profilePic = await loadProfileImage(requesterId);
                    
                    const pendingItem = document.createElement('div');
                    pendingItem.className = 'pending-item user-item';
                    pendingItem.dataset.requesterId = requesterId;
                    pendingItem.innerHTML = `
                        <div class="user-info">
                            <img src="${profilePic}" class="profile-pic" onerror="this.src='../assets/avatar/1.png'">
                            <div class="user-details">
                                <div class="name">${userName}</div>
                                <div class="role">${userRole}</div>
                            </div>
                        </div>
                        <div class="actions">
                            <button class="accept-btn" onclick="acceptRequest('${requesterId}')">
                                <i class="fas fa-check"></i> Accept
                            </button>
                            <button class="delete-btn" onclick="deleteRequest('${requesterId}')">
                                <i class="fas fa-times"></i> Delete
                            </button>
                        </div>
                    `;
                    
                    elements.pendingRequestsList.appendChild(pendingItem);
                }
            }
            
            pendingRequestsSection.style.display = hasPending ? 'block' : 'none';
        } else {
            pendingRequestsSection.style.display = 'none';
        }
    } catch (error) {
        console.error("Error loading pending requests:", error);
        elements.pendingRequestsList.innerHTML = '<p>Error loading pending requests.</p>';
        document.querySelector('.pending-requests').style.display = 'none';
    }
}

function checkAndShowWorkflowArea() {
    // Check if there are tasks and show workflow area
    const tasksRef = ref(db, `tasks`);
    onValue(tasksRef, (snapshot) => {
        if (snapshot.exists()) {
            const tasks = snapshot.val();
            let hasTasks = false;
            
            for (const taskId in tasks) {
                const task = tasks[taskId];
                if (task.studentId === userId) {
                    hasTasks = true;
                    break;
                }
            }
            
            if (hasTasks && elements.workflowArea) {
                elements.workflowArea.style.display = 'block';
            }
        }
    });
}

async function loadConnections() {
    if (!elements.connectionsList) return;
    try {
        const connectionsRef = ref(db, `users/${userId}/connections`);
        const snapshot = await get(connectionsRef);
        elements.connectionsList.innerHTML = '';
        if (snapshot.exists()) {
            const connections = snapshot.val();
            let hasConnections = false;
            
            // Fetch both professional and student data
            const professionals = await fetchProfessionalData();
            const studentsRef = ref(db, 'studentslist');
            const studentsSnapshot = await get(studentsRef);
            const students = studentsSnapshot.exists() ? studentsSnapshot.val() : {};
            
            for (const connectionId in connections) {
                if (connections[connectionId].status === "connected") {
                    hasConnections = true;
                    
                    // Determine if connection is a professional or student
                    const professional = professionals.find(p => p.id === connectionId);
                    const student = students[connectionId];
                    
                    let userName = "Unnamed";
                    let userRole = "user";
                    
                    if (professional) {
                        userName = professional.personal?.name || "Unnamed Professional";
                        userRole = "professional";
                    } else if (student) {
                        userName = student.personal?.name || "Unnamed Student";
                        userRole = "student";
                    }
                    
                    const profilePic = await loadProfileImage(connectionId);
                    const chatId = [userId, connectionId].sort().join("+");
                    const chatRef = ref(db, `chats/${chatId}/messages`);
                    let lastMessage = "No messages yet";
                    let hasUnread = false;
                    const chatSnapshot = await get(chatRef);
                    if (chatSnapshot.exists()) {
                        const messages = Object.values(chatSnapshot.val());
                        const lastMsg = messages[messages.length - 1];
                        lastMessage = lastMsg.file ? `[File] ${lastMsg.file.name}` : lastMsg.content || "No messages yet";
                        hasUnread = messages.some(msg => msg.senderId !== userId && !msg.read);
                    }
                    
                    const userItem = document.createElement('div');
                    userItem.className = 'user-item';
                    userItem.dataset.connectionId = connectionId;
                    userItem.dataset.connectionType = professional ? 'professional' : 'student';
                    userItem.innerHTML = `
                        <img src="${profilePic}" alt="${userName}" class="profile-pic" onerror="this.src='../assets/avatar/1.png'">
                        <div class="user-info">
                            <div class="name">${userName}</div>
                            <div class="last-message">${lastMessage}</div>
                        </div>
                        ${hasUnread ? '<div class="unread-dot"></div>' : ''}
                    `;
                    
                    // Add click event listener to the user item
                    userItem.addEventListener('click', () => {
                        if (professional) {
                            selectProfessional(connectionId);
                        } else {
                            // For students, you might want to implement a different selection logic
                            // For now, we'll just show a message
                            alert('Student connections are not yet fully implemented for collaboration.');
                        }
                    });
                    
                    elements.connectionsList.appendChild(userItem);
                }
            }
            if (!hasConnections) {
                elements.connectionsList.innerHTML = '<p>No connected users found.</p>';
            }
        } else {
            elements.connectionsList.innerHTML = '<p>No connected users found.</p>';
        }
        isDataLoaded.connections = true;
        checkAllDataLoaded();
    } catch (error) {
        console.error("Error loading connections:", error);
        elements.connectionsList.innerHTML = '<p>Error loading connections.</p>';
        isDataLoaded.connections = true;
        checkAllDataLoaded();
    }
}

async function loadChatHeader() {
    if (!elements.chatHeader) return;
    try {
        const professionals = await fetchProfessionalData();
        const professional = professionals.find(p => p.id === selectedProfessionalId) || {};
        const userName = professional.personal?.name || "Unnamed";
        const userTitle = professional.education?.branch || "";
        const profilePic = await loadProfileImage(selectedProfessionalId);
        elements.chatHeader.innerHTML = `
            <div style="display: flex; align-items: center; gap: 1rem;">
                <img src="${profilePic}" alt="${userName}" class="profile-pic">
                <div>
                    <div class="name">${userName}</div>
                    <div class="title">${userTitle}</div>
                </div>
            </div>
            <div class="chat-actions">
                <button class="hide-chat-btn" onclick="hideChat()" title="Hide Chat">
                    <i class="fas fa-chevron-right"></i>
                </button>
                <div class="menu">
                    <i class="fas fa-ellipsis-v menu-icon"></i>
                    <div class="menu-dropdown">
                        <button data-action="deleteConnection">Delete Connection</button>
                    </div>
                </div>
            </div>
        `;
    } catch (error) {
        console.error("Error loading chat header:", error);
        elements.chatHeader.innerHTML = `
            <div style="display: flex; align-items: center; gap: 1rem;">
                <img src="../assets/avatar/1.png" alt="Unnamed" class="profile-pic">
                <div>
                    <div class="name">Unnamed</div>
                    <div class="title"></div>
                </div>
            </div>
            <div class="chat-actions">
                <button class="hide-chat-btn" onclick="hideChat()" title="Hide Chat">
                    <i class="fas fa-chevron-right"></i>
                </button>
                <div class="menu">
                    <i class="fas fa-ellipsis-v menu-icon"></i>
                    <div class="menu-dropdown">
                        <button data-action="deleteConnection">Delete Connection</button>
                    </div>
                </div>
            </div>
        `;
    }
}

function formatMessageDate(timestamp) {
    const now = new Date();
    const messageDate = new Date(timestamp);
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
    const messageDay = new Date(messageDate.getFullYear(), messageDate.getMonth(), messageDate.getDate());
    if (messageDay.getTime() === today.getTime()) {
        return 'Today';
    } else if (messageDay.getTime() === yesterday.getTime()) {
        return 'Yesterday';
    } else {
        return messageDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
}

async function loadChat() {
    if (!elements.chatMessages) return;
    // Clean up previous listener if it exists
    if (currentChatListener) {
        currentChatListener();
        currentChatListener = null;
    }
    
    if (!selectedProfessionalId) return;
    
    const chatId = [userId, selectedProfessionalId].sort().join("+");
    
    // Clear the chat messages area immediately when switching professionals
    elements.chatMessages.innerHTML = '';
    
    // Manage cache size before loading new chat
    manageCacheSize();
    
    // Show skeleton loading only if no cached messages
    if (!messageCache.has(chatId) || messageCache.get(chatId).length === 0) {
        elements.chatMessages.innerHTML = `
            <div class="skeleton-message"></div>
            <div class="skeleton-message"></div>
        `;
    }
    
    const currentUser = await fetchCurrentUserProfile();
    
    // Store the listener reference so we can clean it up later
    currentChatListener = onValue(ref(db, `chats/${chatId}/messages`), async (snapshot) => {
        if (!snapshot.exists()) {
            elements.chatMessages.innerHTML = '<div class="message">No messages yet</div>';
            messageCache.set(chatId, []);
            lastMessageTimestamps.set(chatId, {});
            isDataLoaded.chats = true;
            checkAllDataLoaded();
            return;
        }

        const newMessages = Object.entries(snapshot.val())
            .map(([id, msg]) => ({ id, ...msg }))
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        const cachedMessages = messageCache.get(chatId) || [];
        const lastTimestamps = lastMessageTimestamps.get(chatId) || {};
        
        // Check if we need to do a full render or incremental update
        const needsFullRender = shouldDoFullRender(cachedMessages, newMessages, lastTimestamps);
        
        if (needsFullRender) {
            // Full render - clear and rebuild everything
            await renderAllMessages(newMessages, currentUser, chatId);
        } else {
            // Incremental update - only update changed messages
            await updateChangedMessages(cachedMessages, newMessages, currentUser, chatId);
        }
        
        // Update cache and timestamps
        messageCache.set(chatId, newMessages);
        const newTimestamps = {};
        newMessages.forEach(msg => {
            newTimestamps[msg.id] = msg.timestamp;
        });
        lastMessageTimestamps.set(chatId, newTimestamps);
        
        // Mark messages as read
        newMessages.forEach(msg => {
            if (msg.senderId !== userId && !msg.read) {
                update(ref(db, `chats/${chatId}/messages/${msg.id}`), { read: true });
            }
        });
        
        isDataLoaded.chats = true;
        checkAllDataLoaded();
    });
}

// Add this function for chat reactions
async function toggleReaction(messageId, reaction) {
    try {
        const chatId = [userId, selectedProfessionalId].sort().join("+");
        const messageRef = ref(db, `chats/${chatId}/messages/${messageId}`);
        const snapshot = await get(messageRef);
        if (snapshot.exists()) {
            const message = snapshot.val();
            const reactions = message.reactions || {};
            if (reactions[userId] === reaction) {
                delete reactions[userId];
            } else {
                reactions[userId] = reaction;
            }
            await update(messageRef, { reactions });
        }
    } catch (error) {
        console.error("Error toggling reaction:", error);
        alert("Failed to toggle reaction.");
    }
}

async function sendMessage() {
    if (!elements.chatInput) return;
    const content = elements.chatInput.value.trim();
    if (!content || !selectedProfessionalId) return;
    const chatId = [userId, selectedProfessionalId].sort().join("+");
    const messageRef = ref(db, `chats/${chatId}/messages`);
    try {
        const currentUser = await fetchCurrentUserProfile();
        const newMessage = {
            senderId: userId,
            senderName: currentUser.name,
            content,
            timestamp: new Date().toISOString(),
            read: false
        };
        await push(messageRef, newMessage);
        elements.chatInput.value = '';
        elements.chatInput.style.height = 'auto';
        elements.taskDropdown.classList.remove('active');
        if (elements.messageDing) {
            elements.messageDing.play().catch(error => console.error("Error playing ding sound:", error));
        }
    } catch (error) {
        console.error("Error sending message:", error);
        alert("Failed to send message.");
    }
}

async function sendFileMessage(file) {
    if (!selectedProfessionalId) return;
    const chatId = [userId, selectedProfessionalId].sort().join("+");
    const messageRef = ref(db, `chats/${chatId}/messages`);
    try {
        const storagePath = `chats/${chatId}/${Date.now()}_${file.name}`;
        const fileRef = storageRef(storage, storagePath);
        const uploadTask = uploadBytesResumable(fileRef, file);

        elements.uploadProgress.classList.add('active');
        elements.uploadProgressBar.style.width = '0%';

        uploadTask.on('state_changed',
            (snapshot) => {
                const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                elements.uploadProgressBar.style.width = `${progress}%`;
            },
            (error) => {
                console.error('Error uploading file:', error);
                elements.uploadProgress.classList.remove('active');
                alert('Failed to upload file.');
            },
            async () => {
                const fileUrl = await getDownloadURL(fileRef);
                const currentUser = await fetchCurrentUserProfile();
                const newMessage = {
                    senderId: userId,
                    senderName: currentUser.name,
                    file: {
                        name: file.name,
                        url: fileUrl,
                        type: file.type,
                        size: file.size
                    },
                    timestamp: new Date().toISOString(),
                    read: false
                };
                await push(messageRef, newMessage);
                elements.uploadProgress.classList.remove('active');
                if (elements.messageDing) {
                    elements.messageDing.play().catch(error => console.error("Error playing ding sound:", error));
                }
            }
        );
    } catch (error) {
        console.error("Error initiating file upload:", error);
        elements.uploadProgress.classList.remove('active');
        alert("Failed to upload file.");
    }
}

async function openTaskPopup(taskId = null) {
    alert('Students cannot create tasks. You can only edit existing tasks assigned to you.');
    return;
}

async function populateTaskDropdown() {
    try {
        const tasksRef = ref(db, `tasks`);
        const snapshot = await get(tasksRef);
        elements.taskDropdown.innerHTML = '';
        if (snapshot.exists()) {
            const tasks = snapshot.val();
            let taskFound = false;
            for (const id in tasks) {
                if (tasks[id].studentId === userId && tasks[id].professionalId === selectedProfessionalId) {
                    taskFound = true;
                    const taskItem = document.createElement('div');
                    taskItem.className = 'task-dropdown-item';
                    taskItem.textContent = tasks[id].title;
                    elements.taskDropdown.appendChild(taskItem);
                }
            }
            if (!taskFound) {
                elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">No tasks available</div>';
            }
        } else {
            elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">No tasks available</div>';
        }
    } catch (error) {
        console.error("Error populating task dropdown:", error);
        elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">Error loading tasks</div>';
    }
}

function insertMention(taskTitle) {
    const currentValue = elements.chatInput.value;
    const cursorPos = elements.chatInput.selectionStart;
    const textBefore = currentValue.substring(0, cursorPos);
    const textAfter = currentValue.substring(cursorPos);
    const lastAtIndex = textBefore.lastIndexOf('@');
    let newValue;
    if (lastAtIndex >= 0 && lastAtIndex === cursorPos - 1) {
        newValue = textBefore + taskTitle + ' ' + textAfter;
    } else {
        newValue = textBefore + '@' + taskTitle + ' ' + textAfter;
    }
    elements.chatInput.value = newValue;
    elements.chatInput.focus();
    const newCursorPos = lastAtIndex >= 0 ? lastAtIndex + taskTitle.length + 2 : cursorPos + taskTitle.length + 2;
    elements.chatInput.setSelectionRange(newCursorPos, newCursorPos);
    elements.taskDropdown.classList.remove('active');
    elements.chatInput.style.height = 'auto';
    elements.chatInput.style.height = `${Math.min(elements.chatInput.scrollHeight, 100)}px`;
}

function loadWorkflows() {
    if (!elements.workflowList) return;
    
    const tasksRef = ref(db, `tasks`);
    onValue(tasksRef, (snapshot) => {
        elements.workflowList.innerHTML = '';
        let hasTasks = false;
        
        if (snapshot.exists()) {
            const tasks = snapshot.val();
            const filteredTasks = [];
            
            // Filter and collect tasks for the current student
            for (const taskId in tasks) {
                const task = tasks[taskId];
                // Show tasks for the current student, either all tasks or filtered by selected professional
                if (task.studentId === userId && (!selectedProfessionalId || task.professionalId === selectedProfessionalId)) {
                    filteredTasks.push({ taskId, ...task });
                }
            }
            
            // Sort tasks by deadline (nearest first)
            filteredTasks.sort((a, b) => {
                const deadlineA = new Date(a.deadline);
                const deadlineB = new Date(b.deadline);
                return deadlineA - deadlineB;
            });
            
            // Create workflow items for sorted tasks
            filteredTasks.forEach(({ taskId, ...task }) => {
                hasTasks = true;
                const workflowItem = document.createElement('div');
                workflowItem.className = 'workflow-item';
                workflowItem.dataset.taskId = taskId;
                workflowItem.innerHTML = `
                    <div class="task-header">
                        <div class="task-info">
                        <h4>${task.title}</h4>
                            <p class="task-description">${task.description}</p>
                        </div>
                        <div class="task-menu">
                            <i class="fas fa-ellipsis-v task-menu-icon"></i>
                            <div class="task-menu-dropdown">
                                <button data-action="deleteTask" class="delete-task-btn">Reject Task</button>
                            </div>
                        </div>
                    </div>
                    <div class="task-meta">
                    <div class="deadline-container">
                            <div class="circular-progress">
                                <div class="circular-progress-ring">
                                    <svg class="progress-ring" width="60" height="60">
                                        <circle class="progress-ring-circle-bg" cx="30" cy="30" r="24" stroke-width="4"></circle>
                                        <circle class="progress-ring-circle" cx="30" cy="30" r="24" stroke-width="4" 
                                            stroke-dasharray="${2 * Math.PI * 24}" 
                                            stroke-dashoffset="${2 * Math.PI * 24 * (1 - calculateDeadlineProgress(task.deadline) / 100)}"
                                            style="stroke: ${getDeadlineColor(task.deadline)};"></circle>
                                    </svg>
                                    <div class="progress-text">
                                        <span class="days-number">${calculateDaysLeft(task.deadline)}</span>
                                        <span class="days-label">days</span>
                    </div>
                                </div>
                            </div>
                        </div>
                        ${task.files && Object.keys(task.files).length > 0 ? `
                            <div class="files-count" onclick="toggleFilesPopup('${taskId}', event)">
                                <i class="fas fa-paperclip"></i>
                                <span>${Object.keys(task.files).length} ${getFileTypeLabel(task.files)}</span>
                            </div>
                        ` : ''}
                    </div>
                    <div class="task-timeline">
                        <div class="timeline-header">
                            <h5>Submission Timeline</h5>
                            <div class="timeline-actions">
                                <button class="add-comment-btn" onclick="openCommentModal('${taskId}')">
                                    <i class="fas fa-comment"></i> Add Comment
                                </button>
                                <button class="add-submission-btn" onclick="openSubmissionModal('${taskId}')">
                                    <i class="fas fa-plus"></i> Add Submission
                                </button>
                            </div>
                        </div>
                        <div class="timeline-content" id="timeline-${taskId}">
                            ${generateTimelineHTML(task.submissions || {}, task.comments || {}, taskId)}
                        </div>
                    </div>
                `;
                elements.workflowList.appendChild(workflowItem);
            });
        }
        if (!hasTasks) {
            elements.workflowList.innerHTML = `
                <div class="no-tasks-message">
                    <div class="no-tasks-icon">
                        <i class="fas fa-clipboard-list"></i>
                    </div>
                    <h4>No tasks assigned now</h4>
                    <p>Chat with employer to get started</p>
                    
                </div>
            `;
        }
        isDataLoaded.tasks = true;
        checkAllDataLoaded();
        
        // Check and show workflow area if there are tasks
        if (hasTasks && elements.workflowArea) {
            elements.workflowArea.style.display = 'block';
        }
    });
}

function hideChat() {
    if (elements.chatArea) {
        elements.chatArea.classList.add('chat-hidden');
        setTimeout(() => {
            elements.chatArea.style.display = 'none';
        }, 300);
    }
    if (elements.chatToggleBtn) {
        elements.chatToggleBtn.style.display = 'flex';
    }
}

function showChat() {
    if (elements.chatArea) {
        elements.chatArea.style.display = 'block';
        elements.chatArea.classList.remove('chat-hidden');
    }
    if (elements.chatToggleBtn) {
        elements.chatToggleBtn.style.display = 'none';
    }
}

function openFileViewer(fileUrl, fileType, fileName) {
    if (elements.fileViewerModal && elements.fileContent) {
        let content = '';
        if (isImageFile(fileType)) {
            content = `<img src="${fileUrl}" alt="${fileName}" style="max-width: 100%; max-height: 80vh; object-fit: contain;">`;
        } else if (isVideoFile(fileType)) {
            content = `<video src="${fileUrl}" controls style="max-width: 100%; max-height: 80vh;"></video>`;
        }
        elements.fileContent.innerHTML = content;
        elements.fileViewerModal.classList.add('active');
    }
}

function closeFileViewer() {
    if (elements.fileViewerModal) {
        elements.fileViewerModal.classList.remove('active');
        if (elements.fileContent) {
            elements.fileContent.innerHTML = '';
        }
    }
}

function generateTimelineHTML(submissions, comments, taskId) {
    const allItems = [];
    
    // Add submissions
    if (submissions && Object.keys(submissions).length > 0) {
        Object.entries(submissions).forEach(([id, submission]) => {
            allItems.push({
                id,
                type: 'submission',
                ...submission
            });
        });
    }
    
    // Add comments
    if (comments && Object.keys(comments).length > 0) {
        Object.entries(comments).forEach(([id, comment]) => {
            allItems.push({
                id,
                type: 'comment',
                ...comment
            });
        });
    }
    
    if (allItems.length === 0) {
        return '<div class="timeline-empty">No submissions or comments yet</div>';
    }
    
    // Sort all items by timestamp (newest first)
    const sortedItems = allItems.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    return sortedItems.map(item => {
        if (item.type === 'submission') {
            const isApproved = item.status === 'approved';
            const approvalStatus = isApproved ? 'approved' : 'pending';
            const statusIcon = isApproved ? 'fa-check-circle' : 'fa-clock';
            const statusColor = isApproved ? '#4CAF50' : '#FFC107';
            
            return `
                <div class="timeline-item ${approvalStatus}">
                    <div class="timeline-marker">
                        <i class="fas fa-upload"></i>
                    </div>
                    <div class="timeline-item-content">
                        <div class="timeline-header">
                            <span class="submission-author">${item.authorName}</span>
                            <div class="timeline-item-actions">
                                <span class="submission-date">${formatSubmissionDate(item.timestamp)}</span>
                                <div class="submission-status">
                                    <i class="fas ${statusIcon}" style="color: ${statusColor};"></i>
                                    <span style="color: ${statusColor}; font-weight: 500;">${isApproved ? 'Approved' : 'Pending'}</span>
                                </div>
                                <div class="timeline-item-menu">
                                    <i class="fas fa-ellipsis-v timeline-menu-icon" onclick="toggleTimelineMenu('submission-${item.id}')"></i>
                                    <div class="timeline-menu-dropdown" id="submission-${item.id}">
                                        <button onclick="deleteSubmission('${item.id}', '${taskId}')" class="delete-btn">
                                            <i class="fas fa-trash"></i> Delete Submission
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        ${item.comment ? `<div class="submission-comment">${item.comment}</div>` : ''}
                        ${item.files ? `
                            <div class="submission-files">
                                ${Object.values(item.files).map(file => `
                                    <div class="submission-file">
                                        <div class="file-thumbnail-container">
                                            ${generateFileThumbnail(file)}
                                        </div>
                                        <div class="file-info">
                                            <div class="file-name">${file.name}</div>
                                            <div class="file-size">${file.size ? (file.size / 1024).toFixed(2) + ' KB' : 'Unknown size'}</div>
                                        </div>
                                        <div class="file-actions">
                                            <a href="${file.url}" download="${file.name}" class="download-btn" title="Download">
                                                <i class="fas fa-download"></i>
                                            </a>
                                            ${isImageFile(file.type) || isVideoFile(file.type) ? `
                                                <button class="view-btn" onclick="openFileViewer('${file.url}', '${file.type}', '${file.name}')" title="View">
                                                    <i class="fas fa-eye"></i>
                                                </button>
                                            ` : ''}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        ${isApproved && item.feedback ? `
                            <div class="approval-feedback">
                                <div class="feedback-header">
                                    <span style="color: #4CAF50; font-weight: 500;">Feedback</span>
                                </div>
                                <div class="feedback-content">${item.feedback}</div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        } else {
            return `
                <div class="timeline-item">
                    <div class="timeline-marker comment-marker">
                        <i class="fas fa-comment"></i>
                    </div>
                    <div class="timeline-item-content">
                        <div class="timeline-header">
                            <span class="comment-author">${item.authorName}</span>
                            <div class="timeline-item-actions">
                                <span class="comment-date">${formatSubmissionDate(item.timestamp)}</span>
                                <div class="timeline-item-menu">
                                    <i class="fas fa-ellipsis-v timeline-menu-icon" onclick="toggleTimelineMenu('comment-${item.id}')"></i>
                                    <div class="timeline-menu-dropdown" id="comment-${item.id}">
                                        <button onclick="deleteComment('${item.id}', '${taskId}')" class="delete-btn">
                                            <i class="fas fa-trash"></i> Delete Comment
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="comment-content">${formatCommentContent(item.content)}</div>
                    </div>
                </div>
            `;
        }
    }).join('');
}

function formatSubmissionDate(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diffTime = now - date;
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) {
        return 'Today at ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else if (diffDays === 1) {
        return 'Yesterday at ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else if (diffDays < 7) {
        return diffDays + ' days ago';
    } else {
        return date.toLocaleDateString();
    }
}

function formatCommentContent(content) {
    if (!content) return '';
    
    // Convert markdown-like formatting to HTML
    let formattedContent = content
        // Convert **text** to <strong>text</strong>
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        // Convert line breaks to <br> tags
        .replace(/\n/g, '<br>');
    
    return formattedContent;
}

function openSubmissionModal(taskId) {
    currentTaskId = taskId;
    if (elements.submissionModal) {
        elements.submissionModal.classList.add('active');
        submissionFiles = [];
        updateUploadedFiles();
        // Attach upload button and file input events after modal is visible
        setTimeout(() => {
            const uploadBtn = document.getElementById('upload-btn');
            const submissionFileInput = document.getElementById('submission-files');
            if (uploadBtn && submissionFileInput) {
                uploadBtn.onclick = () => submissionFileInput.click();
                submissionFileInput.removeEventListener('change', handleSubmissionFileSelect);
                submissionFileInput.addEventListener('change', handleSubmissionFileSelect);
            }
        }, 100);
    }
}

function closeSubmissionModal() {
    if (elements.submissionModal) {
        elements.submissionModal.classList.remove('active');
        currentTaskId = null;
        submissionFiles = [];
        document.getElementById('submission-comment').value = '';
        updateUploadedFiles();
    }
}

function updateUploadedFiles() {
    const uploadedFilesDiv = document.getElementById('uploaded-files');
    if (uploadedFilesDiv) {
        uploadedFilesDiv.innerHTML = submissionFiles.map((file, index) => `
            <div class="uploaded-file">
                <i class="${getFileIconClass(file.type)}"></i>
                <span>${file.name}</span>
                <button onclick="removeSubmissionFile(${index})" class="remove-file">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `).join('');
    }
}

function removeSubmissionFile(index) {
    submissionFiles.splice(index, 1);
    updateUploadedFiles();
}

async function submitWork() {
    if (!currentTaskId || submissionFiles.length === 0) {
        alert('Please upload at least one file');
        return;
    }
    
    // Get the submit button and show loading state
    const submitBtn = document.querySelector('.submission-modal .btn-primary');
    const originalText = submitBtn.textContent;
    submitBtn.textContent = 'Submitting...';
    submitBtn.classList.add('loading');
    submitBtn.disabled = true;
    
    try {
        const comment = document.getElementById('submission-comment').value.trim();
        const taskRef = ref(db, `tasks/${currentTaskId}`);
        const submissionsRef = ref(db, `tasks/${currentTaskId}/submissions`);
        
        // Upload files
        const uploadedFiles = {};
        for (let i = 0; i < submissionFiles.length; i++) {
            const file = submissionFiles[i];
            const storagePath = `tasks/${currentTaskId}/submissions/${Date.now()}_${i}_${file.name}`;
            const fileRef = storageRef(storage, storagePath);
            const uploadTask = uploadBytesResumable(fileRef, file);
            
            await new Promise((resolve, reject) => {
                uploadTask.on('state_changed',
                    () => {},
                    reject,
                    async () => {
                        const fileUrl = await getDownloadURL(fileRef);
                        uploadedFiles[`file_${i}`] = {
                            name: file.name,
                            url: fileUrl,
                            type: file.type,
                            size: file.size
                        };
                        resolve();
                    }
                );
            });
        }
        
        // Create submission
        const currentUser = await fetchCurrentUserProfile();
        const submission = {
            authorId: userId,
            authorName: currentUser.name,
            comment: comment,
            files: uploadedFiles,
            timestamp: new Date().toISOString()
        };
        
        await push(submissionsRef, submission);
        closeSubmissionModal();
        
        // Refresh the timeline
        loadWorkflows();
        
    } catch (error) {
        console.error('Error submitting work:', error);
        alert('Failed to submit work. Please try again.');
    } finally {
        // Reset button state
        submitBtn.textContent = originalText;
        submitBtn.classList.remove('loading');
        submitBtn.disabled = false;
    }
}

function getFileTypeLabel(files) {
    const fileArray = Object.values(files);
    if (fileArray.length === 0) return 'files';
    
    const imageCount = fileArray.filter(file => isImageFile(file.type)).length;
    const videoCount = fileArray.filter(file => isVideoFile(file.type)).length;
    const pdfCount = fileArray.filter(file => file.type.includes('pdf')).length;
    const documentCount = fileArray.filter(file => 
        file.type.includes('word') || 
        file.type.includes('doc') || 
        file.type.includes('excel') || 
        file.type.includes('spreadsheet')
    ).length;
    
    if (imageCount === fileArray.length) {
        return imageCount === 1 ? 'image' : 'images';
    } else if (videoCount === fileArray.length) {
        return videoCount === 1 ? 'video' : 'videos';
    } else if (pdfCount === fileArray.length) {
        return pdfCount === 1 ? 'PDF' : 'PDFs';
    } else if (documentCount === fileArray.length) {
        return documentCount === 1 ? 'document' : 'documents';
    } else {
        return fileArray.length === 1 ? 'file' : 'files';
    }
}

function toggleFilesPopup(taskId, event) {
    event.stopPropagation();
    const popup = document.getElementById('files-popup');
    const popupBody = document.getElementById('files-popup-body');
    
    if (popup.classList.contains('active')) {
        closeFilesPopup();
        return;
    }
    
    // Get task files
    const taskRef = ref(db, `tasks/${taskId}`);
    get(taskRef).then((snapshot) => {
        if (snapshot.exists()) {
            const task = snapshot.val();
            if (task.files) {
                const filesHTML = Object.values(task.files).map(file => `
                    <div class="popup-file-item">
                        <div class="file-icon-container">
                            <i class="${getFileIconClass(file.type)} file-icon" style="color: ${getFileIconColor(file.type)};"></i>
                        </div>
                        <div class="file-info">
                            <div class="file-name">${file.name}</div>
                            <div class="file-size">${file.size ? (file.size / 1024).toFixed(2) + ' KB' : 'Unknown size'}</div>
                        </div>
                        <div class="file-actions">
                            <a href="${file.url}" download="${file.name}" class="download-btn" title="Download">
                                <i class="fas fa-download"></i>
                            </a>
                            ${isImageFile(file.type) || isVideoFile(file.type) ? `
                                <button class="view-btn" onclick="openFileViewer('${file.url}', '${file.type}', '${file.name}')" title="View">
                                    <i class="fas fa-eye"></i>
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `).join('');
                
                popupBody.innerHTML = filesHTML;
            } else {
                popupBody.innerHTML = '<div class="no-files">No files attached</div>';
            }
        }
    });
    
    // Position popup to the left of the clicked element
    const rect = event.target.getBoundingClientRect();
    const popupWidth = 450;
    const screenWidth = window.innerWidth;
    
    console.log('Click position:', rect.left, 'Screen width:', screenWidth, 'Popup width:', popupWidth);
    
    // Force popup to the left of the cursor
    let leftPosition = rect.left - popupWidth - 20; // 20px gap from cursor
    
    console.log('Calculated left position:', leftPosition);
    
    // Only if popup would go off-screen to the left, then position it to the right
    if (leftPosition < 20) {
        leftPosition = rect.right + 20;
        console.log('Repositioned to right:', leftPosition);
    }
    
    // Ensure popup doesn't go off-screen to the right
    if (leftPosition + popupWidth > screenWidth - 20) {
        leftPosition = screenWidth - popupWidth - 20;
        console.log('Adjusted for right edge:', leftPosition);
    }
    
    // Final safety check
    leftPosition = Math.max(20, leftPosition);
    
    console.log('Final position:', leftPosition);
    
    popup.style.top = rect.top + 'px';
    popup.style.left = leftPosition + 'px';
    
    popup.classList.add('active');
}

function closeFilesPopup() {
    const popup = document.getElementById('files-popup');
    popup.classList.remove('active');
}

function calculateDaysLeft(deadline) {
    const now = new Date();
    const deadlineDate = new Date(deadline);
    const diffTime = deadlineDate - now;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays > 0 ? diffDays : 0;
}

function calculateDeadlineProgress(deadline) {
    const now = new Date();
    const deadlineDate = new Date(deadline);
    const diffTime = deadlineDate - now;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    if (diffDays <= 0) return 0;
    if (diffDays >= 30) return 100;
    return Math.round((diffDays / 30) * 100);
}

function getDeadlineColor(deadline) {
    const daysLeft = calculateDaysLeft(deadline);
    if (daysLeft <= 3) return '#FF5252';
    if (daysLeft <= 7) return '#FFC107';
    return '#4CAF50';
}

function openCommentModal(taskId) {
    currentTaskId = taskId;
    if (elements.commentModal) {
        elements.commentModal.classList.add('active');
    }
}

function closeCommentModal() {
    if (elements.commentModal) {
        elements.commentModal.classList.remove('active');
        currentTaskId = null;
        document.getElementById('comment-text').value = '';
    }
}

async function submitComment() {
    if (!currentTaskId) {
        alert('No task selected');
        return;
    }
    
    const commentText = document.getElementById('comment-text').value.trim();
    if (!commentText) {
        alert('Please enter a comment');
        return;
    }
    
    try {
        const commentsRef = ref(db, `tasks/${currentTaskId}/comments`);
        const currentUser = await fetchCurrentUserProfile();
        
        const comment = {
            authorId: userId,
            authorName: currentUser.name,
            content: commentText,
            timestamp: new Date().toISOString()
        };
        
        await push(commentsRef, comment);
        closeCommentModal();
        
        // Refresh the timeline
        loadWorkflows();
        
    } catch (error) {
        console.error('Error submitting comment:', error);
        alert('Failed to submit comment. Please try again.');
    }
}

// AI Apps Panel Functions
function toggleAIAppsPanel() {
    const panel = document.getElementById('ai-apps-panel');
    const button = document.getElementById('ai-apps-button');
    
    if (panel.classList.contains('active')) {
        closeAIAppsPanel();
    } else {
        openAIAppsPanel();
    }
}

function openAIAppsPanel() {
    const panel = document.getElementById('ai-apps-panel');
    const button = document.getElementById('ai-apps-button');
    
    panel.classList.add('active');
    button.classList.add('active');
}

function closeAIAppsPanel() {
    const panel = document.getElementById('ai-apps-panel');
    const button = document.getElementById('ai-apps-button');
    
    panel.classList.remove('active');
    button.classList.remove('active');
}

function openAIApp(appType) {
    // Close the panel first
    closeAIAppsPanel();
    
    // Handle different AI app types
    switch(appType) {
        case 'image-generator':
            alert('Image Generator - Coming Soon!');
            break;
        case 'video-generator':
            alert('Video Generator - Coming Soon!');
            break;
        case 'code-assistant':
            alert('Code Assistant - Coming Soon!');
            break;
        case 'data-analyzer':
            alert('Data Analyzer - Coming Soon!');
            break;
        case 'text-writer':
            alert('Text Writer - Coming Soon!');
            break;
        case 'translator':
            alert('Translator - Coming Soon!');
            break;
        default:
            alert('AI Tool - Coming Soon!');
    }
}

// Assigned Tasks Functions
async function loadAssignedTasks() {
    try {
        const assignedTasksRef = ref(db, `students/${userId}/assignedTasks`);
        const snapshot = await get(assignedTasksRef);
        
        elements.assignedTasksList.innerHTML = '';
        const assignedTasksSection = document.getElementById('assigned-tasks-section');
        
        if (snapshot.exists()) {
            const tasks = snapshot.val();
            let hasPendingTasks = false;
            console.log('Loaded assigned tasks:', tasks); // DEBUG

            // Fetch professional data to get photos
            const professionals = await fetchProfessionalData();

            // Filter and collect pending tasks
            const pendingTasks = [];
            for (const taskId in tasks) {
                const task = tasks[taskId];
                if (task.status === 'pending') {
                    pendingTasks.push({ taskId, ...task });
                }
            }

            // Sort pending tasks by deadline (nearest first)
            pendingTasks.sort((a, b) => {
                const deadlineA = new Date(a.deadline);
                const deadlineB = new Date(b.deadline);
                return deadlineA - deadlineB;
            });

            // Create cards for sorted tasks
            for (const { taskId, ...task } of pendingTasks) {
                hasPendingTasks = true;
                // Find professional photo
                const professional = professionals.find(p => p.id === task.professionalId);
                const professionalPhoto = await loadProfileImage(task.professionalId);
                
                const card = createAssignedTaskCard(task, taskId, professionalPhoto);
                if (card) elements.assignedTasksList.appendChild(card);
            }

            if (hasPendingTasks) {
                assignedTasksSection.style.display = 'block';
            } else {
                assignedTasksSection.style.display = 'none';
            }
        } else {
            assignedTasksSection.style.display = 'none';
        }
    } catch (error) {
        console.error('Error loading assigned tasks:', error);
        document.getElementById('assigned-tasks-section').style.display = 'none';
    }
}

function createAssignedTaskCard(task, taskId, professionalPhoto) {
    if (task.status !== 'pending') return null;
    const card = document.createElement('div');
    card.className = `assigned-task-card pending`;
    card.dataset.taskId = taskId;
    const daysLeft = calculateDaysLeft(task.deadline);
    
    console.log('Rendering card for task:', task.title, 'Photo:', professionalPhoto); // DEBUG
    card.innerHTML = `
        <div class="assigned-task-content">
            <div class="assigned-task-main">
                <div class="assigned-task-header">
                    <h4 class="assigned-task-title">${task.title}</h4>
                    <div class="assigned-task-badge">
                        <i class="fas fa-clock"></i>
                        ${daysLeft}d
                    </div>
                </div>
                <p class="assigned-task-description">${task.description || 'No description provided'}</p>
                <div class="assigned-task-meta">
                    <span class="assigned-task-category">${task.category.replace('-', ' ')}</span>
                    <div class="assigned-task-employer">
                        <img src="${professionalPhoto}" alt="${task.professionalName}" onerror="this.src='../assets/avatar/1.png'">
                        <span>${task.professionalName}</span>
                    </div>
                </div>
            </div>
            <div class="assigned-task-actions">
                <button class="assigned-task-btn accept-btn" onclick="acceptTask('${taskId}')">
                    <i class="fas fa-check"></i>
                    Accept
                </button>
                <button class="assigned-task-btn reject-btn" onclick="rejectTask('${taskId}')">
                    <i class="fas fa-times"></i>
                    Reject
                </button>
            </div>
        </div>
    `;
    return card;
}

async function acceptTask(taskId) {
    try {
        // Store the task ID for the acceptance process
        window.currentAcceptingTaskId = taskId;
        
        // Show the task acceptance modal
        document.getElementById('task-acceptance-modal').classList.add('active');
        
        // Clear previous form data
        document.getElementById('task-plan').value = '';
        document.getElementById('task-questions').value = '';
        document.getElementById('task-timeline').value = '';
        
    } catch (error) {
        console.error('Error showing task acceptance modal:', error);
        alert('Failed to show acceptance form.');
    }
}

async function confirmAcceptTask() {
    try {
        const taskId = window.currentAcceptingTaskId;
        if (!taskId) {
            alert('No task selected for acceptance.');
            return;
        }

        // Get form data
        const plan = document.getElementById('task-plan').value.trim();
        const questions = document.getElementById('task-questions').value.trim();
        const timeline = document.getElementById('task-timeline').value.trim();

        // Validate that at least plan is provided
        if (!plan) {
            alert('Please provide your plan and approach for the task.');
            return;
        }

        // Get the task details first
        const taskSnapshot = await get(ref(db, `students/${userId}/assignedTasks/${taskId}`));
        const task = taskSnapshot.val();
        
        if (!task) {
            alert('Task not found.');
            return;
        }

        // Update task status to accepted
        await update(ref(db, `students/${userId}/assignedTasks/${taskId}`), {
            status: 'accepted',
            acceptedAt: new Date().toISOString()
        });
        
        // Add employer as connection if not already connected
        const studentConnectionRef = ref(db, `users/${userId}/connections/${task.professionalId}`);
        const professionalConnectionRef = ref(db, `users/${task.professionalId}/connections/${userId}`);
        
        const connectionSnapshot = await get(studentConnectionRef);
        if (!connectionSnapshot.exists()) {
            await set(studentConnectionRef, { status: "connected" });
            await set(professionalConnectionRef, { status: "connected" });
        }
        
        // Add to workflow tasks (this creates the task in the main task section)
        await set(ref(db, `tasks/${taskId}`), {
            ...task,
            studentId: userId,
            professionalId: task.professionalId,
            status: 'in-progress',
            createdAt: new Date().toISOString(),
            title: task.title,
            description: task.description,
            category: task.category,
            deadline: task.deadline,
            files: task.files || {}
        });

        // Create initial comment with plan, questions, and timeline
        const currentUser = await fetchCurrentUserProfile();
        const initialComment = {
            authorId: userId,
            authorName: currentUser.name,
            content: `**Task Acceptance & Initial Plan**\n\n**My Plan & Approach:**\n${plan}\n\n${questions ? `**Questions & Clarifications:**\n${questions}\n\n` : ''}${timeline ? `**Timeline & Milestones:**\n${timeline}` : ''}`,
            timestamp: new Date().toISOString(),
            type: 'acceptance-comment'
        };

        // Add the initial comment to the task timeline
        const commentsRef = ref(db, `tasks/${taskId}/comments`);
        await push(commentsRef, initialComment);
        
        // Close the acceptance modal
        closeTaskAcceptanceModal();
        
        // Automatically select the professional to show the task in workflow
        await selectProfessional(task.professionalId);
        
        // Show success message
        showSuccessModal('Task Accepted!', 'The task has been accepted and added to your workflow. Your initial plan has been shared with the employer.');
        
        // Reload assigned tasks and connections
        loadAssignedTasks();
        loadConnections();
        
    } catch (error) {
        console.error('Error accepting task:', error);
        alert('Failed to accept task. Please try again.');
    }
}

function closeTaskAcceptanceModal() {
    document.getElementById('task-acceptance-modal').classList.remove('active');
    window.currentAcceptingTaskId = null;
}

async function rejectTask(taskId) {
    try {
        // Show styled confirmation dialog
        confirmAction('confirmRejectTask', 'Reject Task', 'Are you sure you want to reject this task? This action cannot be undone.', { taskId });
    } catch (error) {
        console.error('Error showing reject confirmation:', error);
        alert('Failed to show confirmation dialog.');
    }
}

async function confirmRejectTask({ taskId }) {
    try {
        // Get the task details first
        const taskSnapshot = await get(ref(db, `students/${userId}/assignedTasks/${taskId}`));
        const task = taskSnapshot.val();
        
        if (!task) {
            alert('Task not found.');
            return;
        }

        // Update the task status to rejected instead of removing it
        await update(ref(db, `students/${userId}/assignedTasks/${taskId}`), {
            status: 'rejected',
            rejectedAt: new Date().toISOString()
        });
        
        // Get the main task data to check waitlist
        const assignedTaskRef = ref(db, `assignedTasks/${taskId}`);
        const assignedTaskSnap = await get(assignedTaskRef);
        
        if (assignedTaskSnap.exists()) {
            const taskData = assignedTaskSnap.val();
            let waitlist = Array.isArray(taskData.waitlistStudents) ? [...taskData.waitlistStudents] : [];
            
            // Check if current student is primary and there are waitlist students
            if (taskData.primaryStudent === userId && waitlist.length > 0) {
                // Promote the next student from waitlist
                const nextStudentId = waitlist.shift();
                
                // Update the main task data
                await update(assignedTaskRef, {
                    primaryStudent: nextStudentId,
                    waitlistStudents: waitlist,
                    currentWaitlistIndex: 0
                });
                
                // Update the promoted student's assignment
                const nextStudentAssignmentRef = ref(db, `students/${nextStudentId}/assignedTasks/${taskId}`);
                await update(nextStudentAssignmentRef, {
                    status: 'pending',
                    assignmentType: 'primary',
                    waitlistPosition: null,
                    promotedAt: new Date().toISOString()
                });
                
                // Show success message with promotion info
                showSuccessModal('Task Rejected!', 'The task has been rejected. The next student on the waitlist has been promoted to primary assignment.');
            } else {
                // No waitlist students or not primary student
                showSuccessModal('Task Rejected!', 'The task has been rejected and removed from your list.');
            }
        } else {
            showSuccessModal('Task Rejected!', 'The task has been rejected and removed from your list.');
        }
        
        // Reload assigned tasks
        loadAssignedTasks();
        
    } catch (error) {
        console.error('Error rejecting task:', error);
        alert('Failed to reject task. Please try again.');
    }
}

async function viewAssignedTask(taskId) {
    try {
        const taskSnapshot = await get(ref(db, `students/${userId}/assignedTasks/${taskId}`));
        const task = taskSnapshot.val();
        
        if (!task) {
            alert('Task not found.');
            return;
        }
        
        const daysLeft = calculateDaysLeft(task.deadline);
        
        elements.assignedTaskTitle.textContent = task.title;
        elements.assignedTaskBody.innerHTML = `
            <div class="task-details">
                <div class="detail-section">
                    <h4>Task Information</h4>
                    <div class="detail-grid">
                        <div class="detail-item">
                            <strong>Title:</strong> ${task.title}
                        </div>
                        <div class="detail-item">
                            <strong>Description:</strong> ${task.description}
                        </div>
                        <div class="detail-item">
                            <strong>Category:</strong> ${task.category.replace('-', ' ')}
                        </div>
                        <div class="detail-item">
                            <strong>Deadline:</strong> ${new Date(task.deadline).toLocaleDateString()}
                        </div>
                        <div class="detail-item">
                            <strong>Days Left:</strong> ${daysLeft} days
                        </div>
                        <div class="detail-item">
                            <strong>Status:</strong> ${task.status}
                        </div>
                    </div>
                </div>
                
                <div class="detail-section">
                    <h4>Professional Information</h4>
                    <div class="professional-detail">
                        <div class="professional-name">${task.professionalName}</div>
                        <div class="assigned-date">Assigned: ${new Date(task.assignedAt).toLocaleDateString()}</div>
                    </div>
                </div>
                
                ${task.files && Object.keys(task.files).length > 0 ? `
                    <div class="detail-section">
                        <h4>Attached Files (${Object.keys(task.files).length})</h4>
                        <div class="task-files">
                            ${Object.values(task.files).map(file => `
                                <a href="${file.url}" download="${file.name}" class="task-file">
                                    <i class="fas fa-file"></i>
                                    <span>${file.name}</span>
                                </a>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            </div>
        `;
        
        // Set up action buttons based on task status
        if (task.status === 'pending') {
            elements.assignedTaskActions.innerHTML = `
                <button class="cancel-btn" onclick="closeAssignedTaskModal()">Cancel</button>
                <button class="accept-btn" onclick="acceptTask('${taskId}')">Accept Task</button>
                <button class="reject-btn" onclick="rejectTask('${taskId}')">Reject Task</button>
            `;
        } else {
            elements.assignedTaskActions.innerHTML = `
                <button class="cancel-btn" onclick="closeAssignedTaskModal()">Close</button>
            `;
        }
        
        elements.assignedTaskModal.classList.add('active');
        
    } catch (error) {
        console.error('Error loading task details:', error);
        alert('Failed to load task details.');
    }
}

function closeAssignedTaskModal() {
    elements.assignedTaskModal.classList.remove('active');
}

function showSuccessModal(title, message) {
    elements.successTitle.textContent = title;
    elements.successMessage.innerHTML = `
        <div class="success-content">
            <i class="fas fa-check-circle"></i>
            <h4>${title}</h4>
            <p>${message}</p>
        </div>
    `;
    elements.successModal.classList.add('active');
}

function closeSuccessModal() {
    elements.successModal.classList.remove('active');
}

async function acceptRequest(requesterId) {
    try {
        // Handle both object parameter format and string parameter format
        const id = typeof requesterId === 'object' ? requesterId.professionalId : requesterId;
        
        const studentConnectionRef = ref(db, `users/${userId}/connections/${id}`);
        const requesterConnectionRef = ref(db, `users/${id}/connections/${userId}`);
        await update(studentConnectionRef, { status: "connected" });
        await update(requesterConnectionRef, { status: "connected" });
        professionalData = null; // Clear cache
        await loadConnections();
        await loadPendingRequests();
        
        // Show success message
        showSuccessModal('Connection Accepted!', 'The connection request has been accepted successfully.');
    } catch (error) {
        console.error("Error accepting request:", error);
        alert("Failed to accept request.");
    }
}

async function deleteRequest(requesterId) {
    try {
        // Handle both object parameter format and string parameter format
        const id = typeof requesterId === 'object' ? requesterId.professionalId : requesterId;
        
        const studentConnectionRef = ref(db, `users/${userId}/connections/${id}`);
        const requesterConnectionRef = ref(db, `users/${id}/connections/${userId}`);
        await remove(studentConnectionRef);
        await remove(requesterConnectionRef);
        professionalData = null; // Clear cache to refresh professional data
        loadConnections();
        loadPendingRequests();
        
        // Show success message
        showSuccessModal('Request Deleted!', 'The connection request has been deleted successfully.');
    } catch (error) {
        console.error("Error deleting request:", error);
        alert("Failed to delete request.");
    }
}

async function deleteConnection({ professionalId }) {
    try {
        // Handle both object parameter format and string parameter format
        const id = typeof professionalId === 'object' ? professionalId.professionalId : professionalId;
        
        const studentConnectionRef = ref(db, `users/${userId}/connections/${id}`);
        const requesterConnectionRef = ref(db, `users/${id}/connections/${userId}`);
        await remove(studentConnectionRef);
        await remove(requesterConnectionRef);
        professionalData = null; // Clear cache to refresh professional data
        loadConnections();
        loadPendingRequests();
        
        // Hide workflow area and chat when connection is deleted
        if (elements.workflowArea) elements.workflowArea.style.display = 'none';
        if (elements.chatArea) {
            elements.chatArea.style.display = 'none';
            elements.chatArea.classList.remove('chat-hidden');
        }
        
        // Hide chat toggle button when no professional is selected
        if (elements.chatToggleBtn) {
            elements.chatToggleBtn.style.display = 'none';
        }
        
        selectedProfessionalId = null;
        
        // Show success message
        showSuccessModal('Connection Deleted!', 'The connection has been deleted successfully.');
    } catch (error) {
        console.error("Error deleting connection:", error);
        alert("Failed to delete connection.");
    }
}

async function deleteTask({ taskId }) {
    try {
        const taskRef = ref(db, `tasks/${taskId}`);
        await remove(taskRef);
        loadWorkflows();
    } catch (error) {
        console.error("Error deleting task:", error);
        alert("Failed to delete task.");
    }
}

async function deleteMessage({ messageId }) {
    try {
        const chatId = [userId, selectedProfessionalId].sort().join("+");
        const messageRef = ref(db, `chats/${chatId}/messages/${messageId}`);
        await remove(messageRef);
    } catch (error) {
        console.error("Error deleting message:", error);
        alert("Failed to delete message.");
    }
}

async function selectProfessional(professionalId) {
    console.log('selectProfessional called with:', professionalId);
    
    // Clear all chat data when switching professionals
    clearAllChatData();
    
    selectedProfessionalId = professionalId;
    
    document.querySelectorAll('.user-item').forEach(item => {
        const isActive = item.dataset.professionalId === professionalId;
        item.classList.toggle('active', isActive);
        const lastMessage = item.querySelector('.last-message');
        if (lastMessage) lastMessage.style.display = isActive ? 'none' : 'block';
        if (isActive) {
            const unreadDot = item.querySelector('.unread-dot');
            if (unreadDot) unreadDot.remove();
        }
    });
    
    console.log('workflowArea element:', elements.workflowArea);
    console.log('chatToggleBtn element:', elements.chatToggleBtn);
    
    // Hide choose connection message and show workflow area
    const chooseConnectionMessage = document.getElementById('choose-connection-message');
    if (chooseConnectionMessage) {
        chooseConnectionMessage.style.display = 'none';
    }
    
    // Show workflow area
    if (elements.workflowArea) {
        console.log('Setting workflowArea display to block');
        elements.workflowArea.style.display = 'block';
    }
    
    // Keep chat area hidden initially
    if (elements.chatArea) {
        elements.chatArea.style.display = 'none';
        elements.chatArea.classList.remove('chat-hidden');
    }
    
    // Show chat toggle button when professional is selected
    if (elements.chatToggleBtn) {
        console.log('Setting chatToggleBtn display to flex');
        elements.chatToggleBtn.style.display = 'flex';
    }
    
    // Close sidebar in mobile view when professional is selected
    if (window.innerWidth <= 768) {
        closeSidebar();
    }
    
    console.log('Calling loadChatHeader, loadChat, loadWorkflows');
    loadChatHeader();
    loadChat();
    loadWorkflows();
}

window.sendMessage = sendMessage;
window.sendFileMessage = sendFileMessage;
window.openTaskPopup = openTaskPopup;
window.selectProfessional = selectProfessional;
window.acceptRequest = acceptRequest;
window.deleteRequest = deleteRequest;
window.deleteConnection = deleteConnection;
window.deleteTask = deleteTask;
window.deleteMessage = deleteMessage;
window.confirmAction = confirmAction;
window.closeConfirmation = closeConfirmation;
window.toggleReaction = toggleReaction;
window.hideChat = hideChat;
window.showChat = showChat;
window.openFileViewer = openFileViewer;
window.closeFileViewer = closeFileViewer;
window.openSubmissionModal = openSubmissionModal;
window.closeSubmissionModal = closeSubmissionModal;
window.removeSubmissionFile = removeSubmissionFile;
window.submitWork = submitWork;
window.toggleFilesPopup = toggleFilesPopup;
window.closeFilesPopup = closeFilesPopup;
window.openCommentModal = openCommentModal;
window.closeCommentModal = closeCommentModal;
window.submitComment = submitComment;
window.toggleAIAppsPanel = toggleAIAppsPanel;
window.openAIAppsPanel = openAIAppsPanel;
window.closeAIAppsPanel = closeAIAppsPanel;
window.openAIApp = openAIApp;

// Assigned Tasks Window Functions
window.acceptTask = acceptTask;
window.rejectTask = rejectTask;
window.confirmRejectTask = confirmRejectTask;
window.viewAssignedTask = viewAssignedTask;
window.closeAssignedTaskModal = closeAssignedTaskModal;
window.closeSuccessModal = closeSuccessModal;
window.confirmAcceptTask = confirmAcceptTask;
window.closeTaskAcceptanceModal = closeTaskAcceptanceModal;

// Mobile Sidebar Functions
window.toggleSidebar = toggleSidebar;
window.closeSidebar = closeSidebar;

// Timeline Menu Functions
window.toggleTimelineMenu = toggleTimelineMenu;
window.deleteComment = deleteComment;
window.deleteSubmission = deleteSubmission;
window.confirmDeleteComment = confirmDeleteComment;
window.confirmDeleteSubmission = confirmDeleteSubmission;

function toggleSidebar() {
    const sidebar = document.querySelector('.sidebar-left');
    const toggle = document.getElementById('sidebar-toggle');
    const overlay = document.getElementById('sidebar-overlay');
    const dashboard = document.querySelector('.dashboard-content');
    
    if (sidebar.classList.contains('active')) {
        closeSidebar();
    } else {
        sidebar.classList.add('active');
        toggle.classList.add('active');
        overlay.classList.add('active');
        dashboard.classList.add('sidebar-open');
    }
}

function closeSidebar() {
    const sidebar = document.querySelector('.sidebar-left');
    const toggle = document.getElementById('sidebar-toggle');
    const overlay = document.getElementById('sidebar-overlay');
    const dashboard = document.querySelector('.dashboard-content');
    
    sidebar.classList.remove('active');
    toggle.classList.remove('active');
    overlay.classList.remove('active');
    dashboard.classList.remove('sidebar-open');
}

function toggleTimelineMenu(menuId) {
    // Close all other menus first
    document.querySelectorAll('.timeline-menu-dropdown.active').forEach(menu => {
        if (menu.id !== menuId) {
            menu.classList.remove('active');
        }
    });
    
    // Toggle the clicked menu
    const menu = document.getElementById(menuId);
    if (menu) {
        menu.classList.toggle('active');
    }
}

// Close timeline menus when clicking outside
document.addEventListener('click', (e) => {
    if (!e.target.closest('.timeline-item-menu')) {
        document.querySelectorAll('.timeline-menu-dropdown.active').forEach(menu => {
            menu.classList.remove('active');
        });
    }
});

async function deleteComment(commentId, taskId) {
    try {
        // Show confirmation dialog
        confirmAction('confirmDeleteComment', 'Delete Comment', 'Are you sure you want to delete this comment? This action cannot be undone.', { commentId, taskId });
    } catch (error) {
        console.error('Error showing delete confirmation:', error);
        alert('Failed to show confirmation dialog.');
    }
}

async function confirmDeleteComment({ commentId, taskId }) {
    try {
        if (!taskId) {
            alert('No task selected.');
            return;
        }
        
        // Delete the comment from Firebase
        const commentRef = ref(db, `tasks/${taskId}/comments/${commentId}`);
        await remove(commentRef);
        
        // Refresh the timeline
        loadWorkflows();
        
        // Show success message
        showSuccessModal('Comment Deleted!', 'The comment has been successfully deleted.');
        
    } catch (error) {
        console.error('Error deleting comment:', error);
        alert('Failed to delete comment. Please try again.');
    }
}

async function deleteSubmission(submissionId, taskId) {
    try {
        // Show confirmation dialog
        confirmAction('confirmDeleteSubmission', 'Delete Submission', 'Are you sure you want to delete this submission? This action cannot be undone and all uploaded files will be permanently removed.', { submissionId, taskId });
    } catch (error) {
        console.error('Error showing delete confirmation:', error);
        alert('Failed to show confirmation dialog.');
    }
}

async function confirmDeleteSubmission({ submissionId, taskId }) {
    try {
        if (!taskId) {
            alert('No task selected.');
            return;
        }
        
        // Get submission details first to delete files
        const submissionRef = ref(db, `tasks/${taskId}/submissions/${submissionId}`);
        const submissionSnapshot = await get(submissionRef);
        
        if (submissionSnapshot.exists()) {
            const submission = submissionSnapshot.val();
            
            // Delete uploaded files from storage if they exist
            if (submission.files) {
                for (const fileKey in submission.files) {
                    const file = submission.files[fileKey];
                    try {
                        // Extract file path from URL and delete from storage
                        const fileRef = storageRef(storage, file.url.split('/o/')[1]?.split('?')[0]);
                        await remove(fileRef);
                    } catch (fileError) {
                        console.warn('Could not delete file from storage:', fileError);
                    }
                }
            }
        }
        
        // Delete the submission from Firebase
        await remove(submissionRef);
        
        // Refresh the timeline
        loadWorkflows();
        
        // Show success message
        showSuccessModal('Submission Deleted!', 'The submission and all associated files have been successfully deleted.');
        
    } catch (error) {
        console.error('Error deleting submission:', error);
        alert('Failed to delete submission. Please try again.');
    }
}

// Helper function to determine if full render is needed
function shouldDoFullRender(cachedMessages, newMessages, lastTimestamps) {
    // If cache is empty, do full render
    if (cachedMessages.length === 0) return true;
    
    // If message count changed significantly, do full render
    if (Math.abs(newMessages.length - cachedMessages.length) > 3) return true;
    
    // If any message timestamps changed, check if it's a major change
    let changedCount = 0;
    for (const msg of newMessages) {
        const cachedTimestamp = lastTimestamps[msg.id];
        if (!cachedTimestamp || cachedTimestamp !== msg.timestamp) {
            changedCount++;
        }
    }
    
    // If more than 20% of messages changed, do full render (more aggressive)
    return changedCount > (newMessages.length * 0.2);
}

// Function to render all messages (full render)
async function renderAllMessages(messages, currentUser, chatId) {
    elements.chatMessages.innerHTML = '';
    
    if (messages.length === 0) {
        elements.chatMessages.innerHTML = '<div class="message">No messages yet</div>';
        return;
    }
    
    const professionals = await fetchProfessionalData();
    const professional = professionals.find(p => p.id === selectedProfessionalId) || {};
    const tasksRef = ref(db, `tasks`);
    const tasksSnapshot = await get(tasksRef);
    const tasks = tasksSnapshot.exists() ? tasksSnapshot.val() : {};
    let taskTitles = [];
    for (const taskId in tasks) {
        if (tasks[taskId].studentId === userId && tasks[taskId].professionalId === selectedProfessionalId) {
            taskTitles.push(tasks[taskId].title);
        }
    }
    
    let lastDate = null;
    for (const msg of messages) {
        const messageElement = await createMessageElement(msg, currentUser, professional, taskTitles, chatId);
        
        // Add date divider if needed
        const date = formatMessageDate(msg.timestamp);
        if (date !== lastDate) {
            const dateDivider = document.createElement('div');
            dateDivider.className = 'date-divider';
            dateDivider.innerHTML = `<span>${date}</span>`;
            elements.chatMessages.appendChild(dateDivider);
            lastDate = date;
        }
        
        elements.chatMessages.appendChild(messageElement);
    }
    
    elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
}

// Function to update only changed messages (incremental update)
async function updateChangedMessages(cachedMessages, newMessages, currentUser, chatId) {
    const lastTimestamps = lastMessageTimestamps.get(chatId) || {};
    const professionals = await fetchProfessionalData();
    const professional = professionals.find(p => p.id === selectedProfessionalId) || {};
    const tasksRef = ref(db, `tasks`);
    const tasksSnapshot = await get(tasksRef);
    const tasks = tasksSnapshot.exists() ? tasksSnapshot.val() : {};
    let taskTitles = [];
    for (const taskId in tasks) {
        if (tasks[taskId].studentId === userId && tasks[taskId].professionalId === selectedProfessionalId) {
            taskTitles.push(tasks[taskId].title);
        }
    }
    
    // Find changed messages
    const changedMessages = [];
    const newMessageIds = new Set(newMessages.map(m => m.id));
    const cachedMessageIds = new Set(cachedMessages.map(m => m.id));
    
    // Check for new messages
    for (const msg of newMessages) {
        if (!cachedMessageIds.has(msg.id)) {
            changedMessages.push({ type: 'new', message: msg });
        }
    }
    
    // Check for updated messages
    for (const msg of newMessages) {
        const cachedTimestamp = lastTimestamps[msg.id];
        if (cachedTimestamp && cachedTimestamp !== msg.timestamp) {
            changedMessages.push({ type: 'updated', message: msg });
        }
    }
    
    // Check for deleted messages
    for (const msg of cachedMessages) {
        if (!newMessageIds.has(msg.id)) {
            changedMessages.push({ type: 'deleted', message: msg });
        }
    }
    
    // Batch DOM updates to improve performance
    const fragment = document.createDocumentFragment();
    const elementsToRemove = [];
    const elementsToAdd = [];
    const elementsToUpdate = [];
    
    // Prepare all changes
    for (const change of changedMessages) {
        const existingElement = elements.chatMessages.querySelector(`[data-message-id="${change.message.id}"]`);
        
        if (change.type === 'new') {
            // Prepare new message
            const messageElement = await createMessageElement(change.message, currentUser, professional, taskTitles, chatId);
            
            // Check if we need to add a date divider
            const date = formatMessageDate(change.message.timestamp);
            const prevMessage = newMessages.find(m => m.id === change.message.id);
            const prevIndex = newMessages.indexOf(prevMessage);
            const prevDate = prevIndex > 0 ? formatMessageDate(newMessages[prevIndex - 1].timestamp) : null;
            
            if (date !== prevDate) {
                const dateDivider = document.createElement('div');
                dateDivider.className = 'date-divider';
                dateDivider.innerHTML = `<span>${date}</span>`;
                elementsToAdd.push({ element: dateDivider, before: existingElement });
            }
            
            elementsToAdd.push({ element: messageElement, before: existingElement });
        } else if (change.type === 'updated') {
            // Prepare updated message
            const messageElement = await createMessageElement(change.message, currentUser, professional, taskTitles, chatId);
            elementsToUpdate.push({ oldElement: existingElement, newElement: messageElement });
        } else if (change.type === 'deleted') {
            // Prepare deleted message
            if (existingElement) {
                elementsToRemove.push(existingElement);
            }
        }
    }
    
    // Apply all changes in batch
    // Remove elements first
    elementsToRemove.forEach(element => element.remove());
    
    // Update elements
    elementsToUpdate.forEach(({ oldElement, newElement }) => {
        if (oldElement) {
            oldElement.replaceWith(newElement);
        }
    });
    
    // Add new elements
    elementsToAdd.forEach(({ element, before }) => {
        if (before) {
            elements.chatMessages.insertBefore(element, before);
        } else {
            elements.chatMessages.appendChild(element);
        }
    });
    
    // Scroll to bottom if new messages were added
    if (changedMessages.some(c => c.type === 'new')) {
        elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
    }
}

// Function to create a single message element
async function createMessageElement(msg, currentUser, professional, taskTitles, chatId) {
    const isSent = msg.senderId === userId;
    const senderName = isSent ? currentUser.name : (professional.personal?.name || "Unnamed");
    const profilePic = isSent 
        ? currentUser.profilePic
        : await loadProfileImage(selectedProfessionalId);
    const time = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${isSent ? 'sent' : 'received'} ${msg.file ? 'file-message' : ''}`;
    messageDiv.dataset.messageId = msg.id;
    
    let content = msg.content || '';
    taskTitles.forEach(title => {
        const regex = new RegExp(`@${title.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')}`, 'g');
        content = content.replace(regex, `<span class="mention">@${title}</span>`);
    });
    
    let reactionsHTML = '';
    if (msg.reactions && msg.reactions[userId]) {
        reactionsHTML = `<span class="reaction">${msg.reactions[userId]}</span>`;
    }
    
    if (msg.file) {
        const fileSize = msg.file.size ? (msg.file.size / 1024).toFixed(2) + ' KB' : 'Unknown size';
        const isImage = msg.file.type && msg.file.type.startsWith('image/');
        const fileName = msg.file.name.length > 25 ? msg.file.name.substring(0, 25) + '...' : msg.file.name;
        
        messageDiv.innerHTML = `
            <div class="message-header">
                <img src="${profilePic}" class="profile-pic">
                <div class="name">${senderName}</div>
                <div class="time">${time}</div>
            </div>
            <a href="${msg.file.url}" download="${msg.file.name}" target="_blank">
                <div class="file-info">
                    ${isImage ? 
                        `<img src="${msg.file.url}" alt="${msg.file.name}" class="file-thumbnail">` :
                        `<i class="${getFileIconClass(msg.file.type)} file-icon" style="color: ${getFileIconColor(msg.file.type)};"></i>`
                    }
                    <div class="file-details">
                        <div class="file-name">${fileName}</div>
                        <div class="file-size">${fileSize}</div>
                    </div>
                </div>
            </a>
            <div class="read-status">${msg.read ? 'Seen' : 'Sent'}</div>
            <div class="reactions">${reactionsHTML}</div>
            <div class="reaction-bar" >
                <span class="reaction-icon" data-reaction="ðŸ¤" style="display: none;">ðŸ¤</span>
                <span class="reaction-icon" data-reaction="ðŸ‘" style="display: none;">ðŸ‘</span>
                <span class="reaction-icon" data-reaction="â¤ï¸" style="display: none;">â¤ï¸</span>
                <div class="message-menu">
                    <i class="fas fa-ellipsis-h message-menu-icon"></i>
                    <div class="message-menu-dropdown">
                        <button data-action="deleteMessage">Delete Message</button>
                    </div>
                </div>
            </div>
        `;
    } else {
        messageDiv.innerHTML = `
            <div class="message-header">
                <img src="${profilePic}" class="profile-pic">
                <div class="name">${senderName}</div>
                <div class="time">${time}</div>
            </div>
            <div class="content">${content}</div>
            <div class="read-status">${msg.read ? 'Seen' : 'Sent'}</div>
            <div class="reactions">${reactionsHTML}</div>
            <div class="reaction-bar" >
                <span class="reaction-icon" data-reaction="ðŸ¤" style="display: none;">ðŸ¤</span>
                <span class="reaction-icon" data-reaction="ðŸ‘" style="display: none;">ðŸ‘</span>
                <span class="reaction-icon" data-reaction="â¤ï¸" style="display: none;">â¤ï¸</span>
                <div class="message-menu">
                    <i class="fas fa-ellipsis-h message-menu-icon"></i>
                    <div class="message-menu-dropdown">
                        <button data-action="deleteMessage">Delete Message</button>
                    </div>
                </div>
            </div>
        `;
    }
    
    return messageDiv;
}

// Add cache management functions
function clearMessageCache() {
    messageCache.clear();
    lastMessageTimestamps.clear();
}

function clearChatCache(chatId) {
    messageCache.delete(chatId);
    lastMessageTimestamps.delete(chatId);
}

// Clear all chat data when switching professionals
function clearAllChatData() {
    // Clear all caches
    messageCache.clear();
    lastMessageTimestamps.clear();
    
    // Clear chat listener
    if (currentChatListener) {
        currentChatListener();
        currentChatListener = null;
    }
    
    // Clear chat messages area
    if (elements.chatMessages) {
        elements.chatMessages.innerHTML = '';
    }
}

// Cache size management
function manageCacheSize() {
    const maxCacheSize = 10; // Maximum number of chat caches to keep
    if (messageCache.size > maxCacheSize) {
        const chatIds = Array.from(messageCache.keys());
        const oldestChatIds = chatIds.slice(0, messageCache.size - maxCacheSize);
        oldestChatIds.forEach(chatId => {
            clearChatCache(chatId);
        });
    }
}

// Cache management functions for debugging
window.clearMessageCache = clearMessageCache;
window.clearChatCache = clearChatCache;
window.clearAllChatData = clearAllChatData;
window.manageCacheSize = manageCacheSize;
window.messageCache = messageCache;
window.lastMessageTimestamps = lastMessageTimestamps;

init();

// Task Rejection Modal Functions
function openTaskRejectionModal(taskId) {
    // Store the task ID for the rejection process
    window.currentRejectingTaskId = taskId;
    
    // Clear previous form data
    elements.rejectionReason.value = '';
    
    // Show the task rejection modal
    elements.taskRejectionModal.classList.add('active');
}

function closeTaskRejectionModal() {
    elements.taskRejectionModal.classList.remove('active');
    window.currentRejectingTaskId = null;
}

async function submitTaskRejection() {
    try {
        const taskId = window.currentRejectingTaskId;
        if (!taskId) {
            alert('No task selected for rejection.');
            return;
        }

        // Get the rejection reason
        const reason = elements.rejectionReason.value.trim();
        if (!reason) {
            alert('Please provide a reason for rejecting this task.');
            return;
        }

        // Get the task details first
        const taskSnapshot = await get(ref(db, `tasks/${taskId}`));
        const task = taskSnapshot.val();
        
        if (!task) {
            alert('Task not found.');
            return;
        }

        // Store the rejection request in Firebase
        const rejectionData = {
            taskId: taskId,
            userId: userId,
            reason: reason,
            taskTitle: task.title,
            taskDescription: task.description,
            professionalId: task.professionalId,
            studentId: task.studentId,
            submittedAt: new Date().toISOString(),
            status: 'pending', // pending, approved, rejected
            processedAt: null
        };

        // Add to rejected tasks collection
        const rejectedTasksRef = ref(db, `rejectedTasks`);
        await push(rejectedTasksRef, rejectionData);

        // Close the rejection modal
        closeTaskRejectionModal();
        
        // Show success message
        showSuccessModal('Rejection Request Submitted!', 'Your task rejection request has been submitted successfully. It will be processed within 24 hours. The task will remain visible until the rejection is approved.');
        
    } catch (error) {
        console.error('Error submitting task rejection:', error);
        alert('Failed to submit rejection request. Please try again.');
    }
}

window.confirmAcceptTask = confirmAcceptTask;
window.closeTaskAcceptanceModal = closeTaskAcceptanceModal;

// Task Rejection Modal Functions
window.openTaskRejectionModal = openTaskRejectionModal;
window.closeTaskRejectionModal = closeTaskRejectionModal;
window.submitTaskRejection = submitTaskRejection;

// === Invite Connection Functions ===
// Check for invite parameter in URL when page loads
function checkForInvite() {
    const urlParams = new URLSearchParams(window.location.search);
    const inviteId = urlParams.get('invite');
    
    if (inviteId && userId && inviteId !== userId) {
        // Check if already connected
        checkIfAlreadyConnected(inviteId);
    }
}

async function checkIfAlreadyConnected(inviteId) {
    try {
        // Check if there's already a connection
        const connectionSnapshot = await get(ref(db, `students/${userId}/connections/${inviteId}`));
        if (connectionSnapshot.exists()) {
            console.log('Already connected with this user');
            return;
        }
        
        // If not connected, show connection request
        showConnectionRequest(inviteId);
    } catch (error) {
        console.error('Error checking connection status:', error);
    }
}

async function showConnectionRequest(inviteId) {
    try {
        // Check if inviter is a student or professional
        const studentSnapshot = await get(ref(db, `studentslist/${inviteId}`));
        const professionalSnapshot = await get(ref(db, `professionalslist/${inviteId}`));
        
        let inviterName = 'A user';
        let inviterRole = 'user';
        
        if (studentSnapshot.exists()) {
            const inviterData = studentSnapshot.val();
            inviterName = inviterData.personal?.name || 'A student';
            inviterRole = 'student';
        } else if (professionalSnapshot.exists()) {
            const inviterData = professionalSnapshot.val();
            inviterName = inviterData.personal?.name || 'A professional';
            inviterRole = 'professional';
        }
        
        // Create a custom modal for connection request
        const modal = document.createElement('div');
        modal.className = 'confirmation-dialog active';
        modal.innerHTML = `
            <div class="dialog-box">
                <h3>Connection Request</h3>
                <p>${inviterName} (${inviterRole}) wants to connect with you on Taska. Would you like to accept this connection request?</p>
                <div class="dialog-actions">
                    <button class="cancel" onclick="closeConnectionModal()">Decline</button>
                    <button class="confirm" onclick="acceptConnection('${inviteId}', '${inviterRole}')">Accept</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
    } catch (error) {
        console.error('Error processing invite:', error);
    }
}

function closeConnectionModal() {
    const modal = document.querySelector('.confirmation-dialog');
    if (modal) {
        modal.remove();
    }
}

async function acceptConnection(inviteId, inviterRole) {
    try {
        // Create connection records for both users
        const connectionData = {
            status: 'connected',
            timestamp: new Date().toISOString(),
            connectedAt: new Date().toISOString()
        };
        
        // Add connection for current user (student)
        await set(ref(db, `students/${userId}/connections/${inviteId}`), connectionData);
        
        // Add connection for the inviter (could be student or professional)
        if (inviterRole === 'student') {
            await set(ref(db, `students/${inviteId}/connections/${userId}`), connectionData);
        } else if (inviterRole === 'professional') {
            await set(ref(db, `professionals/${inviteId}/connections/${userId}`), connectionData);
        }
        
        // Close the modal
        closeConnectionModal();
        
        // Show success message
        showSuccessModal('Connection Established!', `You are now connected with this ${inviterRole}. You can now collaborate on tasks together.`);
        
        // Reload connections to show the new connection
        loadConnections();
        
    } catch (error) {
        console.error('Error accepting connection:', error);
        alert('Failed to establish connection. Please try again.');
    }
}

// === End Invite Connection Functions ===

// === Invite to Connect Modal for Tasks Page ===
// Create the invite modal dynamically
const inviteConnectModalTasks = document.createElement('div');
inviteConnectModalTasks.id = 'invite-connect-modal-tasks';
inviteConnectModalTasks.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.4);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    backdrop-filter: blur(8px);
`;

inviteConnectModalTasks.innerHTML = `
    <div style="
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        padding: 0;
        max-width: 520px;
        width: 90%;
        max-height: 90vh;
        overflow: hidden;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 8px 25px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(20px);
    ">
        <!-- macOS-style title bar -->
        <div style="
            background: rgba(248, 249, 250, 0.8);
            padding: 12px 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            backdrop-filter: blur(10px);
        ">
            <h2 style="
                margin: 0;
                font-size: 16px;
                font-weight: 500;
                color: #1d1d1f;
                flex: 1;
                text-align: center;
            ">Invite to Connect</h2>
            
            <button id="close-invite-modal-tasks" style="
                background: none;
                border: none;
                font-size: 20px;
                cursor: pointer;
                color: #6e6e73;
                padding: 4px 8px;
                border-radius: 6px;
                transition: all 0.2s;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 32px;
                height: 32px;
            " onmouseover="this.style.background='rgba(0, 0, 0, 0.1)'; this.style.color='#1d1d1f'" onmouseout="this.style.background='none'; this.style.color='#6e6e73'" onclick="closeInviteModalTasks()">Ã—</button>
        </div>
        
        <!-- Modal content -->
        <div style="padding: 32px;">
            <div style="text-align: center; margin-bottom: 24px;">
                <p style="
                    color: #6e6e73;
                    margin-bottom: 24px;
                    font-size: 15px;
                    line-height: 1.5;
                    font-weight: 400;
                ">Share this QR code or link to connect with Employers on Taska</p>
                
                <div id="qr-code-container-tasks" style="
                    display: inline-block;
                    padding: 24px;
                    background: rgba(248, 249, 250, 0.8);
                    border-radius: 16px;
                    margin-bottom: 24px;
                    border: 1px solid rgba(0, 0, 0, 0.08);
                    backdrop-filter: blur(10px);
                ">
                    <div id="qr-code-tasks" style="width: 200px; height: 200px; margin: 0 auto;"></div>
                </div>
                
                <div style="margin-bottom: 24px;">
                    <label style="
                        display: block;
                        text-align: left;
                        font-weight: 500;
                        color: #1d1d1f;
                        margin-bottom: 8px;
                        font-size: 14px;
                    ">Invite Link</label>
                    <div style="
                        display: flex;
                        gap: 8px;
                        align-items: center;
                    ">
                        <input type="text" id="invite-link-tasks" readonly style="
                            flex: 1;
                            padding: 12px 16px;
                            border: 1px solid rgba(0, 0, 0, 0.1);
                            border-radius: 8px;
                            font-size: 14px;
                            background: rgba(248, 249, 250, 0.8);
                            color: #6e6e73;
                            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
                            outline: none;
                            transition: all 0.2s;
                        " onfocus="this.style.borderColor='#007aff'; this.style.boxShadow='0 0 0 3px rgba(0, 122, 255, 0.1)'" onblur="this.style.borderColor='rgba(0, 0, 0, 0.1)'; this.style.boxShadow='none'">
                        <button id="copy-link-btn-tasks" style="
                            padding: 12px 20px;
                            background: #007aff;
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 500;
                            font-size: 14px;
                            transition: all 0.2s;
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            white-space: nowrap;
                        " onmouseover="this.style.background='#0056cc'" onmouseout="this.style.background='#007aff'">Copy</button>
                    </div>
                </div>
                
                <div style="
                    display: flex;
                    gap: 12px;
                    justify-content: center;
                    flex-wrap: wrap;
                ">
                    <button id="share-whatsapp-btn-tasks" style="
                        padding: 12px 20px;
                        background: #25d366;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        font-weight: 500;
                        font-size: 14px;
                        transition: all 0.2s;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    " onmouseover="this.style.background='#128c7e'" onmouseout="this.style.background='#25d366'">
                        <i class="fab fa-whatsapp" style="font-size: 16px;"></i>
                        WhatsApp
                    </button>
                    
                    <button id="share-email-btn-tasks" style="
                        padding: 12px 20px;
                        background: #007aff;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        font-weight: 500;
                        font-size: 14px;
                        transition: all 0.2s;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    " onmouseover="this.style.background='#0056cc'" onmouseout="this.style.background='#007aff'">
                        <i class="fas fa-envelope" style="font-size: 14px;"></i>
                        Email
                    </button>
                </div>
            </div>
        </div>
    </div>
`;

document.body.appendChild(inviteConnectModalTasks);

// Add event listeners for the tasks page invite modal
document.addEventListener('DOMContentLoaded', function() {
    // Add event listener for the invite button in tasks page
    const inviteBtnTasks = document.getElementById('invite-connect-btn-tasks');
    if (inviteBtnTasks) {
        inviteBtnTasks.addEventListener('click', function() {
            openInviteModalTasks();
        });
    }
    
    // Add event listener for the close button
    const closeBtnTasks = document.getElementById('close-invite-modal-tasks');
    if (closeBtnTasks) {
        closeBtnTasks.addEventListener('click', function() {
            closeInviteModalTasks();
        });
    }
    
    // Add event listener for modal backdrop
    inviteConnectModalTasks.addEventListener('click', function(e) {
        if (e.target === this) {
            closeInviteModalTasks();
        }
    });
    
    // Add event listeners for share buttons
    const copyBtnTasks = document.getElementById('copy-link-btn-tasks');
    if (copyBtnTasks) {
        copyBtnTasks.addEventListener('click', function() {
            copyInviteLinkTasks();
        });
    }
    
    const whatsappBtnTasks = document.getElementById('share-whatsapp-btn-tasks');
    if (whatsappBtnTasks) {
        whatsappBtnTasks.addEventListener('click', function() {
            shareViaWhatsAppTasks();
        });
    }
    
    const emailBtnTasks = document.getElementById('share-email-btn-tasks');
    if (emailBtnTasks) {
        emailBtnTasks.addEventListener('click', function() {
            shareViaEmailTasks();
        });
    }
});

// Functions for tasks page invite modal
function openInviteModalTasks() {
    if (!userId) {
        alert('You must be logged in to generate an invite link.');
        return;
    }
    
    checkUserRoleAndGenerateLinkTasks();
}

async function checkUserRoleAndGenerateLinkTasks() {
    try {
        // Check if user exists in studentslist
        const studentSnapshot = await get(ref(db, `studentslist/${userId}`));
        const professionalSnapshot = await get(ref(db, `professionalslist/${userId}`));
        
        let inviteLink;
        if (studentSnapshot.exists()) {
            // User is a student - invite to checkinvite.html
            inviteLink = `${window.location.origin}/checkinvite.html?invite=${userId}`;
        } else if (professionalSnapshot.exists()) {
            // User is a professional - invite to checkinvite.html
            inviteLink = `${window.location.origin}/checkinvite.html?invite=${userId}`;
        } else {
            // User not found in either list
            alert('User role not found. Please try again.');
            return;
        }
        
        document.getElementById('invite-link-tasks').value = inviteLink;
        
        // Show modal first
        inviteConnectModalTasks.style.display = 'flex';
        
        // Generate QR code with a small delay to ensure library is loaded
        setTimeout(() => {
            generateQRCodeTasks(inviteLink);
        }, 100);
        
    } catch (error) {
        console.error('Error checking user role:', error);
        alert('Failed to generate invite link. Please try again.');
    }
}

function closeInviteModalTasks() {
    inviteConnectModalTasks.style.display = 'none';
}

function generateQRCodeTasks(text) {
    const qrContainer = document.getElementById('qr-code-tasks');
    qrContainer.innerHTML = '';
    
    console.log('Generating QR code for tasks page:', text);
    console.log('QRCode library available:', typeof QRCode !== 'undefined');
    
    // Check if QRCode library is available
    if (typeof QRCode === 'undefined') {
        console.warn('QRCode library not loaded, showing fallback');
        qrContainer.innerHTML = `
            <div style="
                width: 200px; 
                height: 200px; 
                background: #f8f9fa; 
                border: 2px dashed #dadce0; 
                display: flex; 
                align-items: center; 
                justify-content: center; 
                color: #5f6368; 
                font-size: 0.875rem; 
                text-align: center;
                padding: 1rem;
            ">
                QR Code not available<br>
                Please use the invite link below
            </div>
        `;
        return;
    }
    
    try {
        // Create QR code using qrcodejs library
        new QRCode(qrContainer, {
            text: text,
            width: 200,
            height: 200,
            colorDark: '#000000',
            colorLight: '#FFFFFF',
            correctLevel: QRCode.CorrectLevel.H
        });
        
        console.log('QR code generated successfully for tasks page');
    } catch (error) {
        console.error('Exception in QR code generation for tasks page:', error);
        qrContainer.innerHTML = `
            <div style="
                width: 200px; 
                height: 200px; 
                background: #f8f9fa; 
                border: 2px dashed #dadce0; 
                display: flex; 
                align-items: center; 
                justify-content: center; 
                color: #5f6368; 
                font-size: 0.875rem; 
                text-align: center;
                padding: 1rem;
            ">
                QR Code generation failed<br>
                Please use the invite link below
            </div>
        `;
    }
}

function copyInviteLinkTasks() {
    const inviteLink = document.getElementById('invite-link-tasks');
    inviteLink.select();
    inviteLink.setSelectionRange(0, 99999);
    
    try {
        document.execCommand('copy');
        const copyBtn = document.getElementById('copy-link-btn-tasks');
        const originalText = copyBtn.textContent;
        const originalBackground = copyBtn.style.background;
        
        copyBtn.textContent = 'Copied!';
        copyBtn.style.background = '#34c759';
        
        setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.style.background = originalBackground || '#007aff';
        }, 2000);
    } catch (err) {
        alert('Failed to copy link. Please copy it manually.');
    }
}

function shareViaWhatsAppTasks() {
    const inviteLink = document.getElementById('invite-link-tasks').value;
    const message = `Hi! I'd like to connect with you on Taska. Here's my invite link: ${inviteLink}`;
    
    // Use WhatsApp Web API to open WhatsApp directly
    const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(message)}`;
    
    // Open WhatsApp in a new window/tab
    window.open(whatsappUrl, '_blank');
}

function shareViaEmailTasks() {
    const inviteLink = document.getElementById('invite-link-tasks').value;
    const subject = 'Connect with me on Taska';
    const body = `Hi! I'd like to connect with you on Taska. Here's my invite link: ${inviteLink}`;
    const emailUrl = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    window.open(emailUrl);
}

// === End Invite to Connect Modal for Tasks Page ===
</script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93b153f5ba4ebd25',t:'MTc0NjQ1OTUzOC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>