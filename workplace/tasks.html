<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taska Elite - Student Tasks</title>
    <link rel="stylesheet" href="css/tasks.css">
    <link rel="stylesheet" href="../css/reset.css">
    <link rel="stylesheet" href="../css/global.css">
    <link rel="stylesheet" href="../css/dashboard.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Confirmation Dialog Styles */
        .confirmation-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        .confirmation-dialog.active {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .confirmation-dialog .dialog-box {
            background: #fff;
            padding: 2rem;
            border-radius: 16px;
            width: 90%;
            max-width: 450px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border: 1px solid #e0e0e0;
            animation: slideInUp 0.3s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .confirmation-dialog .dialog-box h3 {
            margin: 0 0 1rem;
            color: #1a1a1a;
            font-size: 1.4rem;
            font-weight: 600;
        }

        .confirmation-dialog .dialog-box p {
            margin: 0 0 2rem;
            color: #666;
            font-size: 1rem;
            line-height: 1.5;
        }

        .confirmation-dialog .dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .confirmation-dialog .dialog-actions button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
            font-family: 'Poppins', sans-serif;
        }

        .confirmation-dialog .dialog-actions .cancel {
            background: #f5f5f5;
            color: #666;
            border: 1px solid #e0e0e0;
        }

        .confirmation-dialog .dialog-actions .cancel:hover {
            background: #e9ecef;
            color: #333;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .confirmation-dialog .dialog-actions .confirm {
            background: #4CAF50;
            color: #fff;
        }

        .confirmation-dialog .dialog-actions .confirm:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .confirmation-dialog .dialog-actions .delete {
            background: #FF5252;
            color: #fff;
        }

        .confirmation-dialog .dialog-actions .delete:hover {
            background: #e04848;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 82, 82, 0.3);
        }

        /* Success Modal Styles */
        .success-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        .success-modal.active {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        .success-modal .modal-content {
            background: #fff;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border: 1px solid #e0e0e0;
            animation: slideInUp 0.3s ease-out;
        }

        .success-modal .modal-header {
            padding: 1.5rem 2rem 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .success-modal .modal-header h3 {
            margin: 0;
            color: #1a1a1a;
            font-size: 1.3rem;
            font-weight: 600;
        }

        .success-modal .modal-header button {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #666;
            cursor: pointer;
            padding: 0;
        }

        .success-modal .modal-body {
            padding: 1rem 2rem;
        }

        .success-modal .modal-actions {
            padding: 0 2rem 1.5rem;
            display: flex;
            justify-content: center;
        }

        .success-modal .success-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .success-modal .success-btn:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        /* Success Content Styles */
        .success-content {
            text-align: center;
            padding: 1rem 0;
        }

        .success-content i {
            font-size: 2.5rem;
            color: #16a34a;
            margin-bottom: 0.75rem;
        }

        .success-content h4 {
            font-size: 1.1rem;
            color: #333;
            margin: 0 0 0.75rem 0;
            font-weight: 600;
        }

        .success-content p {
            color: #666;
            margin: 0.25rem 0;
            line-height: 1.4;
            font-size: 0.9rem;
        }

        /* Task Acceptance Modal Styles */
        .task-acceptance-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        .task-acceptance-modal.active {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        .task-acceptance-modal .modal-content {
            background: #fff;
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border: 1px solid #e0e0e0;
            animation: slideInUp 0.3s ease-out;
        }

        .task-acceptance-modal .modal-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .task-acceptance-modal .modal-header h3 {
            margin: 0;
            color: #1a1a1a;
            font-size: 1.3rem;
            font-weight: 600;
        }

        .task-acceptance-modal .modal-header button {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #666;
            cursor: pointer;
            padding: 0;
        }

        .task-acceptance-modal .modal-body {
            padding: 2rem;
        }

        .task-acceptance-modal .form-group {
            margin-bottom: 1.5rem;
        }

        .task-acceptance-modal .form-group label {
            display: block;
            font-weight: 500;
            color: #333;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }

        .task-acceptance-modal .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.9rem;
            font-family: 'Poppins', sans-serif;
            resize: vertical;
            min-height: 100px;
            box-sizing: border-box;
        }

        .task-acceptance-modal .form-group textarea:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        .task-acceptance-modal .modal-actions {
            padding: 1.5rem 2rem;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }

        .task-acceptance-modal .cancel-btn {
            background: #f5f5f5;
            color: #666;
            border: 1px solid #e0e0e0;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .task-acceptance-modal .cancel-btn:hover {
            background: #e9ecef;
            color: #333;
        }

        .task-acceptance-modal .accept-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .task-acceptance-modal .accept-btn:hover {
            background: #45a049;
        }

        .task-acceptance-modal .accept-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="mobile-message">
        <p>Please use a desktop for a better experience.</p>
    </div>
    <nav class="navbar">
        <a href="../index.html">
            <div class="logo">Taska</div>
          </a>
        <ul class="nav-menu">
            <li><a href="tasks.html" class="active">Workplace</a></li>
            <li><a href="profile.html">Account</a></li>
        </ul>
        <div class="hamburger">☰</div>
    </nav>

    <div class="dashboard-content">
        <div class="sidebar-left">
            <!-- Assigned Tasks Section -->
            <div class="assigned-tasks-section" id="assigned-tasks-section" style="display: none;">
                <h3>Assigned Tasks</h3>
                <div id="assigned-tasks-list" class="assigned-tasks-list">
                    <!-- Assigned tasks will be populated here -->
                </div>
            </div>
            
            <!-- Connections Section -->
            <div class="connections-section">
                <h3>Connections</h3>
                <div id="connections-list" class="skeleton-loading">
                    <div class="skeleton-user-item"></div>
                    <div class="skeleton-user-item"></div>
                    <div class="skeleton-user-item"></div>
                </div>
                <div class="pending-requests" style="display: none;">
                    <h3>Pending Requests</h3>
                    <div id="pending-requests-list"></div>
                </div>
            </div>
        </div>
        <div class="sidebar-right" id="workflow-area">
            <h3>Tasks</h3>
            <div id="workflow-list" class="skeleton-loading">
                <div class="skeleton-task-item"></div>
                <div class="skeleton-task-item"></div>
            </div>
        </div>
        <div class="chat-area" id="chat-area">
            <div class="chat-header skeleton-loading" id="chat-header">
                <div class="skeleton-header"></div>
            </div>
            <div class="messages skeleton-loading" id="chat-messages">
                <div class="skeleton-message"></div>
                <div class="skeleton-message"></div>
            </div>
            <div class="chat-input">
                <div class="input-container">
                    <div class="upload-progress" id="upload-progress">
                        <div class="upload-progress-bar" id="upload-progress-bar"></div>
                    </div>
                    <textarea id="chat-input" placeholder="Type a message..." rows="1"></textarea>
                    <i class="fas fa-at mention-icon" id="mention-icon"></i>
                    <label for="file-input" class="file-input-label"><i class="fas fa-paperclip"></i></label>
                    <input type="file" id="file-input" class="file-input">
                    <div class="task-dropdown" id="task-dropdown"></div>
                </div>
                <button onclick="sendMessage()"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
        
        <!-- Chat Toggle Button (appears when chat is hidden) -->
        <div class="chat-toggle-btn" id="chat-toggle-btn">
            <i class="fas fa-comments"></i>
            <span>Chat</span>
        </div>
    </div>

    <div class="confirmation-dialog" id="confirmation-dialog">
        <div class="dialog-box">
            <h3 id="dialog-title"></h3>
            <p id="dialog-message"></p>
            <div class="dialog-actions">
                <button class="cancel" onclick="closeConfirmation()">Cancel</button>
                <button id="confirm-button" class="confirm"></button>
            </div>
        </div>
    </div>

    <!-- File Viewer Modal -->
    <div class="file-viewer-modal" id="file-viewer-modal">
        <div class="modal-content">
            <button class="close-modal" onclick="closeFileViewer()">
                <i class="fas fa-times"></i>
            </button>
            <div class="file-content" id="file-content"></div>
        </div>
    </div>

    <!-- Submission Modal -->
    <div class="submission-modal" id="submission-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add Submission</h3>
                <button class="close-modal" onclick="closeSubmissionModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="submission-comment">Comment (Optional)</label>
                    <textarea id="submission-comment" placeholder="Add a comment about this submission..." rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label for="submission-files">Upload Files</label>
                    <div class="file-upload-area" id="file-upload-area">
                        <input type="file" id="submission-files" multiple accept="*/*">
                        <div class="upload-placeholder">
                            <i class="fas fa-cloud-upload-alt"></i>
                            <p>Drag & drop files here or click to browse</p>
                        </div>
                    </div>
                    <div class="uploaded-files" id="uploaded-files"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeSubmissionModal()">Cancel</button>
                <button class="btn-primary" onclick="submitWork()">Submit Work</button>
            </div>
        </div>
    </div>

    <!-- Comment Modal -->
    <div class="comment-modal" id="comment-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add Comment</h3>
                <button class="close-modal" onclick="closeCommentModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="comment-text">Comment</label>
                    <textarea id="comment-text" placeholder="Add your comment..." rows="5"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeCommentModal()">Cancel</button>
                <button class="btn-primary" onclick="submitComment()">Add Comment</button>
            </div>
        </div>
    </div>

    <!-- Files Popup -->
    <div class="files-popup" id="files-popup">
        <div class="popup-content">
            <div class="popup-header">
                <h4>Attached Files</h4>
                <button class="close-popup" onclick="closeFilesPopup()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="popup-body" id="files-popup-body">
                <!-- Files will be populated here -->
            </div>
        </div>
    </div>

    <!-- Assigned Task Details Modal -->
    <div class="assigned-task-modal" id="assigned-task-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="assigned-task-title">Task Details</h3>
                <button onclick="closeAssignedTaskModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body" id="assigned-task-body">
                <!-- Task details will be populated here -->
            </div>
            <div class="modal-actions" id="assigned-task-actions">
                <!-- Action buttons will be populated here -->
            </div>
        </div>
    </div>

    <!-- Success Modal -->
    <div class="success-modal" id="success-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="success-title">Success!</h3>
                <button onclick="closeSuccessModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="success-message" id="success-message">
                    <!-- Success message will be populated here -->
                </div>
            </div>
            <div class="modal-actions">
                <button class="success-btn" onclick="closeSuccessModal()">Continue</button>
            </div>
        </div>
    </div>

    <!-- Task Acceptance Modal -->
    <div class="task-acceptance-modal" id="task-acceptance-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Accept Task</h3>
                <button onclick="closeTaskAcceptanceModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="task-plan">Your Plan & Approach</label>
                    <textarea id="task-plan" placeholder="Describe your plan for completing this task, your approach, and any initial thoughts..."></textarea>
                </div>
                <div class="form-group">
                    <label for="task-questions">Questions & Clarifications</label>
                    <textarea id="task-questions" placeholder="Ask any questions you have about the task, request clarifications, or discuss requirements..."></textarea>
                </div>
                <div class="form-group">
                    <label for="task-timeline">Timeline & Milestones</label>
                    <textarea id="task-timeline" placeholder="Outline your proposed timeline, key milestones, and when you expect to deliver the work..."></textarea>
                </div>
            </div>
            <div class="modal-actions">
                <button class="cancel-btn" onclick="closeTaskAcceptanceModal()">Cancel</button>
                <button class="accept-btn" id="confirm-accept-btn" onclick="confirmAcceptTask()">Accept Task</button>
            </div>
        </div>
    </div>

    <audio id="message-ding" src="../assets/ding.mp3"></audio>

    <script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
import { getDatabase, ref, get, push, set, onValue, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";
import { getAuth } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
import { getStorage, ref as storageRef, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-storage.js";

const firebaseConfig = {
    apiKey: "AIzaSyDZIDlEtaNRxODoFhRw0xF2yYFBqqBexqo",
    authDomain: "taska-45011.firebaseapp.com",
    databaseURL: "https://taska-45011-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "taska-45011",
    storageBucket: "gs://taska-45011.firebasestorage.app",
    messagingSenderId: "205487498813",
    appId: "1:205487498813:web:0de2c9eab567482781ec54",
    measurementId: "G-G0G1F6GQ9B"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);
const storage = getStorage(app);

let userId = null;
let selectedProfessionalId = null;
let professionalData = null;
let currentUserProfile = null;
let uploadedTaskFiles = [];
let isDataLoaded = { connections: false, chats: false, tasks: false };
let currentTaskId = null;
let submissionFiles = [];

const elements = {
    connectionsList: document.getElementById('connections-list'),
    pendingRequestsList: document.getElementById('pending-requests-list'),
    chatArea: document.getElementById('chat-area'),
    chatHeader: document.getElementById('chat-header'),
    chatMessages: document.getElementById('chat-messages'),
    chatInput: document.getElementById('chat-input'),
    workflowArea: document.getElementById('workflow-area'),
    workflowList: document.getElementById('workflow-list'),
    completedTasksList: document.getElementById('completed-tasks-list'),
    confirmationDialog: document.getElementById('confirmation-dialog'),
    dialogTitle: document.getElementById('dialog-title'),
    dialogMessage: document.getElementById('dialog-message'),
    confirmButton: document.getElementById('confirm-button'),
    messageDing: document.getElementById('message-ding'),
    fileInput: document.getElementById('file-input'),
    uploadProgress: document.getElementById('upload-progress'),
    uploadProgressBar: document.getElementById('upload-progress-bar'),
    mentionIcon: document.getElementById('mention-icon'),
    taskDropdown: document.getElementById('task-dropdown'),
    chatToggleBtn: document.getElementById('chat-toggle-btn'),
    fileViewerModal: document.getElementById('file-viewer-modal'),
    fileContent: document.getElementById('file-content'),
    submissionModal: document.getElementById('submission-modal'),
    commentModal: document.getElementById('comment-modal'),
    assignedTasksList: document.getElementById('assigned-tasks-list'),
    assignedTaskModal: document.getElementById('assigned-task-modal'),
    assignedTaskTitle: document.getElementById('assigned-task-title'),
    assignedTaskBody: document.getElementById('assigned-task-body'),
    assignedTaskActions: document.getElementById('assigned-task-actions'),
    successModal: document.getElementById('success-modal'),
    successTitle: document.getElementById('success-title'),
    successMessage: document.getElementById('success-message')
};

async function fetchProfessionalData() {
    if (professionalData) return professionalData;
    try {
        const snapshot = await get(ref(db, 'professionalslist'));
        const data = snapshot.val() || {};
        professionalData = Object.keys(data).map(id => ({
            id,
            ...data[id],
            personal: data[id].personal || {},
            education: data[id].education || {},
            skills: data[id].skills || '',
            profiles: data[id].profiles || {},
            portfolio: data[id].portfolio || []
        }));
        return professionalData;
    } catch (error) {
        console.error('Error fetching professional data:', error);
        return [];
    }
}

async function fetchCurrentUserProfile() {
    if (currentUserProfile) return currentUserProfile;
    try {
        const snapshot = await get(ref(db, `studentslist/${userId}`));
        const user = snapshot.val() || {};
        currentUserProfile = {
            name: user.personal?.name || "Unnamed",
            profilePic: user.personal?.profilePic || "../assets/avatar/1.png"
        };
        return currentUserProfile;
    } catch (error) {
        console.error('Error fetching current user profile:', error);
        return { name: "Unnamed", profilePic: "../assets/avatar/1.png" };
    }
}

function confirmAction(action, title, message, actionParams = {}) {
    elements.dialogTitle.textContent = title;
    elements.dialogMessage.textContent = message;
    elements.confirmationDialog.classList.add('active');
    elements.confirmButton.textContent = title.includes('Delete') ? 'Delete' : 'Confirm';
    elements.confirmButton.className = title.includes('Delete') ? 'delete' : 'confirm';
    elements.confirmButton.onclick = () => {
        window[action](actionParams);
        closeConfirmation();
    };
}

function closeConfirmation() {
    elements.confirmationDialog.classList.remove('active');
}

function getFileIconClass(type) {
    if (type.includes('pdf')) return 'fas fa-file-pdf';
    if (type.includes('image')) return 'fas fa-file-image';
    if (type.includes('video')) return 'fas fa-file-video';
    if (type.includes('excel') || type.includes('spreadsheet')) return 'fas fa-file-excel';
    if (type.includes('word') || type.includes('doc')) return 'fas fa-file-word';
    return 'fas fa-file';
}

function getFileIconColor(type) {
    if (type.includes('pdf')) return '#FF5252';
    if (type.includes('image')) return '#4CAF50';
    if (type.includes('video')) return '#2196F3';
    if (type.includes('excel') || type.includes('spreadsheet')) return '#2E7D32';
    if (type.includes('word') || type.includes('doc')) return '#1976D2';
    return '#6c757d';
}

function isImageFile(type) {
    return type.startsWith('image/');
}

function isVideoFile(type) {
    return type.startsWith('video/');
}

function generateFileThumbnail(file) {
    if (isImageFile(file.type)) {
        return `
            <div class="file-thumbnail image-thumbnail">
                <img src="${file.url}" alt="${file.name}" loading="lazy">
                <div class="file-overlay">
                    <i class="fas fa-eye"></i>
                </div>
            </div>
        `;
    } else if (isVideoFile(file.type)) {
        return `
            <div class="file-thumbnail video-thumbnail">
                <video src="${file.url}" preload="metadata"></video>
                <div class="file-overlay">
                    <i class="fas fa-play"></i>
                </div>
            </div>
        `;
    } else {
        return `
            <a href="${file.url}" download="${file.name}" class="file-icon-container" title="${file.name}">
                <i class="${getFileIconClass(file.type)} file-icon" style="color: ${getFileIconColor(file.type)};"></i>
            </a>
        `;
    }
}

function checkAllDataLoaded() {
    if (isDataLoaded.connections && isDataLoaded.chats && isDataLoaded.tasks) {
        elements.connectionsList.classList.remove('skeleton-loading');
        elements.chatArea.classList.remove('skeleton-loading');
        elements.chatHeader.classList.remove('skeleton-loading');
        elements.chatMessages.classList.remove('skeleton-loading');
        elements.workflowList.classList.remove('skeleton-loading');
    }
}

async function init() {
    document.addEventListener('DOMContentLoaded', async () => {
        await fetchProfessionalData();
        setupEventListeners();
        auth.onAuthStateChanged(user => {
            if (user) {
                userId = user.uid;
                fetchCurrentUserProfile().then(() => {
                    loadConnections();
                    loadPendingRequests();
                    loadAssignedTasks();
                    loadWorkflows(); // Load workflows by default
                    checkAndShowWorkflowArea(); // Check if there are tasks and show workflow area
                });
            } else {
                console.error("User not authenticated");
                window.location.href = "../index.html";
            }
        });
    });
}

function setupEventListeners() {
    const hamburger = document.querySelector('.navbar .hamburger');
    const navMenu = document.querySelector('.navbar .nav-menu');
    if (hamburger && navMenu) {
        hamburger.addEventListener('click', () => navMenu.classList.toggle('active'));
    }

    document.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.closest('.user-item') && !target.closest('.pending-item')) {
            const professionalId = target.closest('.user-item').dataset.professionalId;
            selectProfessional(professionalId);
        }
        if (target.matches('.accept-btn')) {
            const professionalId = target.closest('.pending-item').dataset.professionalId;
            confirmAction('acceptRequest', 'Accept Request', 'Are you sure you want to accept this connection request?', { professionalId });
        }
        if (target.matches('.delete 붕n')) {
            const professionalId = target.closest('.pending-item').dataset.professionalId;
            confirmAction('deleteRequest', 'Delete Request', 'Are you sure you want to delete this connection request?', { professionalId });
        }
        if (target.matches('.task-menu-icon')) {
            const dropdown = target.closest('.task-menu').querySelector('.task-menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (target.matches('.task-menu-dropdown button')) {
            const action = target.dataset.action;
            const taskId = target.closest('.workflow-item').dataset.taskId;
            if (action === 'deleteTask') {
                confirmAction('deleteTask', 'Delete Task', 'Are you sure you want to delete this task?', { taskId });
            }
        }
        if (target.matches('.reaction-icon')) {
            const messageId = target.closest('.message').dataset.messageId;
            const reaction = target.dataset.reaction;
            toggleReaction(messageId, reaction);
        }
        if (target.matches('.message-menu-icon')) {
            const dropdown = target.closest('.message-menu').querySelector('.message-menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (target.matches('.message-menu-dropdown button')) {
            const action = target.dataset.action;
            const messageId = target.closest('.message').dataset.messageId;
            if (action === 'deleteMessage') {
                confirmAction('deleteMessage', 'Delete Message', 'Are you sure you want to delete this message?', { messageId });
            }
        }
        if (target.matches('.chat-header .menu-icon')) {
            const dropdown = target.closest('.menu').querySelector('.menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (target.matches('.chat-header .menu-dropdown button')) {
            const action = target.dataset.action;
            if (action === 'deleteConnection') {
                confirmAction('deleteConnection', 'Delete Connection', 'Are you sure you want to delete this connection?', { professionalId: selectedProfessionalId });
            }
        }
        if (target.matches('.mention-icon')) {
            elements.taskDropdown.classList.toggle('active');
            if (elements.taskDropdown.classList.contains('active')) {
                await populateTaskDropdown();
            }
        }
        if (target.matches('.task-dropdown-item')) {
            const taskTitle = target.textContent;
            insertMention(taskTitle);
        }
        if (target.matches('.chat-toggle-btn') || target.closest('.chat-toggle-btn')) {
            showChat();
        }
        if (target.closest('.file-thumbnail')) {
            const thumbnail = target.closest('.file-thumbnail');
            const img = thumbnail.querySelector('img');
            const video = thumbnail.querySelector('video');
            if (img) {
                openFileViewer(img.src, 'image/jpeg', img.alt);
            } else if (video) {
                openFileViewer(video.src, 'video/mp4', 'Video');
            }
        }
    });

    if (elements.workflowList) {
        elements.workflowList.addEventListener('change', (e) => {
            if (e.target.matches('.status-select')) {
                const taskId = e.target.closest('.workflow-item').dataset.taskId;
                const newStatus = e.target.value;
                confirmAction('updateStatus', `Update Task Status`, `Are you sure you want to change the task status to "${newStatus}"?`, { taskId, status: newStatus });
            }
        });
    }

    if (elements.chatInput) {
        elements.chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        elements.chatInput.addEventListener('input', async () => {
            elements.chatInput.style.height = 'auto';
            elements.chatInput.style.height = `${Math.min(elements.chatInput.scrollHeight, 100)}px`;
            const value = elements.chatInput.value;
            if (value.endsWith('@') && !elements.taskDropdown.classList.contains('active')) {
                elements.taskDropdown.classList.add('active');
                await populateTaskDropdown();
            }
        });
        elements.chatInput.addEventListener('keydown', (e) => {
            if (elements.taskDropdown.classList.contains('active')) {
                const items = elements.taskDropdown.querySelectorAll('.task-dropdown-item');
                let selectedIndex = -1;
                items.forEach((item, index) => {
                    if (item.classList.contains('selected')) selectedIndex = index;
                });
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    items.forEach(item => item.classList.remove('selected'));
                    items[selectedIndex].classList.add('selected');
                    items[selectedIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, 0);
                    items.forEach(item => item.classList.remove('selected'));
                    items[selectedIndex].classList.add('selected');
                    items[selectedIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    const taskTitle = items[selectedIndex].textContent;
                    insertMention(taskTitle);
                } else if (e.key === 'Escape') {
                    elements.taskDropdown.classList.remove('active');
                }
            }
        });
    }

    if (elements.fileInput) {
        elements.fileInput.addEventListener('change', async () => {
            if (elements.fileInput.files.length > 0) {
                await sendFileMessage(elements.fileInput.files[0]);
                elements.fileInput.value = '';
            }
        });
    }

    // Submission file upload listeners
    const submissionFilesInput = document.getElementById('submission-files');
    if (submissionFilesInput) {
        submissionFilesInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            submissionFiles.push(...files);
            updateUploadedFiles();
            e.target.value = '';
        });
    }

    const fileUploadArea = document.getElementById('file-upload-area');
    if (fileUploadArea) {
        fileUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileUploadArea.classList.add('dragover');
        });

        fileUploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            fileUploadArea.classList.remove('dragover');
        });

        fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUploadArea.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files);
            submissionFiles.push(...files);
            updateUploadedFiles();
        });

        fileUploadArea.addEventListener('click', () => {
            submissionFilesInput.click();
        });
    }

    document.addEventListener('click', (e) => {
        if (!e.target.closest('.task-menu')) {
            document.querySelectorAll('.task-menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        if (!e.target.closest('.message-menu')) {
            document.querySelectorAll('.message-menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        if (!e.target.closest('.chat-header .menu')) {
            document.querySelectorAll('.chat-header .menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        if (!e.target.closest('.input-container')) {
            elements.taskDropdown.classList.remove('active');
        }
        // Hide chat when clicking outside
        if (elements.chatArea && elements.chatArea.style.display === 'block' && 
            !e.target.closest('.chat-area') && !e.target.closest('.chat-toggle-btn')) {
            hideChat();
        }
    });
}

async function loadConnections() {
    if (!elements.connectionsList) return;
    try {
        const connectionsRef = ref(db, `users/${userId}/connections`);
        const snapshot = await get(connectionsRef);
        elements.connectionsList.innerHTML = '';
        if (snapshot.exists()) {
            const connections = snapshot.val();
            let hasConnections = false;
            const professionals = await fetchProfessionalData();
            for (const professionalId in connections) {
                if (connections[professionalId].status === "connected") {
                    hasConnections = true;
                    const professional = professionals.find(p => p.id === professionalId) || {};
                    const userName = professional.personal?.name || "Unnamed";
                    const profilePic = professional.personal?.profilePic || "../assets/avatar/1.png";
                    const chatId = [userId, professionalId].sort().join("+");
                    const chatRef = ref(db, `chats/${chatId}/messages`);
                    let lastMessage = "No messages yet";
                    let hasUnread = false;
                    const chatSnapshot = await get(chatRef);
                    if (chatSnapshot.exists()) {
                        const messages = Object.values(chatSnapshot.val());
                        const lastMsg = messages[messages.length - 1];
                        lastMessage = lastMsg.file ? `[File] ${lastMsg.file.name}` : lastMsg.content || "No messages yet";
                        hasUnread = messages.some(msg => msg.senderId !== userId && !msg.read);
                    }
                    const userItem = document.createElement('div');
                    userItem.className = 'user-item';
                    userItem.dataset.professionalId = professionalId;
                    userItem.innerHTML = `
                        <img src="${profilePic}" alt="${userName}" class="profile-pic">
                        <div class="user-info">
                            <div class="name">${userName}</div>
                            <div class="last-message">${lastMessage}</div>
                        </div>
                        ${hasUnread ? '<div class="unread-dot"></div>' : ''}
                    `;
                    elements.connectionsList.appendChild(userItem);
                }
            }
            if (!hasConnections) {
                elements.connectionsList.innerHTML = '<p>No connected professionals found.</p>';
            }
        } else {
            elements.connectionsList.innerHTML = '<p>No connected professionals found.</p>';
        }
        isDataLoaded.connections = true;
        checkAllDataLoaded();
    } catch (error) {
        console.error("Error loading connections:", error);
        elements.connectionsList.innerHTML = '<p>Error loading connections.</p>';
        isDataLoaded.connections = true;
        checkAllDataLoaded();
    }
}

async function loadPendingRequests() {
    if (!elements.pendingRequestsList) return;
    try {
        const connectionsRef = ref(db, `users/${userId}/connections`);
        const snapshot = await get(connectionsRef);
        elements.pendingRequestsList.innerHTML = '';
        const pendingRequestsSection = document.querySelector('.pending-requests');
        if (snapshot.exists()) {
            const connections = snapshot.val();
            let hasPending = false;
            const professionals = await fetchProfessionalData();
            for (const professionalId in connections) {
                if (connections[professionalId].status === "pending") {
                    hasPending = true;
                    const professional = professionals.find(p => p.id === professionalId) || {};
                    const userName = professional.personal?.name || "Unnamed";
                    const profilePic = professional.personal?.profilePic || "../assets/avatar/1.png";
                    const pendingItem = document.createElement('div');
                    pendingItem.className = 'pending-item user-item';
                    pendingItem.dataset.professionalId = professionalId;
                    pendingItem.innerHTML = `
                        <div class="user-info">
                            <img src="${profilePic}" alt="${userName}" class="profile-pic">
                            <div class="name">${userName}</div>
                        </div>
                        <div class="actions">
                            <button class="accept-btn">Accept</button>
                            <button class="delete-btn">Delete</button>
                        </div>
                    `;
                    elements.pendingRequestsList.appendChild(pendingItem);
                }
            }
            pendingRequestsSection.style.display = hasPending ? 'block' : 'none';
        } else {
            pendingRequestsSection.style.display = 'none';
        }
    } catch (error) {
        console.error("Error loading pending requests:", error);
        elements.pendingRequestsList.innerHTML = '<p>Error loading pending requests.</p>';
        document.querySelector('.pending-requests').style.display = 'none';
    }
}

async function acceptRequest({ professionalId }) {
    try {
        const studentConnectionRef = ref(db, `users/${userId}/connections/${professionalId}`);
        const professionalConnectionRef = ref(db, `users/${professionalId}/connections/${userId}`);
        await update(studentConnectionRef, { status: "connected" });
        await update(professionalConnectionRef, { status: "connected" });
        professionalData = null; // Clear cache
        await loadConnections();
        await loadPendingRequests();
    } catch (error) {
        console.error("Error accepting request:", error);
        alert("Failed to accept request.");
    }
}

async function deleteRequest({ professionalId }) {
    try {
        const studentConnectionRef = ref(db, `users/${userId}/connections/${professionalId}`);
        const professionalConnectionRef = ref(db, `users/${professionalId}/connections/${userId}`);
        await remove(studentConnectionRef);
        await remove(professionalConnectionRef);
        professionalData = null; // Clear cache to refresh professional data
        loadConnections();
        loadPendingRequests();
    } catch (error) {
        console.error("Error deleting request:", error);
        alert("Failed to delete request.");
    }
}

async function deleteConnection({ professionalId }) {
    try {
        const studentConnectionRef = ref(db, `users/${userId}/connections/${professionalId}`);
        const professionalConnectionRef = ref(db, `users/${professionalId}/connections/${userId}`);
        await remove(studentConnectionRef);
        await remove(professionalConnectionRef);
        professionalData = null; // Clear cache to refresh professional data
        loadConnections();
        loadPendingRequests();
        elements.chatArea.style.display = 'none';
        elements.workflowArea.style.display = 'none';
        selectedProfessionalId = null;
    } catch (error) {
        console.error("Error deleting connection:", error);
        alert("Failed to delete connection.");
    }
}

async function deleteTask({ taskId }) {
    try {
        const taskRef = ref(db, `tasks/${taskId}`);
        await remove(taskRef);
        loadWorkflows();
    } catch (error) {
        console.error("Error deleting task:", error);
        alert("Failed to delete task.");
    }
}

async function deleteMessage({ messageId }) {
    try {
        const chatId = [userId, selectedProfessionalId].sort().join("+");
        const messageRef = ref(db, `chats/${chatId}/messages/${messageId}`);
        await remove(messageRef);
    } catch (error) {
        console.error("Error deleting message:", error);
        alert("Failed to delete message.");
    }
}

async function selectProfessional(professionalId) {
    selectedProfessionalId = professionalId;
    document.querySelectorAll('.user-item').forEach(item => {
        const isActive = item.dataset.professionalId === professionalId;
        item.classList.toggle('active', isActive);
        const lastMessage = item.querySelector('.last-message');
        if (lastMessage) lastMessage.style.display = isActive ? 'none' : 'block';
        if (isActive) {
            const unreadDot = item.querySelector('.unread-dot');
            if (unreadDot) unreadDot.remove();
        }
    });
    if (elements.workflowArea) elements.workflowArea.style.display = 'block';
    if (elements.chatToggleBtn) elements.chatToggleBtn.style.display = 'flex';
    loadChatHeader();
    loadChat();
    loadWorkflows();
}

async function loadChatHeader() {
    if (!elements.chatHeader) return;
    try {
        const professionals = await fetchProfessionalData();
        const professional = professionals.find(p => p.id === selectedProfessionalId) || {};
        const userName = professional.personal?.name || "Unnamed";
        const userTitle = professional.education?.branch || "";
        const profilePic = professional.personal?.profilePic || "../assets/avatar/1.png";
        elements.chatHeader.innerHTML = `
            <div style="display: flex; align-items: center; gap: 1rem;">
                <img src="${profilePic}" alt="${userName}" class="profile-pic">
                <div>
                    <div class="name">${userName}</div>
                    <div class="title">${userTitle}</div>
                </div>
            </div>
            <div class="chat-actions">
            <div class="menu">
                <i class="fas fa-ellipsis-v menu-icon"></i>
                <div class="menu-dropdown">
                    <button data-action="deleteConnection">Delete Connection</button>
                    </div>
                </div>
            </div>
        `;
    } catch (error) {
        console.error("Error loading chat header:", error);
        elements.chatHeader.innerHTML = `
            <div style="display: flex; align-items: center; gap: 1rem;">
                <img src="../assets/avatar/1.png" alt="Unnamed" class="profile-pic">
                <div>
                    <div class="name">Unnamed</div>
                    <div class="title"></div>
                </div>
            </div>
            <div class="chat-actions">
            <div class="menu">
                <i class="fas fa-ellipsis-v menu-icon"></i>
                <div class="menu-dropdown">
                    <button data-action="deleteConnection">Delete Connection</button>
                    </div>
                </div>
            </div>
        `;
    }
}

function formatMessageDate(timestamp) {
    const now = new Date();
    const messageDate = new Date(timestamp);
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
    const messageDay = new Date(messageDate.getFullYear(), messageDate.getMonth(), messageDate.getDate());
    if (messageDay.getTime() === today.getTime()) {
        return 'Today';
    } else if (messageDay.getTime() === yesterday.getTime()) {
        return 'Yesterday';
    } else {
        return messageDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
}

async function loadChat() {
    if (!elements.chatMessages) return;
    elements.chatMessages.innerHTML = `
        <div class="skeleton-message"></div>
        <div class="skeleton-message"></div>
    `;
    if (selectedProfessionalId) {
        const chatId = [userId, selectedProfessionalId].sort().join("+");
        const chatRef = ref(db, `chats/${chatId}/messages`);
        const currentUser = await fetchCurrentUserProfile();
        onValue(chatRef, async (snapshot) => {
            elements.chatMessages.innerHTML = '';
            if (snapshot.exists()) {
                const messages = Object.entries(snapshot.val())
                    .map(([id, msg]) => ({ id, ...msg }))
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const professionals = await fetchProfessionalData();
                const professional = professionals.find(p => p.id === selectedProfessionalId) || {};
                const tasksRef = ref(db, `tasks`);
                const tasksSnapshot = await get(tasksRef);
                const tasks = tasksSnapshot.exists() ? tasksSnapshot.val() : {};
                let taskTitles = [];
                for (const taskId in tasks) {
                    if (tasks[taskId].studentId === userId && tasks[taskId].professionalId === selectedProfessionalId) {
                        taskTitles.push(tasks[taskId].title);
                    }
                }
                let lastDate = null;
                messages.forEach(msg => {
                    const isSent = msg.senderId === userId;
                    const senderName = isSent ? currentUser.name : (professional.personal?.name || "Unnamed");
                    const profilePic = isSent 
                        ? currentUser.profilePic
                        : professional.personal?.profilePic || "../assets/avatar/1.png";
                    const time = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const date = formatMessageDate(msg.timestamp);
                    if (date !== lastDate) {
                        const dateDivider = document.createElement('div');
                        dateDivider.className = 'date-divider';
                        dateDivider.innerHTML = `<span>${date}</span>`;
                        elements.chatMessages.appendChild(dateDivider);
                        lastDate = date;
                    }
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message ${isSent ? 'sent' : 'received'} ${msg.file ? 'file-message' : ''}`;
                    messageDiv.dataset.messageId = msg.id;
                    let content = msg.content || '';
                    taskTitles.forEach(title => {
                        const regex = new RegExp(`@${title.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')}`, 'g');
                        content = content.replace(regex, `<span class="mention">@${title}</span>`);
                    });
                    let reactionsHTML = '';
                    if (msg.reactions && msg.reactions[userId]) {
                        reactionsHTML = `<span class="reaction">${msg.reactions[userId]}</span>`;
                    }
                    if (msg.file) {
                        const fileSize = msg.file.size ? (msg.file.size / 1024).toFixed(2) + ' KB' : 'Unknown size';
                        messageDiv.innerHTML = `
                            <div class="message-header">
                                <img src="${profilePic}" alt="${senderName}" class="profile-pic">
                                <div class="name">${senderName}</div>
                                <div class="time">${time}</div>
                            </div>
                            <a href="${msg.file.url}" download="${msg.file.name}" target="_blank">
                                <div class="file-info">
                                    <i class="${getFileIconClass(msg.file.type)} file-icon" style="color: ${getFileIconColor(msg.file.type)};"></i>
                                    <div class="file-details">
                                        <div class="file-name">${msg.file.name}</div>
                                        <div class="file-size">${fileSize}</div>
                                    </div>
                                </div>
                            </a>
                            <div class="read-status">${msg.read ? 'Seen' : 'Sent'}</div>
                            <div class="reactions">${reactionsHTML}</div>
                            <div class="reaction-bar">
                                <span class="reaction-icon" data-reaction="🤝">🤝</span>
                                <span class="reaction-icon" data-reaction="👍">👍</span>
                                <span class="reaction-icon" data-reaction="❤️">❤️</span>
                                <div class="message-menu">
                                    <i class="fas fa-ellipsis-h message-menu-icon"></i>
                                    <div class="message-menu-dropdown">
                                        <button data-action="deleteMessage">Delete Message</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        messageDiv.innerHTML = `
                            <div class="message-header">
                                <img src="${profilePic}" alt="${senderName}" class="profile-pic">
                                <div class="name">${senderName}</div>
                                <div class="time">${time}</div>
                            </div>
                            <div class="content">${content}</div>
                            <div class="read-status">${msg.read ? 'Seen' : 'Sent'}</div>
                            <div class="reactions">${reactionsHTML}</div>
                            <div class="reaction-bar">
                                <span class="reaction-icon" data-reaction="🤝">🤝</span>
                                <span class="reaction-icon" data-reaction="👍">👍</span>
                                <span class="reaction-icon" data-reaction="❤️">❤️</span>
                                <div class="message-menu">
                                    <i class="fas fa-ellipsis-h message-menu-icon"></i>
                                    <div class="message-menu-dropdown">
                                        <button data-action="deleteMessage">Delete Message</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    elements.chatMessages.appendChild(messageDiv);
                });
                elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
                messages.forEach(msg => {
                    if (msg.senderId !== userId && !msg.read) {
                        update(ref(db, `chats/${chatId}/messages/${msg.id}`), { read: true });
                    }
                });
            } else {
                elements.chatMessages.innerHTML = '<div class="message">No messages yet</div>';
            }
            isDataLoaded.chats = true;
            checkAllDataLoaded();
        });
    }
}

async function toggleReaction(messageId, reaction) {
    try {
        const chatId = [userId, selectedProfessionalId].sort().join("+");
        const messageRef = ref(db, `chats/${professionalId}/messages/${messageId}`);
        const snapshot = await get(messageRef);
        if (snapshot.exists()) {
            const message = snapshot.val();
            const reactions = message.reactions || {};
            if (reactions[userId] === reaction) {
                delete reactions[userId];
            } else {
                reactions[userId] = reaction;
            }
            await update(messageRef, { reactions });
        }
    } catch (error) {
        console.error("Error toggling reaction:", error);
        alert("Failed to toggle reaction.");
    }
}

async function sendMessage() {
    if (!elements.chatInput) return;
    const content = elements.chatInput.value.trim();
    if (!content || !selectedProfessionalId) return;
    const chatId = [userId, selectedProfessionalId].sort().join("+");
    const messageRef = ref(db, `chats/${chatId}/messages`);
    try {
        const currentUser = await fetchCurrentUserProfile();
        const newMessage = {
            senderId: userId,
            senderName: currentUser.name,
            content,
            timestamp: new Date().toISOString(),
            read: false
        };
        await push(messageRef, newMessage);
        elements.chatInput.value = '';
        elements.chatInput.style.height = 'auto';
        elements.taskDropdown.classList.remove('active');
        if (elements.messageDing) {
            elements.messageDing.play().catch(error => console.error("Error playing ding sound:", error));
        }
    } catch (error) {
        console.error("Error sending message:", error);
        alert("Failed to send message.");
    }
}

async function sendFileMessage(file) {
    if (!selectedProfessionalId) return;
    const chatId = [userId, selectedProfessionalId].sort().join("+");
    const messageRef = ref(db, `chats/${chatId}/messages`);
    try {
        const storagePath = `chats/${chatId}/${Date.now()}_${file.name}`;
        const fileRef = storageRef(storage, storagePath);
        const uploadTask = uploadBytesResumable(fileRef, file);

        elements.uploadProgress.classList.add('active');
        elements.uploadProgressBar.style.width = '0%';

        uploadTask.on('state_changed',
            (snapshot) => {
                const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                elements.uploadProgressBar.style.width = `${progress}%`;
            },
            (error) => {
                console.error('Error uploading file:', error);
                elements.uploadProgress.classList.remove('active');
                alert('Failed to upload file.');
            },
            async () => {
                const fileUrl = await getDownloadURL(fileRef);
                const currentUser = await fetchCurrentUserProfile();
                const newMessage = {
                    senderId: userId,
                    senderName: currentUser.name,
                    file: {
                        name: file.name,
                        url: fileUrl,
                        type: file.type,
                        size: file.size
                    },
                    timestamp: new Date().toISOString(),
                    read: false
                };
                await push(messageRef, newMessage);
                elements.uploadProgress.classList.remove('active');
                if (elements.messageDing) {
                    elements.messageDing.play().catch(error => console.error("Error playing ding sound:", error));
                }
            }
        );
    } catch (error) {
        console.error("Error initiating file upload:", error);
        elements.uploadProgress.classList.remove('active');
        alert("Failed to upload file.");
    }
}

async function openTaskPopup(taskId = null) {
    alert('Students cannot create tasks. You can only edit existing tasks assigned to you.');
    return;
}

async function populateTaskDropdown() {
    try {
        const tasksRef = ref(db, `tasks`);
        const snapshot = await get(tasksRef);
        elements.taskDropdown.innerHTML = '';
        if (snapshot.exists()) {
            const tasks = snapshot.val();
            let taskFound = false;
            for (const id in tasks) {
                if (tasks[id].studentId === userId && tasks[id].professionalId === selectedProfessionalId) {
                    taskFound = true;
                    const taskItem = document.createElement('div');
                    taskItem.className = 'task-dropdown-item';
                    taskItem.textContent = tasks[id].title;
                    elements.taskDropdown.appendChild(taskItem);
                }
            }
            if (!taskFound) {
                elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">No tasks available</div>';
            }
        } else {
            elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">No tasks available</div>';
        }
    } catch (error) {
        console.error("Error populating task dropdown:", error);
        elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">Error loading tasks</div>';
    }
}

function insertMention(taskTitle) {
    const currentValue = elements.chatInput.value;
    const cursorPos = elements.chatInput.selectionStart;
    const textBefore = currentValue.substring(0, cursorPos);
    const textAfter = currentValue.substring(cursorPos);
    const lastAtIndex = textBefore.lastIndexOf('@');
    let newValue;
    if (lastAtIndex >= 0 && lastAtIndex === cursorPos - 1) {
        newValue = textBefore + taskTitle + ' ' + textAfter;
    } else {
        newValue = textBefore + '@' + taskTitle + ' ' + textAfter;
    }
    elements.chatInput.value = newValue;
    elements.chatInput.focus();
    const newCursorPos = lastAtIndex >= 0 ? lastAtIndex + taskTitle.length + 2 : cursorPos + taskTitle.length + 2;
    elements.chatInput.setSelectionRange(newCursorPos, newCursorPos);
    elements.taskDropdown.classList.remove('active');
    elements.chatInput.style.height = 'auto';
    elements.chatInput.style.height = `${Math.min(elements.chatInput.scrollHeight, 100)}px`;
}

function loadWorkflows() {
    if (!elements.workflowList) return;
    
    const tasksRef = ref(db, `tasks`);
    onValue(tasksRef, (snapshot) => {
        elements.workflowList.innerHTML = '';
        let hasTasks = false;
        
        if (snapshot.exists()) {
            const tasks = snapshot.val();
            const filteredTasks = [];
            
            // Filter and collect tasks for the current student
            for (const taskId in tasks) {
                const task = tasks[taskId];
                // Show tasks for the current student, either all tasks or filtered by selected professional
                if (task.studentId === userId && (!selectedProfessionalId || task.professionalId === selectedProfessionalId)) {
                    filteredTasks.push({ taskId, ...task });
                }
            }
            
            // Sort tasks by deadline (nearest first)
            filteredTasks.sort((a, b) => {
                const deadlineA = new Date(a.deadline);
                const deadlineB = new Date(b.deadline);
                return deadlineA - deadlineB;
            });
            
            // Create workflow items for sorted tasks
            filteredTasks.forEach(({ taskId, ...task }) => {
                hasTasks = true;
                const workflowItem = document.createElement('div');
                workflowItem.className = 'workflow-item';
                workflowItem.dataset.taskId = taskId;
                workflowItem.innerHTML = `
                    <div class="task-header">
                        <div class="task-info">
                        <h4>${task.title}</h4>
                            <p class="task-description">${task.description}</p>
                        </div>
                        <div class="task-menu">
                            <i class="fas fa-ellipsis-v task-menu-icon"></i>
                            <div class="task-menu-dropdown">
                                <button data-action="deleteTask" class="delete-task-btn">Delete Task</button>
                            </div>
                        </div>
                    </div>
                    <div class="task-meta">
                    <div class="deadline-container">
                            <div class="circular-progress">
                                <div class="circular-progress-ring">
                                    <svg class="progress-ring" width="60" height="60">
                                        <circle class="progress-ring-circle-bg" cx="30" cy="30" r="24" stroke-width="4"></circle>
                                        <circle class="progress-ring-circle" cx="30" cy="30" r="24" stroke-width="4" 
                                            stroke-dasharray="${2 * Math.PI * 24}" 
                                            stroke-dashoffset="${2 * Math.PI * 24 * (1 - calculateDeadlineProgress(task.deadline) / 100)}"
                                            style="stroke: ${getDeadlineColor(task.deadline)};"></circle>
                                    </svg>
                                    <div class="progress-text">
                                        <span class="days-number">${calculateDaysLeft(task.deadline)}</span>
                                        <span class="days-label">days</span>
                    </div>
                                </div>
                            </div>
                        </div>
                        ${task.files && Object.keys(task.files).length > 0 ? `
                            <div class="files-count" onclick="toggleFilesPopup('${taskId}', event)">
                                <i class="fas fa-paperclip"></i>
                                <span>${Object.keys(task.files).length} ${getFileTypeLabel(task.files)}</span>
                            </div>
                        ` : ''}
                    </div>
                    <div class="task-timeline">
                        <div class="timeline-header">
                            <h5>Submission Timeline</h5>
                            <div class="timeline-actions">
                                <button class="add-comment-btn" onclick="openCommentModal('${taskId}')">
                                    <i class="fas fa-comment"></i> Add Comment
                                </button>
                                <button class="add-submission-btn" onclick="openSubmissionModal('${taskId}')">
                                    <i class="fas fa-plus"></i> Add Submission
                                </button>
                            </div>
                        </div>
                        <div class="timeline-content" id="timeline-${taskId}">
                            ${generateTimelineHTML(task.submissions || {}, task.comments || {})}
                        </div>
                    </div>
                `;
                elements.workflowList.appendChild(workflowItem);
            });
        }
        if (!hasTasks) {
            elements.workflowList.innerHTML = '<p>No tasks found.</p>';
        }
        isDataLoaded.tasks = true;
        checkAllDataLoaded();
        
        // Check and show workflow area if there are tasks
        if (hasTasks && elements.workflowArea) {
            elements.workflowArea.style.display = 'block';
        }
    });
}

async function checkAndShowWorkflowArea() {
    try {
        const tasksRef = ref(db, `tasks`);
        const snapshot = await get(tasksRef);
        
        if (snapshot.exists()) {
            const tasks = snapshot.val();
            const hasTasks = Object.values(tasks).some(task => task.studentId === userId);
            
            if (hasTasks && elements.workflowArea) {
                elements.workflowArea.style.display = 'block';
            }
        }
    } catch (error) {
        console.error('Error checking workflow area:', error);
    }
}

function hideChat() {
    if (elements.chatArea) {
        elements.chatArea.classList.add('chat-hidden');
        setTimeout(() => {
            elements.chatArea.style.display = 'none';
        }, 300);
    }
    if (elements.chatToggleBtn) {
        elements.chatToggleBtn.style.display = 'flex';
    }
}

function showChat() {
    if (elements.chatArea) {
        elements.chatArea.style.display = 'block';
        elements.chatArea.classList.remove('chat-hidden');
    }
    if (elements.chatToggleBtn) {
        elements.chatToggleBtn.style.display = 'none';
    }
}

function openFileViewer(fileUrl, fileType, fileName) {
    if (elements.fileViewerModal && elements.fileContent) {
        let content = '';
        if (isImageFile(fileType)) {
            content = `<img src="${fileUrl}" alt="${fileName}" style="max-width: 100%; max-height: 80vh; object-fit: contain;">`;
        } else if (isVideoFile(fileType)) {
            content = `<video src="${fileUrl}" controls style="max-width: 100%; max-height: 80vh;"></video>`;
        }
        elements.fileContent.innerHTML = content;
        elements.fileViewerModal.classList.add('active');
    }
}

function closeFileViewer() {
    if (elements.fileViewerModal) {
        elements.fileViewerModal.classList.remove('active');
        if (elements.fileContent) {
            elements.fileContent.innerHTML = '';
        }
    }
}

function generateTimelineHTML(submissions, comments) {
    const allItems = [];
    
    // Add submissions
    if (submissions && Object.keys(submissions).length > 0) {
        Object.entries(submissions).forEach(([id, submission]) => {
            allItems.push({
                id,
                type: 'submission',
                ...submission
            });
        });
    }
    
    // Add comments
    if (comments && Object.keys(comments).length > 0) {
        Object.entries(comments).forEach(([id, comment]) => {
            allItems.push({
                id,
                type: 'comment',
                ...comment
            });
        });
    }
    
    if (allItems.length === 0) {
        return '<div class="timeline-empty">No submissions or comments yet</div>';
    }
    
    // Sort all items by timestamp (newest first)
    const sortedItems = allItems.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    return sortedItems.map(item => {
        if (item.type === 'submission') {
            return `
                <div class="timeline-item">
                    <div class="timeline-marker">
                        <i class="fas fa-upload"></i>
                                    </div>
                    <div class="timeline-item-content">
                        <div class="timeline-header">
                            <span class="submission-author">${item.authorName}</span>
                            <span class="submission-date">${formatSubmissionDate(item.timestamp)}</span>
                                </div>
                        ${item.comment ? `<div class="submission-comment">${item.comment}</div>` : ''}
                        ${item.files ? `
                            <div class="submission-files">
                                ${Object.values(item.files).map(file => `
                                    <a href="${file.url}" download="${file.name}" class="submission-file">
                                        <i class="${getFileIconClass(file.type)}"></i>
                                        <span>${file.name}</span>
                                    </a>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        } else {
            return `
                <div class="timeline-item">
                    <div class="timeline-marker comment-marker">
                        <i class="fas fa-comment"></i>
                    </div>
                    <div class="timeline-item-content">
                        <div class="timeline-header">
                            <span class="comment-author">${item.authorName}</span>
                            <span class="comment-date">${formatSubmissionDate(item.timestamp)}</span>
                        </div>
                        <div class="comment-content">${formatCommentContent(item.content)}</div>
                    </div>
                </div>
            `;
        }
    }).join('');
}

function formatSubmissionDate(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diffTime = now - date;
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) {
        return 'Today at ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else if (diffDays === 1) {
        return 'Yesterday at ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else if (diffDays < 7) {
        return diffDays + ' days ago';
    } else {
        return date.toLocaleDateString();
    }
}

function formatCommentContent(content) {
    if (!content) return '';
    
    // Convert markdown-like formatting to HTML
    let formattedContent = content
        // Convert **text** to <strong>text</strong>
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        // Convert line breaks to <br> tags
        .replace(/\n/g, '<br>');
    
    return formattedContent;
}

function openSubmissionModal(taskId) {
    currentTaskId = taskId;
    if (elements.submissionModal) {
        elements.submissionModal.classList.add('active');
        submissionFiles = [];
        updateUploadedFiles();
    }
}

function closeSubmissionModal() {
    if (elements.submissionModal) {
        elements.submissionModal.classList.remove('active');
        currentTaskId = null;
        submissionFiles = [];
        document.getElementById('submission-comment').value = '';
        updateUploadedFiles();
    }
}

function updateUploadedFiles() {
    const uploadedFilesDiv = document.getElementById('uploaded-files');
    if (uploadedFilesDiv) {
        uploadedFilesDiv.innerHTML = submissionFiles.map((file, index) => `
            <div class="uploaded-file">
                <i class="${getFileIconClass(file.type)}"></i>
                <span>${file.name}</span>
                <button onclick="removeSubmissionFile(${index})" class="remove-file">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `).join('');
    }
}

function removeSubmissionFile(index) {
    submissionFiles.splice(index, 1);
    updateUploadedFiles();
}

async function submitWork() {
    if (!currentTaskId || submissionFiles.length === 0) {
        alert('Please upload at least one file');
        return;
    }
    
    try {
        const comment = document.getElementById('submission-comment').value.trim();
        const taskRef = ref(db, `tasks/${currentTaskId}`);
        const submissionsRef = ref(db, `tasks/${currentTaskId}/submissions`);
        
        // Upload files
        const uploadedFiles = {};
        for (let i = 0; i < submissionFiles.length; i++) {
            const file = submissionFiles[i];
            const storagePath = `tasks/${currentTaskId}/submissions/${Date.now()}_${i}_${file.name}`;
            const fileRef = storageRef(storage, storagePath);
            const uploadTask = uploadBytesResumable(fileRef, file);
            
            await new Promise((resolve, reject) => {
                uploadTask.on('state_changed',
                    () => {},
                    reject,
                    async () => {
                        const fileUrl = await getDownloadURL(fileRef);
                        uploadedFiles[`file_${i}`] = {
                            name: file.name,
                            url: fileUrl,
                            type: file.type,
                            size: file.size
                        };
                        resolve();
                    }
                );
            });
        }
        
        // Create submission
        const currentUser = await fetchCurrentUserProfile();
        const submission = {
            authorId: userId,
            authorName: currentUser.name,
            comment: comment,
            files: uploadedFiles,
            timestamp: new Date().toISOString()
        };
        
        await push(submissionsRef, submission);
        closeSubmissionModal();
        
        // Refresh the timeline
        loadWorkflows();
        
    } catch (error) {
        console.error('Error submitting work:', error);
        alert('Failed to submit work. Please try again.');
    }
}

function getFileTypeLabel(files) {
    const fileArray = Object.values(files);
    if (fileArray.length === 0) return 'files';
    
    const imageCount = fileArray.filter(file => isImageFile(file.type)).length;
    const videoCount = fileArray.filter(file => isVideoFile(file.type)).length;
    const pdfCount = fileArray.filter(file => file.type.includes('pdf')).length;
    const documentCount = fileArray.filter(file => 
        file.type.includes('word') || 
        file.type.includes('doc') || 
        file.type.includes('excel') || 
        file.type.includes('spreadsheet')
    ).length;
    
    if (imageCount === fileArray.length) {
        return imageCount === 1 ? 'image' : 'images';
    } else if (videoCount === fileArray.length) {
        return videoCount === 1 ? 'video' : 'videos';
    } else if (pdfCount === fileArray.length) {
        return pdfCount === 1 ? 'PDF' : 'PDFs';
    } else if (documentCount === fileArray.length) {
        return documentCount === 1 ? 'document' : 'documents';
    } else {
        return fileArray.length === 1 ? 'file' : 'files';
    }
}

function toggleFilesPopup(taskId, event) {
    event.stopPropagation();
    const popup = document.getElementById('files-popup');
    const popupBody = document.getElementById('files-popup-body');
    
    if (popup.classList.contains('active')) {
        closeFilesPopup();
        return;
    }
    
    // Get task files
    const taskRef = ref(db, `tasks/${taskId}`);
    get(taskRef).then((snapshot) => {
        if (snapshot.exists()) {
            const task = snapshot.val();
            if (task.files) {
                const filesHTML = Object.values(task.files).map(file => `
                    <div class="popup-file-item">
                        <div class="file-thumbnail-container">
                            ${generateFileThumbnail(file)}
                        </div>
                        <div class="file-info">
                            <div class="file-name">${file.name}</div>
                            <div class="file-size">${file.size ? (file.size / 1024).toFixed(2) + ' KB' : 'Unknown size'}</div>
                        </div>
                        <div class="file-actions">
                            <a href="${file.url}" download="${file.name}" class="download-btn" title="Download">
                                <i class="fas fa-download"></i>
                            </a>
                            ${isImageFile(file.type) || isVideoFile(file.type) ? `
                                <button class="view-btn" onclick="openFileViewer('${file.url}', '${file.type}', '${file.name}')" title="View">
                                    <i class="fas fa-eye"></i>
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `).join('');
                
                popupBody.innerHTML = filesHTML;
            } else {
                popupBody.innerHTML = '<div class="no-files">No files attached</div>';
            }
        }
    });
    
    // Position popup to the left of the clicked element
    const rect = event.target.getBoundingClientRect();
    const popupWidth = 450;
    const screenWidth = window.innerWidth;
    
    console.log('Click position:', rect.left, 'Screen width:', screenWidth, 'Popup width:', popupWidth);
    
    // Force popup to the left of the cursor
    let leftPosition = rect.left - popupWidth - 20; // 20px gap from cursor
    
    console.log('Calculated left position:', leftPosition);
    
    // Only if popup would go off-screen to the left, then position it to the right
    if (leftPosition < 20) {
        leftPosition = rect.right + 20;
        console.log('Repositioned to right:', leftPosition);
    }
    
    // Ensure popup doesn't go off-screen to the right
    if (leftPosition + popupWidth > screenWidth - 20) {
        leftPosition = screenWidth - popupWidth - 20;
        console.log('Adjusted for right edge:', leftPosition);
    }
    
    // Final safety check
    leftPosition = Math.max(20, leftPosition);
    
    console.log('Final position:', leftPosition);
    
    popup.style.top = rect.top + 'px';
    popup.style.left = leftPosition + 'px';
    
    popup.classList.add('active');
}

function closeFilesPopup() {
    const popup = document.getElementById('files-popup');
    popup.classList.remove('active');
}

function calculateDaysLeft(deadline) {
    const now = new Date();
    const deadlineDate = new Date(deadline);
    const diffTime = deadlineDate - now;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays > 0 ? diffDays : 0;
}

function calculateDeadlineProgress(deadline) {
    const now = new Date();
    const deadlineDate = new Date(deadline);
    const diffTime = deadlineDate - now;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    if (diffDays <= 0) return 0;
    if (diffDays >= 30) return 100;
    return Math.round((diffDays / 30) * 100);
}

function getDeadlineColor(deadline) {
    const daysLeft = calculateDaysLeft(deadline);
    if (daysLeft <= 3) return '#FF5252';
    if (daysLeft <= 7) return '#FFC107';
    return '#4CAF50';
}

function openCommentModal(taskId) {
    currentTaskId = taskId;
    if (elements.commentModal) {
        elements.commentModal.classList.add('active');
    }
}

function closeCommentModal() {
    if (elements.commentModal) {
        elements.commentModal.classList.remove('active');
        currentTaskId = null;
        document.getElementById('comment-text').value = '';
    }
}

async function submitComment() {
    if (!currentTaskId) {
        alert('No task selected');
        return;
    }
    
    const commentText = document.getElementById('comment-text').value.trim();
    if (!commentText) {
        alert('Please enter a comment');
        return;
    }
    
    try {
        const commentsRef = ref(db, `tasks/${currentTaskId}/comments`);
        const currentUser = await fetchCurrentUserProfile();
        
        const comment = {
            authorId: userId,
            authorName: currentUser.name,
            content: commentText,
            timestamp: new Date().toISOString()
        };
        
        await push(commentsRef, comment);
        closeCommentModal();
        
        // Refresh the timeline
        loadWorkflows();
        
    } catch (error) {
        console.error('Error submitting comment:', error);
        alert('Failed to submit comment. Please try again.');
    }
}

// AI Apps Panel Functions
function toggleAIAppsPanel() {
    const panel = document.getElementById('ai-apps-panel');
    const button = document.getElementById('ai-apps-button');
    
    if (panel.classList.contains('active')) {
        closeAIAppsPanel();
    } else {
        openAIAppsPanel();
    }
}

function openAIAppsPanel() {
    const panel = document.getElementById('ai-apps-panel');
    const button = document.getElementById('ai-apps-button');
    
    panel.classList.add('active');
    button.classList.add('active');
}

function closeAIAppsPanel() {
    const panel = document.getElementById('ai-apps-panel');
    const button = document.getElementById('ai-apps-button');
    
    panel.classList.remove('active');
    button.classList.remove('active');
}

function openAIApp(appType) {
    // Close the panel first
    closeAIAppsPanel();
    
    // Handle different AI app types
    switch(appType) {
        case 'image-generator':
            alert('Image Generator - Coming Soon!');
            break;
        case 'video-generator':
            alert('Video Generator - Coming Soon!');
            break;
        case 'code-assistant':
            alert('Code Assistant - Coming Soon!');
            break;
        case 'data-analyzer':
            alert('Data Analyzer - Coming Soon!');
            break;
        case 'text-writer':
            alert('Text Writer - Coming Soon!');
            break;
        case 'translator':
            alert('Translator - Coming Soon!');
            break;
        default:
            alert('AI Tool - Coming Soon!');
    }
}

// Assigned Tasks Functions
async function loadAssignedTasks() {
    try {
        const assignedTasksRef = ref(db, `students/${userId}/assignedTasks`);
        const snapshot = await get(assignedTasksRef);
        
        elements.assignedTasksList.innerHTML = '';
        const assignedTasksSection = document.getElementById('assigned-tasks-section');
        
        if (snapshot.exists()) {
            const tasks = snapshot.val();
            let hasPendingTasks = false;
            console.log('Loaded assigned tasks:', tasks); // DEBUG

            // Fetch professional data to get photos
            const professionals = await fetchProfessionalData();

            // Filter and collect pending tasks
            const pendingTasks = [];
            for (const taskId in tasks) {
                const task = tasks[taskId];
                if (task.status === 'pending') {
                    pendingTasks.push({ taskId, ...task });
                }
            }

            // Sort pending tasks by deadline (nearest first)
            pendingTasks.sort((a, b) => {
                const deadlineA = new Date(a.deadline);
                const deadlineB = new Date(b.deadline);
                return deadlineA - deadlineB;
            });

            // Create cards for sorted tasks
            pendingTasks.forEach(({ taskId, ...task }) => {
                hasPendingTasks = true;
                // Find professional photo
                const professional = professionals.find(p => p.id === task.professionalId);
                const professionalPhoto = professional?.personal?.profilePic || '../assets/avatar/1.png';
                
                const card = createAssignedTaskCard(task, taskId, professionalPhoto);
                if (card) elements.assignedTasksList.appendChild(card);
            });

            if (hasPendingTasks) {
                assignedTasksSection.style.display = 'block';
            } else {
                assignedTasksSection.style.display = 'none';
            }
        } else {
            assignedTasksSection.style.display = 'none';
        }
    } catch (error) {
        console.error('Error loading assigned tasks:', error);
        document.getElementById('assigned-tasks-section').style.display = 'none';
    }
}

function createAssignedTaskCard(task, taskId, professionalPhoto) {
    if (task.status !== 'pending') return null;
    const card = document.createElement('div');
    card.className = `assigned-task-card pending`;
    card.dataset.taskId = taskId;
    const daysLeft = calculateDaysLeft(task.deadline);
    
    console.log('Rendering card for task:', task.title, 'Photo:', professionalPhoto); // DEBUG
    card.innerHTML = `
        <div class="assigned-task-content">
            <div class="assigned-task-main">
                <div class="assigned-task-header">
                    <h4 class="assigned-task-title">${task.title}</h4>
                    <div class="assigned-task-badge">
                        <i class="fas fa-clock"></i>
                        ${daysLeft}d
                    </div>
                </div>
                <p class="assigned-task-description">${task.description || 'No description provided'}</p>
                <div class="assigned-task-meta">
                    <span class="assigned-task-category">${task.category.replace('-', ' ')}</span>
                    <div class="assigned-task-employer">
                        <img src="${professionalPhoto}" alt="${task.professionalName}" onerror="this.src='../assets/avatar/1.png'">
                        <span>${task.professionalName}</span>
                    </div>
                </div>
            </div>
            <div class="assigned-task-actions">
                <button class="assigned-task-btn accept-btn" onclick="acceptTask('${taskId}')">
                    <i class="fas fa-check"></i>
                    Accept
                </button>
                <button class="assigned-task-btn reject-btn" onclick="rejectTask('${taskId}')">
                    <i class="fas fa-times"></i>
                    Reject
                </button>
            </div>
        </div>
    `;
    return card;
}

async function acceptTask(taskId) {
    try {
        // Store the task ID for the acceptance process
        window.currentAcceptingTaskId = taskId;
        
        // Show the task acceptance modal
        document.getElementById('task-acceptance-modal').classList.add('active');
        
        // Clear previous form data
        document.getElementById('task-plan').value = '';
        document.getElementById('task-questions').value = '';
        document.getElementById('task-timeline').value = '';
        
    } catch (error) {
        console.error('Error showing task acceptance modal:', error);
        alert('Failed to show acceptance form.');
    }
}

async function confirmAcceptTask() {
    try {
        const taskId = window.currentAcceptingTaskId;
        if (!taskId) {
            alert('No task selected for acceptance.');
            return;
        }

        // Get form data
        const plan = document.getElementById('task-plan').value.trim();
        const questions = document.getElementById('task-questions').value.trim();
        const timeline = document.getElementById('task-timeline').value.trim();

        // Validate that at least plan is provided
        if (!plan) {
            alert('Please provide your plan and approach for the task.');
            return;
        }

        // Get the task details first
        const taskSnapshot = await get(ref(db, `students/${userId}/assignedTasks/${taskId}`));
        const task = taskSnapshot.val();
        
        if (!task) {
            alert('Task not found.');
            return;
        }

        // Update task status to accepted
        await update(ref(db, `students/${userId}/assignedTasks/${taskId}`), {
            status: 'accepted',
            acceptedAt: new Date().toISOString()
        });
        
        // Add employer as connection if not already connected
        const studentConnectionRef = ref(db, `users/${userId}/connections/${task.professionalId}`);
        const professionalConnectionRef = ref(db, `users/${task.professionalId}/connections/${userId}`);
        
        const connectionSnapshot = await get(studentConnectionRef);
        if (!connectionSnapshot.exists()) {
            await set(studentConnectionRef, { status: "connected" });
            await set(professionalConnectionRef, { status: "connected" });
        }
        
        // Add to workflow tasks (this creates the task in the main task section)
        await set(ref(db, `tasks/${taskId}`), {
            ...task,
            studentId: userId,
            professionalId: task.professionalId,
            status: 'in-progress',
            createdAt: new Date().toISOString(),
            title: task.title,
            description: task.description,
            category: task.category,
            deadline: task.deadline,
            files: task.files || {}
        });

        // Create initial comment with plan, questions, and timeline
        const currentUser = await fetchCurrentUserProfile();
        const initialComment = {
            authorId: userId,
            authorName: currentUser.name,
            content: `**Task Acceptance & Initial Plan**\n\n**My Plan & Approach:**\n${plan}\n\n${questions ? `**Questions & Clarifications:**\n${questions}\n\n` : ''}${timeline ? `**Timeline & Milestones:**\n${timeline}` : ''}`,
            timestamp: new Date().toISOString(),
            type: 'acceptance-comment'
        };

        // Add the initial comment to the task timeline
        const commentsRef = ref(db, `tasks/${taskId}/comments`);
        await push(commentsRef, initialComment);
        
        // Close the acceptance modal
        closeTaskAcceptanceModal();
        
        // Automatically select the professional to show the task in workflow
        await selectProfessional(task.professionalId);
        
        // Show success message
        showSuccessModal('Task Accepted!', 'The task has been accepted and added to your workflow. Your initial plan has been shared with the employer.');
        
        // Reload assigned tasks and connections
        loadAssignedTasks();
        loadConnections();
        
    } catch (error) {
        console.error('Error accepting task:', error);
        alert('Failed to accept task. Please try again.');
    }
}

function closeTaskAcceptanceModal() {
    document.getElementById('task-acceptance-modal').classList.remove('active');
    window.currentAcceptingTaskId = null;
}

async function rejectTask(taskId) {
    try {
        // Show styled confirmation dialog
        confirmAction('confirmRejectTask', 'Reject Task', 'Are you sure you want to reject this task? This action cannot be undone.', { taskId });
    } catch (error) {
        console.error('Error showing reject confirmation:', error);
        alert('Failed to show confirmation dialog.');
    }
}

async function confirmRejectTask({ taskId }) {
    try {
        // Get the task details first
        const taskSnapshot = await get(ref(db, `students/${userId}/assignedTasks/${taskId}`));
        const task = taskSnapshot.val();
        
        if (!task) {
            alert('Task not found.');
            return;
        }

        // Remove the task from assigned tasks
        await remove(ref(db, `students/${userId}/assignedTasks/${taskId}`));
        
        // Update the professional's task assignments
        const professionalTaskRef = ref(db, `professionals/${task.professionalId}/tasks/${taskId}`);
        const professionalTaskSnapshot = await get(professionalTaskRef);
        
        if (professionalTaskSnapshot.exists()) {
            const professionalTask = professionalTaskSnapshot.val();
            
            // Remove current student from primary or waitlist
            if (professionalTask.primaryStudents && professionalTask.primaryStudents[userId]) {
                await remove(ref(db, `professionals/${task.professionalId}/tasks/${taskId}/primaryStudents/${userId}`));
            }
            if (professionalTask.waitlistStudents && professionalTask.waitlistStudents[userId]) {
                await remove(ref(db, `professionals/${task.professionalId}/tasks/${taskId}/waitlistStudents/${userId}`));
            }
            
            // Move next waitlisted student to primary if available
            if (professionalTask.waitlistStudents && Object.keys(professionalTask.waitlistStudents).length > 0) {
                const waitlistStudentIds = Object.keys(professionalTask.waitlistStudents);
                const nextStudentId = waitlistStudentIds[0];
                const nextStudent = professionalTask.waitlistStudents[nextStudentId];
                
                // Move to primary
                await set(ref(db, `professionals/${task.professionalId}/tasks/${taskId}/primaryStudents/${nextStudentId}`), nextStudent);
                
                // Remove from waitlist
                await remove(ref(db, `professionals/${task.professionalId}/tasks/${taskId}/waitlistStudents/${nextStudentId}`));
                
                // Update the student's assigned task status to pending
                await set(ref(db, `students/${nextStudentId}/assignedTasks/${taskId}`), {
                    ...task,
                    status: 'pending',
                    assignedAt: new Date().toISOString()
                });
            }
        }
        
        // Show success message
        showSuccessModal('Task Rejected!', 'The task has been rejected and removed from your list.');
        
        // Reload assigned tasks
        loadAssignedTasks();
        
    } catch (error) {
        console.error('Error rejecting task:', error);
        alert('Failed to reject task. Please try again.');
    }
}

async function viewAssignedTask(taskId) {
    try {
        const taskSnapshot = await get(ref(db, `students/${userId}/assignedTasks/${taskId}`));
        const task = taskSnapshot.val();
        
        if (!task) {
            alert('Task not found.');
            return;
        }
        
        const daysLeft = calculateDaysLeft(task.deadline);
        
        elements.assignedTaskTitle.textContent = task.title;
        elements.assignedTaskBody.innerHTML = `
            <div class="task-details">
                <div class="detail-section">
                    <h4>Task Information</h4>
                    <div class="detail-grid">
                        <div class="detail-item">
                            <strong>Title:</strong> ${task.title}
                        </div>
                        <div class="detail-item">
                            <strong>Description:</strong> ${task.description}
                        </div>
                        <div class="detail-item">
                            <strong>Category:</strong> ${task.category.replace('-', ' ')}
                        </div>
                        <div class="detail-item">
                            <strong>Deadline:</strong> ${new Date(task.deadline).toLocaleDateString()}
                        </div>
                        <div class="detail-item">
                            <strong>Days Left:</strong> ${daysLeft} days
                        </div>
                        <div class="detail-item">
                            <strong>Status:</strong> ${task.status}
                        </div>
                    </div>
                </div>
                
                <div class="detail-section">
                    <h4>Professional Information</h4>
                    <div class="professional-detail">
                        <div class="professional-name">${task.professionalName}</div>
                        <div class="assigned-date">Assigned: ${new Date(task.assignedAt).toLocaleDateString()}</div>
                    </div>
                </div>
                
                ${task.files && Object.keys(task.files).length > 0 ? `
                    <div class="detail-section">
                        <h4>Attached Files (${Object.keys(task.files).length})</h4>
                        <div class="task-files">
                            ${Object.values(task.files).map(file => `
                                <a href="${file.url}" download="${file.name}" class="task-file">
                                    <i class="fas fa-file"></i>
                                    <span>${file.name}</span>
                                </a>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            </div>
        `;
        
        // Set up action buttons based on task status
        if (task.status === 'pending') {
            elements.assignedTaskActions.innerHTML = `
                <button class="cancel-btn" onclick="closeAssignedTaskModal()">Cancel</button>
                <button class="accept-btn" onclick="acceptTask('${taskId}')">Accept Task</button>
                <button class="reject-btn" onclick="rejectTask('${taskId}')">Reject Task</button>
            `;
        } else {
            elements.assignedTaskActions.innerHTML = `
                <button class="cancel-btn" onclick="closeAssignedTaskModal()">Close</button>
            `;
        }
        
        elements.assignedTaskModal.classList.add('active');
        
    } catch (error) {
        console.error('Error loading task details:', error);
        alert('Failed to load task details.');
    }
}

function closeAssignedTaskModal() {
    elements.assignedTaskModal.classList.remove('active');
}

function showSuccessModal(title, message) {
    elements.successTitle.textContent = title;
    elements.successMessage.innerHTML = `
        <div class="success-content">
            <i class="fas fa-check-circle"></i>
            <h4>${title}</h4>
            <p>${message}</p>
        </div>
    `;
    elements.successModal.classList.add('active');
}

function closeSuccessModal() {
    elements.successModal.classList.remove('active');
}

window.sendMessage = sendMessage;
window.sendFileMessage = sendFileMessage;
window.openTaskPopup = openTaskPopup;
window.selectProfessional = selectProfessional;
window.acceptRequest = acceptRequest;
window.deleteRequest = deleteRequest;
window.deleteConnection = deleteConnection;
window.deleteTask = deleteTask;
window.deleteMessage = deleteMessage;
window.confirmAction = confirmAction;
window.closeConfirmation = closeConfirmation;
window.toggleReaction = toggleReaction;
window.hideChat = hideChat;
window.showChat = showChat;
window.openFileViewer = openFileViewer;
window.closeFileViewer = closeFileViewer;
window.openSubmissionModal = openSubmissionModal;
window.closeSubmissionModal = closeSubmissionModal;
window.removeSubmissionFile = removeSubmissionFile;
window.submitWork = submitWork;
window.toggleFilesPopup = toggleFilesPopup;
window.closeFilesPopup = closeFilesPopup;
window.openCommentModal = openCommentModal;
window.closeCommentModal = closeCommentModal;
window.submitComment = submitComment;
window.toggleAIAppsPanel = toggleAIAppsPanel;
window.openAIAppsPanel = openAIAppsPanel;
window.closeAIAppsPanel = closeAIAppsPanel;
window.openAIApp = openAIApp;

// Assigned Tasks Window Functions
window.acceptTask = acceptTask;
window.rejectTask = rejectTask;
window.confirmRejectTask = confirmRejectTask;
window.viewAssignedTask = viewAssignedTask;
window.closeAssignedTaskModal = closeAssignedTaskModal;
window.closeSuccessModal = closeSuccessModal;
window.confirmAcceptTask = confirmAcceptTask;
window.closeTaskAcceptanceModal = closeTaskAcceptanceModal;

init();

</script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93b153f5ba4ebd25',t:'MTc0NjQ1OTUzOC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>