<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taska Elite - Student Tasks</title>
    <link rel="stylesheet" href="css/tasks.css">
    <link rel="stylesheet" href="../css/reset.css">
    <link rel="stylesheet" href="../css/global.css">
    <link rel="stylesheet" href="../css/dashboard.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="mobile-message">
        <p>Please use a desktop for a better experience.</p>
    </div>
    <nav class="navbar">
        <a href="../index.html">
            <div class="logo">Taska Elite</div>
          </a>
        <ul class="nav-menu">
            <li><a href="tasks.html" class="active">Tasks</a></li>
            <li><a href="profile.html">Account</a></li>
        </ul>
        <div class="hamburger">‚ò∞</div>
    </nav>

    <div class="dashboard-content">
        <div class="sidebar-left">
            <h3>Connected Professionals</h3>
            <div id="connections-list" class="skeleton-loading">
                <div class="skeleton-user-item"></div>
                <div class="skeleton-user-item"></div>
                <div class="skeleton-user-item"></div>
            </div>
            <div class="pending-requests" style="display: none;">
                <h3>Pending Requests</h3>
                <div id="pending-requests-list"></div>
            </div>
        </div>
        <div class="chat-area" id="chat-area">
            <div class="chat-header skeleton-loading" id="chat-header">
                <div class="skeleton-header"></div>
            </div>
            <div class="messages skeleton-loading" id="chat-messages">
                <div class="skeleton-message"></div>
                <div class="skeleton-message"></div>
            </div>
            <div class="chat-input">
                <div class="input-container">
                    <div class="upload-progress" id="upload-progress">
                        <div class="upload-progress-bar" id="upload-progress-bar"></div>
                    </div>
                    <textarea id="chat-input" placeholder="Type a message..." rows="1"></textarea>
                    <i class="fas fa-at mention-icon" id="mention-icon"></i>
                    <label for="file-input" class="file-input-label"><i class="fas fa-paperclip"></i></label>
                    <input type="file" id="file-input" class="file-input">
                    <div class="task-dropdown" id="task-dropdown"></div>
                </div>
                <button onclick="sendMessage()"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
        <div class="sidebar-right" id="workflow-area">
            <h3>Tasks</h3>
            <div id="workflow-list" class="skeleton-loading">
                <div class="skeleton-task-item"></div>
                <div class="skeleton-task-item"></div>
            </div>
            <div class="completed-tasks">
                <h4 onclick="toggleCompletedTasks()">Completed Tasks <i class="fas fa-chevron-down toggle-icon"></i></h4>
                <div class="completed-tasks-list" id="completed-tasks-list"></div>
            </div>
        </div>
    </div>

    <div class="confirmation-dialog" id="confirmation-dialog">
        <div class="dialog-box">
            <h3 id="dialog-title"></h3>
            <p id="dialog-message"></p>
            <div class="dialog-actions">
                <button class="cancel" onclick="closeConfirmation()">Cancel</button>
                <button id="confirm-button" class="confirm"></button>
            </div>
        </div>
    </div>

    <audio id="message-ding" src="../assets/ding.mp3"></audio>

    <script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
import { getDatabase, ref, get, push, set, onValue, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";
import { getAuth } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
import { getStorage, ref as storageRef, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-storage.js";

const firebaseConfig = {
    apiKey: "AIzaSyDZIDlEtaNRxODoFhRw0xF2yYFBqqBexqo",
    authDomain: "taska-45011.firebaseapp.com",
    databaseURL: "https://taska-45011-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "taska-45011",
    storageBucket: "gs://taska-45011.firebasestorage.app",
    messagingSenderId: "205487498813",
    appId: "1:205487498813:web:0de2c9eab567482781ec54",
    measurementId: "G-G0G1F6GQ9B"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);
const storage = getStorage(app);

let userId = null;
let selectedProfessionalId = null;
let professionalData = null;
let currentUserProfile = null;
let uploadedTaskFiles = [];
let isDataLoaded = { connections: false, chats: false, tasks: false };

const elements = {
    connectionsList: document.getElementById('connections-list'),
    pendingRequestsList: document.getElementById('pending-requests-list'),
    chatArea: document.getElementById('chat-area'),
    chatHeader: document.getElementById('chat-header'),
    chatMessages: document.getElementById('chat-messages'),
    chatInput: document.getElementById('chat-input'),
    workflowArea: document.getElementById('workflow-area'),
    workflowList: document.getElementById('workflow-list'),
    completedTasksList: document.getElementById('completed-tasks-list'),
    confirmationDialog: document.getElementById('confirmation-dialog'),
    dialogTitle: document.getElementById('dialog-title'),
    dialogMessage: document.getElementById('dialog-message'),
    confirmButton: document.getElementById('confirm-button'),
    messageDing: document.getElementById('message-ding'),
    fileInput: document.getElementById('file-input'),
    uploadProgress: document.getElementById('upload-progress'),
    uploadProgressBar: document.getElementById('upload-progress-bar'),
    mentionIcon: document.getElementById('mention-icon'),
    taskDropdown: document.getElementById('task-dropdown')
};

async function fetchProfessionalData() {
    if (professionalData) return professionalData;
    try {
        const snapshot = await get(ref(db, 'professionalslist'));
        const data = snapshot.val() || {};
        professionalData = Object.keys(data).map(id => ({
            id,
            ...data[id],
            personal: data[id].personal || {},
            education: data[id].education || {},
            skills: data[id].skills || '',
            profiles: data[id].profiles || {},
            portfolio: data[id].portfolio || []
        }));
        return professionalData;
    } catch (error) {
        console.error('Error fetching professional data:', error);
        return [];
    }
}

async function fetchCurrentUserProfile() {
    if (currentUserProfile) return currentUserProfile;
    try {
        const snapshot = await get(ref(db, `studentslist/${userId}`));
        const user = snapshot.val() || {};
        currentUserProfile = {
            name: user.personal?.name || "Unnamed",
            profilePic: user.personal?.profilePic || "../assets/avatar/1.png"
        };
        return currentUserProfile;
    } catch (error) {
        console.error('Error fetching current user profile:', error);
        return { name: "Unnamed", profilePic: "../assets/avatar/1.png" };
    }
}

function confirmAction(action, title, message, actionParams = {}) {
    elements.dialogTitle.textContent = title;
    elements.dialogMessage.textContent = message;
    elements.confirmationDialog.classList.add('active');
    elements.confirmButton.textContent = title.includes('Delete') ? 'Delete' : 'Confirm';
    elements.confirmButton.className = title.includes('Delete') ? 'delete' : 'confirm';
    elements.confirmButton.onclick = () => {
        window[action](actionParams);
        closeConfirmation();
    };
}

function closeConfirmation() {
    elements.confirmationDialog.classList.remove('active');
}

function getFileIconClass(type) {
    if (type.includes('pdf')) return 'fas fa-file-pdf';
    if (type.includes('image')) return 'fas fa-file-image';
    if (type.includes('video')) return 'fas fa-file-video';
    if (type.includes('excel') || type.includes('spreadsheet')) return 'fas fa-file-excel';
    if (type.includes('word') || type.includes('doc')) return 'fas fa-file-word';
    return 'fas fa-file';
}

function getFileIconColor(type) {
    if (type.includes('pdf')) return '#FF5252';
    if (type.includes('image')) return '#4CAF50';
    if (type.includes('video')) return '#2196F3';
    if (type.includes('excel') || type.includes('spreadsheet')) return '#2E7D32';
    if (type.includes('word') || type.includes('doc')) return '#1976D2';
    return '#6c757d';
}

function checkAllDataLoaded() {
    if (isDataLoaded.connections && isDataLoaded.chats && isDataLoaded.tasks) {
        elements.connectionsList.classList.remove('skeleton-loading');
        elements.chatArea.classList.remove('skeleton-loading');
        elements.chatHeader.classList.remove('skeleton-loading');
        elements.chatMessages.classList.remove('skeleton-loading');
        elements.workflowList.classList.remove('skeleton-loading');
    }
}

async function init() {
    document.addEventListener('DOMContentLoaded', async () => {
        await fetchProfessionalData();
        setupEventListeners();
        auth.onAuthStateChanged(user => {
            if (user) {
                userId = user.uid;
                fetchCurrentUserProfile().then(() => {
                    loadConnections();
                    loadPendingRequests();
                    loadCompletedTasks();
                });
            } else {
                console.error("User not authenticated");
                window.location.href = "../index.html";
            }
        });
    });
}

function setupEventListeners() {
    const hamburger = document.querySelector('.navbar .hamburger');
    const navMenu = document.querySelector('.navbar .nav-menu');
    if (hamburger && navMenu) {
        hamburger.addEventListener('click', () => navMenu.classList.toggle('active'));
    }

    document.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.closest('.user-item') && !target.closest('.pending-item')) {
            const professionalId = target.closest('.user-item').dataset.professionalId;
            selectProfessional(professionalId);
        }
        if (target.matches('.accept-btn')) {
            const professionalId = target.closest('.pending-item').dataset.professionalId;
            confirmAction('acceptRequest', 'Accept Request', 'Are you sure you want to accept this connection request?', { professionalId });
        }
        if (target.matches('.delete Î∂ïn')) {
            const professionalId = target.closest('.pending-item').dataset.professionalId;
            confirmAction('deleteRequest', 'Delete Request', 'Are you sure you want to delete this connection request?', { professionalId });
        }
        if (target.matches('.task-menu-icon')) {
            const dropdown = target.closest('.task-menu').querySelector('.task-menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (target.matches('.task-menu-dropdown button')) {
            const action = target.dataset.action;
            const taskId = target.closest('.workflow-item').dataset.taskId;
            if (action === 'deleteTask') {
                confirmAction('deleteTask', 'Delete Task', 'Are you sure you want to delete this task?', { taskId });
            }
        }
        if (target.matches('.reaction-icon')) {
            const messageId = target.closest('.message').dataset.messageId;
            const reaction = target.dataset.reaction;
            toggleReaction(messageId, reaction);
        }
        if (target.matches('.message-menu-icon')) {
            const dropdown = target.closest('.message-menu').querySelector('.message-menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (target.matches('.message-menu-dropdown button')) {
            const action = target.dataset.action;
            const messageId = target.closest('.message').dataset.messageId;
            if (action === 'deleteMessage') {
                confirmAction('deleteMessage', 'Delete Message', 'Are you sure you want to delete this message?', { messageId });
            }
        }
        if (target.matches('.chat-header .menu-icon')) {
            const dropdown = target.closest('.menu').querySelector('.menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (target.matches('.chat-header .menu-dropdown button')) {
            const action = target.dataset.action;
            if (action === 'deleteConnection') {
                confirmAction('deleteConnection', 'Delete Connection', 'Are you sure you want to delete this connection?', { professionalId: selectedProfessionalId });
            }
        }
        if (target.matches('.mention-icon')) {
            elements.taskDropdown.classList.toggle('active');
            if (elements.taskDropdown.classList.contains('active')) {
                await populateTaskDropdown();
            }
        }
        if (target.matches('.task-dropdown-item')) {
            const taskTitle = target.textContent;
            insertMention(taskTitle);
        }
    });

    if (elements.workflowList) {
        elements.workflowList.addEventListener('change', (e) => {
            if (e.target.matches('.status-select')) {
                const taskId = e.target.closest('.workflow-item').dataset.taskId;
                const newStatus = e.target.value;
                confirmAction('updateStatus', `Update Task Status`, `Are you sure you want to change the task status to "${newStatus}"?`, { taskId, status: newStatus });
            }
        });
    }

    if (elements.chatInput) {
        elements.chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        elements.chatInput.addEventListener('input', async () => {
            elements.chatInput.style.height = 'auto';
            elements.chatInput.style.height = `${Math.min(elements.chatInput.scrollHeight, 100)}px`;
            const value = elements.chatInput.value;
            if (value.endsWith('@') && !elements.taskDropdown.classList.contains('active')) {
                elements.taskDropdown.classList.add('active');
                await populateTaskDropdown();
            }
        });
        elements.chatInput.addEventListener('keydown', (e) => {
            if (elements.taskDropdown.classList.contains('active')) {
                const items = elements.taskDropdown.querySelectorAll('.task-dropdown-item');
                let selectedIndex = -1;
                items.forEach((item, index) => {
                    if (item.classList.contains('selected')) selectedIndex = index;
                });
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    items.forEach(item => item.classList.remove('selected'));
                    items[selectedIndex].classList.add('selected');
                    items[selectedIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, 0);
                    items.forEach(item => item.classList.remove('selected'));
                    items[selectedIndex].classList.add('selected');
                    items[selectedIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    const taskTitle = items[selectedIndex].textContent;
                    insertMention(taskTitle);
                } else if (e.key === 'Escape') {
                    elements.taskDropdown.classList.remove('active');
                }
            }
        });
    }

    if (elements.fileInput) {
        elements.fileInput.addEventListener('change', async () => {
            if (elements.fileInput.files.length > 0) {
                await sendFileMessage(elements.fileInput.files[0]);
                elements.fileInput.value = '';
            }
        });
    }

    document.addEventListener('click', (e) => {
        if (!e.target.closest('.task-menu')) {
            document.querySelectorAll('.task-menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        if (!e.target.closest('.message-menu')) {
            document.querySelectorAll('.message-menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        if (!e.target.closest('.chat-header .menu')) {
            document.querySelectorAll('.chat-header .menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        if (!e.target.closest('.input-container')) {
            elements.taskDropdown.classList.remove('active');
        }
    });
}

async function loadConnections() {
    if (!elements.connectionsList) return;
    try {
        const connectionsRef = ref(db, `users/${userId}/connections`);
        const snapshot = await get(connectionsRef);
        elements.connectionsList.innerHTML = '';
        if (snapshot.exists()) {
            const connections = snapshot.val();
            let hasConnections = false;
            const professionals = await fetchProfessionalData();
            for (const professionalId in connections) {
                if (connections[professionalId].status === "connected") {
                    hasConnections = true;
                    const professional = professionals.find(p => p.id === professionalId) || {};
                    const userName = professional.personal?.name || "Unnamed";
                    const profilePic = professional.personal?.profilePic || "../assets/avatar/1.png";
                    const chatId = [userId, professionalId].sort().join("+");
                    const chatRef = ref(db, `chats/${chatId}/messages`);
                    let lastMessage = "No messages yet";
                    let hasUnread = false;
                    const chatSnapshot = await get(chatRef);
                    if (chatSnapshot.exists()) {
                        const messages = Object.values(chatSnapshot.val());
                        const lastMsg = messages[messages.length - 1];
                        lastMessage = lastMsg.file ? `[File] ${lastMsg.file.name}` : lastMsg.content || "No messages yet";
                        hasUnread = messages.some(msg => msg.senderId !== userId && !msg.read);
                    }
                    const userItem = document.createElement('div');
                    userItem.className = 'user-item';
                    userItem.dataset.professionalId = professionalId;
                    userItem.innerHTML = `
                        <img src="${profilePic}" alt="${userName}" class="profile-pic">
                        <div class="user-info">
                            <div class="name">${userName}</div>
                            <div class="last-message">${lastMessage}</div>
                        </div>
                        ${hasUnread ? '<div class="unread-dot"></div>' : ''}
                    `;
                    elements.connectionsList.appendChild(userItem);
                }
            }
            if (!hasConnections) {
                elements.connectionsList.innerHTML = '<p>No connected professionals found.</p>';
            }
        } else {
            elements.connectionsList.innerHTML = '<p>No connected professionals found.</p>';
        }
        isDataLoaded.connections = true;
        checkAllDataLoaded();
    } catch (error) {
        console.error("Error loading connections:", error);
        elements.connectionsList.innerHTML = '<p>Error loading connections.</p>';
        isDataLoaded.connections = true;
        checkAllDataLoaded();
    }
}

async function loadPendingRequests() {
    if (!elements.pendingRequestsList) return;
    try {
        const connectionsRef = ref(db, `users/${userId}/connections`);
        const snapshot = await get(connectionsRef);
        elements.pendingRequestsList.innerHTML = '';
        const pendingRequestsSection = document.querySelector('.pending-requests');
        if (snapshot.exists()) {
            const connections = snapshot.val();
            let hasPending = false;
            const professionals = await fetchProfessionalData();
            for (const professionalId in connections) {
                if (connections[professionalId].status === "pending") {
                    hasPending = true;
                    const professional = professionals.find(p => p.id === professionalId) || {};
                    const userName = professional.personal?.name || "Unnamed";
                    const profilePic = professional.personal?.profilePic || "../assets/avatar/1.png";
                    const pendingItem = document.createElement('div');
                    pendingItem.className = 'pending-item user-item';
                    pendingItem.dataset.professionalId = professionalId;
                    pendingItem.innerHTML = `
                        <div class="user-info">
                            <img src="${profilePic}" alt="${userName}" class="profile-pic">
                            <div class="name">${userName}</div>
                        </div>
                        <div class="actions">
                            <button class="accept-btn">Accept</button>
                            <button class="delete-btn">Delete</button>
                        </div>
                    `;
                    elements.pendingRequestsList.appendChild(pendingItem);
                }
            }
            pendingRequestsSection.style.display = hasPending ? 'block' : 'none';
        } else {
            pendingRequestsSection.style.display = 'none';
        }
    } catch (error) {
        console.error("Error loading pending requests:", error);
        elements.pendingRequestsList.innerHTML = '<p>Error loading pending requests.</p>';
        document.querySelector('.pending-requests').style.display = 'none';
    }
}

async function acceptRequest({ professionalId }) {
    try {
        const studentConnectionRef = ref(db, `users/${userId}/connections/${professionalId}`);
        const professionalConnectionRef = ref(db, `users/${professionalId}/connections/${userId}`);
        await update(studentConnectionRef, { status: "connected" });
        await update(professionalConnectionRef, { status: "connected" });
        professionalData = null; // Clear cache
        await loadConnections();
        await loadPendingRequests();
    } catch (error) {
        console.error("Error accepting request:", error);
        alert("Failed to accept request.");
    }
}

async function deleteRequest({ professionalId }) {
    try {
        const studentConnectionRef = ref(db, `users/${userId}/connections/${professionalId}`);
        const professionalConnectionRef = ref(db, `users/${professionalId}/connections/${userId}`);
        await remove(studentConnectionRef);
        await remove(professionalConnectionRef);
        professionalData = null; // Clear cache to refresh professional data
        loadConnections();
        loadPendingRequests();
    } catch (error) {
        console.error("Error deleting request:", error);
        alert("Failed to delete request.");
    }
}

async function deleteConnection({ professionalId }) {
    try {
        const studentConnectionRef = ref(db, `users/${userId}/connections/${professionalId}`);
        const professionalConnectionRef = ref(db, `users/${professionalId}/connections/${userId}`);
        await remove(studentConnectionRef);
        await remove(professionalConnectionRef);
        professionalData = null; // Clear cache to refresh professional data
        loadConnections();
        loadPendingRequests();
        elements.chatArea.style.display = 'none';
        elements.workflowArea.style.display = 'none';
        selectedProfessionalId = null;
    } catch (error) {
        console.error("Error deleting connection:", error);
        alert("Failed to delete connection.");
    }
}

async function deleteTask({ taskId }) {
    try {
        const taskRef = ref(db, `tasks/${taskId}`);
        await remove(taskRef);
        loadWorkflows();
        loadCompletedTasks();
    } catch (error) {
        console.error("Error deleting task:", error);
        alert("Failed to delete task.");
    }
}

async function deleteMessage({ messageId }) {
    try {
        const chatId = [userId, selectedProfessionalId].sort().join("+");
        const messageRef = ref(db, `chats/${chatId}/messages/${messageId}`);
        await remove(messageRef);
    } catch (error) {
        console.error("Error deleting message:", error);
        alert("Failed to delete message.");
    }
}

async function selectProfessional(professionalId) {
    selectedProfessionalId = professionalId;
    document.querySelectorAll('.user-item').forEach(item => {
        const isActive = item.dataset.professionalId === professionalId;
        item.classList.toggle('active', isActive);
        const lastMessage = item.querySelector('.last-message');
        if (lastMessage) lastMessage.style.display = isActive ? 'none' : 'block';
        if (isActive) {
            const unreadDot = item.querySelector('.unread-dot');
            if (unreadDot) unreadDot.remove();
        }
    });
    if (elements.chatArea) elements.chatArea.style.display = 'block';
    if (elements.workflowArea) elements.workflowArea.style.display = 'block';
    loadChatHeader();
    loadChat();
    loadWorkflows();
    loadCompletedTasks();
}

async function loadChatHeader() {
    if (!elements.chatHeader) return;
    try {
        const professionals = await fetchProfessionalData();
        const professional = professionals.find(p => p.id === selectedProfessionalId) || {};
        const userName = professional.personal?.name || "Unnamed";
        const userTitle = professional.education?.branch || "";
        const profilePic = professional.personal?.profilePic || "../assets/avatar/1.png";
        elements.chatHeader.innerHTML = `
            <div style="display: flex; align-items: center; gap: 1rem;">
                <img src="${profilePic}" alt="${userName}" class="profile-pic">
                <div>
                    <div class="name">${userName}</div>
                    <div class="title">${userTitle}</div>
                </div>
            </div>
            <div class="menu">
                <i class="fas fa-ellipsis-v menu-icon"></i>
                <div class="menu-dropdown">
                    <button data-action="deleteConnection">Delete Connection</button>
                </div>
            </div>
        `;
    } catch (error) {
        console.error("Error loading chat header:", error);
        elements.chatHeader.innerHTML = `
            <div style="display: flex; align-items: center; gap: 1rem;">
                <img src="../assets/avatar/1.png" alt="Unnamed" class="profile-pic">
                <div>
                    <div class="name">Unnamed</div>
                    <div class="title"></div>
                </div>
            </div>
            <div class="menu">
                <i class="fas fa-ellipsis-v menu-icon"></i>
                <div class="menu-dropdown">
                    <button data-action="deleteConnection">Delete Connection</button>
                </div>
            </div>
        `;
    }
}

function formatMessageDate(timestamp) {
    const now = new Date();
    const messageDate = new Date(timestamp);
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
    const messageDay = new Date(messageDate.getFullYear(), messageDate.getMonth(), messageDate.getDate());
    if (messageDay.getTime() === today.getTime()) {
        return 'Today';
    } else if (messageDay.getTime() === yesterday.getTime()) {
        return 'Yesterday';
    } else {
        return messageDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
}

async function loadChat() {
    if (!elements.chatMessages) return;
    elements.chatMessages.innerHTML = `
        <div class="skeleton-message"></div>
        <div class="skeleton-message"></div>
    `;
    if (selectedProfessionalId) {
        const chatId = [userId, selectedProfessionalId].sort().join("+");
        const chatRef = ref(db, `chats/${chatId}/messages`);
        const currentUser = await fetchCurrentUserProfile();
        onValue(chatRef, async (snapshot) => {
            elements.chatMessages.innerHTML = '';
            if (snapshot.exists()) {
                const messages = Object.entries(snapshot.val())
                    .map(([id, msg]) => ({ id, ...msg }))
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const professionals = await fetchProfessionalData();
                const professional = professionals.find(p => p.id === selectedProfessionalId) || {};
                const tasksRef = ref(db, `tasks`);
                const tasksSnapshot = await get(tasksRef);
                const tasks = tasksSnapshot.exists() ? tasksSnapshot.val() : {};
                let taskTitles = [];
                for (const taskId in tasks) {
                    if (tasks[taskId].studentId === userId && tasks[taskId].professionalId === selectedProfessionalId) {
                        taskTitles.push(tasks[taskId].title);
                    }
                }
                let lastDate = null;
                messages.forEach(msg => {
                    const isSent = msg.senderId === userId;
                    const senderName = isSent ? currentUser.name : (professional.personal?.name || "Unnamed");
                    const profilePic = isSent 
                        ? currentUser.profilePic
                        : professional.personal?.profilePic || "../assets/avatar/1.png";
                    const time = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const date = formatMessageDate(msg.timestamp);
                    if (date !== lastDate) {
                        const dateDivider = document.createElement('div');
                        dateDivider.className = 'date-divider';
                        dateDivider.innerHTML = `<span>${date}</span>`;
                        elements.chatMessages.appendChild(dateDivider);
                        lastDate = date;
                    }
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message ${isSent ? 'sent' : 'received'} ${msg.file ? 'file-message' : ''}`;
                    messageDiv.dataset.messageId = msg.id;
                    let content = msg.content || '';
                    taskTitles.forEach(title => {
                        const regex = new RegExp(`@${title.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')}`, 'g');
                        content = content.replace(regex, `<span class="mention">@${title}</span>`);
                    });
                    let reactionsHTML = '';
                    if (msg.reactions && msg.reactions[userId]) {
                        reactionsHTML = `<span class="reaction">${msg.reactions[userId]}</span>`;
                    }
                    if (msg.file) {
                        const fileSize = msg.file.size ? (msg.file.size / 1024).toFixed(2) + ' KB' : 'Unknown size';
                        messageDiv.innerHTML = `
                            <div class="message-header">
                                <img src="${profilePic}" alt="${senderName}" class="profile-pic">
                                <div class="name">${senderName}</div>
                                <div class="time">${time}</div>
                            </div>
                            <a href="${msg.file.url}" download="${msg.file.name}" target="_blank">
                                <div class="file-info">
                                    <i class="${getFileIconClass(msg.file.type)} file-icon" style="color: ${getFileIconColor(msg.file.type)};"></i>
                                    <div class="file-details">
                                        <div class="file-name">${msg.file.name}</div>
                                        <div class="file-size">${fileSize}</div>
                                    </div>
                                </div>
                            </a>
                            <div class="read-status">${msg.read ? 'Seen' : 'Sent'}</div>
                            <div class="reactions">${reactionsHTML}</div>
                            <div class="reaction-bar">
                                <span class="reaction-icon" data-reaction="ü§ù">ü§ù</span>
                                <span class="reaction-icon" data-reaction="üëç">üëç</span>
                                <span class="reaction-icon" data-reaction="‚ù§Ô∏è">‚ù§Ô∏è</span>
                                <div class="message-menu">
                                    <i class="fas fa-ellipsis-h message-menu-icon"></i>
                                    <div class="message-menu-dropdown">
                                        <button data-action="deleteMessage">Delete Message</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        messageDiv.innerHTML = `
                            <div class="message-header">
                                <img src="${profilePic}" alt="${senderName}" class="profile-pic">
                                <div class="name">${senderName}</div>
                                <div class="time">${time}</div>
                            </div>
                            <div class="content">${content}</div>
                            <div class="read-status">${msg.read ? 'Seen' : 'Sent'}</div>
                            <div class="reactions">${reactionsHTML}</div>
                            <div class="reaction-bar">
                                <span class="reaction-icon" data-reaction="ü§ù">ü§ù</span>
                                <span class="reaction-icon" data-reaction="üëç">üëç</span>
                                <span class="reaction-icon" data-reaction="‚ù§Ô∏è">‚ù§Ô∏è</span>
                                <div class="message-menu">
                                    <i class="fas fa-ellipsis-h message-menu-icon"></i>
                                    <div class="message-menu-dropdown">
                                        <button data-action="deleteMessage">Delete Message</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    elements.chatMessages.appendChild(messageDiv);
                });
                elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
                messages.forEach(msg => {
                    if (msg.senderId !== userId && !msg.read) {
                        update(ref(db, `chats/${chatId}/messages/${msg.id}`), { read: true });
                    }
                });
            } else {
                elements.chatMessages.innerHTML = '<div class="message">No messages yet</div>';
            }
            isDataLoaded.chats = true;
            checkAllDataLoaded();
        });
    }
}

async function toggleReaction(messageId, reaction) {
    try {
        const chatId = [userId, selectedProfessionalId].sort().join("+");
        const messageRef = ref(db, `chats/${professionalId}/messages/${messageId}`);
        const snapshot = await get(messageRef);
        if (snapshot.exists()) {
            const message = snapshot.val();
            const reactions = message.reactions || {};
            if (reactions[userId] === reaction) {
                delete reactions[userId];
            } else {
                reactions[userId] = reaction;
            }
            await update(messageRef, { reactions });
        }
    } catch (error) {
        console.error("Error toggling reaction:", error);
        alert("Failed to toggle reaction.");
    }
}

async function sendMessage() {
    if (!elements.chatInput) return;
    const content = elements.chatInput.value.trim();
    if (!content || !selectedProfessionalId) return;
    const chatId = [userId, selectedProfessionalId].sort().join("+");
    const messageRef = ref(db, `chats/${chatId}/messages`);
    try {
        const currentUser = await fetchCurrentUserProfile();
        const newMessage = {
            senderId: userId,
            senderName: currentUser.name,
            content,
            timestamp: new Date().toISOString(),
            read: false
        };
        await push(messageRef, newMessage);
        elements.chatInput.value = '';
        elements.chatInput.style.height = 'auto';
        elements.taskDropdown.classList.remove('active');
        if (elements.messageDing) {
            elements.messageDing.play().catch(error => console.error("Error playing ding sound:", error));
        }
    } catch (error) {
        console.error("Error sending message:", error);
        alert("Failed to send message.");
    }
}

async function sendFileMessage(file) {
    if (!selectedProfessionalId) return;
    const chatId = [userId, selectedProfessionalId].sort().join("+");
    const messageRef = ref(db, `chats/${chatId}/messages`);
    try {
        const storagePath = `chats/${chatId}/${Date.now()}_${file.name}`;
        const fileRef = storageRef(storage, storagePath);
        const uploadTask = uploadBytesResumable(fileRef, file);

        elements.uploadProgress.classList.add('active');
        elements.uploadProgressBar.style.width = '0%';

        uploadTask.on('state_changed',
            (snapshot) => {
                const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                elements.uploadProgressBar.style.width = `${progress}%`;
            },
            (error) => {
                console.error('Error uploading file:', error);
                elements.uploadProgress.classList.remove('active');
                alert('Failed to upload file.');
            },
            async () => {
                const fileUrl = await getDownloadURL(fileRef);
                const currentUser = await fetchCurrentUserProfile();
                const newMessage = {
                    senderId: userId,
                    senderName: currentUser.name,
                    file: {
                        name: file.name,
                        url: fileUrl,
                        type: file.type,
                        size: file.size
                    },
                    timestamp: new Date().toISOString(),
                    read: false
                };
                await push(messageRef, newMessage);
                elements.uploadProgress.classList.remove('active');
                if (elements.messageDing) {
                    elements.messageDing.play().catch(error => console.error("Error playing ding sound:", error));
                }
            }
        );
    } catch (error) {
        console.error("Error initiating file upload:", error);
        elements.uploadProgress.classList.remove('active');
        alert("Failed to upload file.");
    }
}

async function openTaskPopup(taskId = null) {
    alert('Students cannot create tasks. You can only edit existing tasks assigned to you.');
    return;
}

async function populateTaskDropdown() {
    try {
        const tasksRef = ref(db, `tasks`);
        const snapshot = await get(tasksRef);
        elements.taskDropdown.innerHTML = '';
        if (snapshot.exists()) {
            const tasks = snapshot.val();
            let taskFound = false;
            for (const id in tasks) {
                if (tasks[id].studentId === userId && tasks[id].professionalId === selectedProfessionalId) {
                    taskFound = true;
                    const taskItem = document.createElement('div');
                    taskItem.className = 'task-dropdown-item';
                    taskItem.textContent = tasks[id].title;
                    elements.taskDropdown.appendChild(taskItem);
                }
            }
            if (!taskFound) {
                elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">No tasks available</div>';
            }
        } else {
            elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">No tasks available</div>';
        }
    } catch (error) {
        console.error("Error populating task dropdown:", error);
        elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">Error loading tasks</div>';
    }
}

function insertMention(taskTitle) {
    const currentValue = elements.chatInput.value;
    const cursorPos = elements.chatInput.selectionStart;
    const textBefore = currentValue.substring(0, cursorPos);
    const textAfter = currentValue.substring(cursorPos);
    const lastAtIndex = textBefore.lastIndexOf('@');
    let newValue;
    if (lastAtIndex >= 0 && lastAtIndex === cursorPos - 1) {
        newValue = textBefore + taskTitle + ' ' + textAfter;
    } else {
        newValue = textBefore + '@' + taskTitle + ' ' + textAfter;
    }
    elements.chatInput.value = newValue;
    elements.chatInput.focus();
    const newCursorPos = lastAtIndex >= 0 ? lastAtIndex + taskTitle.length + 2 : cursorPos + taskTitle.length + 2;
    elements.chatInput.setSelectionRange(newCursorPos, newCursorPos);
    elements.taskDropdown.classList.remove('active');
    elements.chatInput.style.height = 'auto';
    elements.chatInput.style.height = `${Math.min(elements.chatInput.scrollHeight, 100)}px`;
}

function loadWorkflows() {
    if (!elements.workflowList) return;
    if (selectedProfessionalId) {
        const tasksRef = ref(db, `tasks`);
        onValue(tasksRef, (snapshot) => {
            elements.workflowList.innerHTML = '';
            let hasTasks = false;
            if (snapshot.exists()) {
                const tasks = snapshot.val();
                for (const taskId in tasks) {
                    const task = tasks[taskId];
                    if (task.studentId === userId && task.professionalId === selectedProfessionalId && task.status !== 'completed') {
                        hasTasks = true;
                        const workflowItem = document.createElement('div');
                        workflowItem.className = 'workflow-item';
                        workflowItem.dataset.taskId = taskId;
                        let fileIcons = '';
                        if (task.files) {
                            fileIcons = Object.values(task.files).map(file => `
                                <a href="${file.url}" download="${file.name}" class="file-icon-container" title="${file.name}">
                                    <i class="${getFileIconClass(file.type)} file-icon" style="color: ${getFileIconColor(file.type)};"></i>
                                </a>
                            `).join('');
                        }
                        workflowItem.innerHTML = `
                            <div class="task-header">
                                <h4>${task.title}</h4>
                                <div class="task-menu">
                                    <i class="fas fa-ellipsis-v task-menu-icon"></i>
                                    <div class="task-menu-dropdown">
                                        <button data-action="deleteTask" class="delete-task-btn">Delete Task</button>
                                    </div>
                                </div>
                            </div>
                            <p>${task.description}</p>
                            <div class="deadline-container">
                                <div class="deadline-slider" style="width: ${calculateDeadlineProgress(task.deadline)}%; background: ${getDeadlineColor(task.deadline)};"></div>
                                <span class="days-left">${calculateDaysLeft(task.deadline)} days left</span>
                            </div>
                            <select class="status-select">
                                <option value="pending" ${task.status === "pending" ? "selected" : ""}>Pending</option>
                                <option value="in progress" ${task.status === "in progress" ? "selected" : ""}>In Progress</option>
                                <option value="completed" ${task.status === "completed" ? "selected" : ""}>Completed</option>
                            </select>
                            <div class="file-icons">${fileIcons}</div>
                        `;
                        elements.workflowList.appendChild(workflowItem);
                    }
                }
            }
            if (!hasTasks) {
                elements.workflowList.innerHTML = '<p>No tasks found.</p>';
            }
            isDataLoaded.tasks = true;
            checkAllDataLoaded();
        });
    }
}

function loadCompletedTasks() {
    if (!elements.completedTasksList) return;
    elements.completedTasksList.innerHTML = '';
    if (selectedProfessionalId) {
        const tasksRef = ref(db, `tasks`);
        onValue(tasksRef, (snapshot) => {
            elements.completedTasksList.innerHTML = '';
            let hasCompletedTasks = false;
            if (snapshot.exists()) {
                const tasks = snapshot.val();
                for (const taskId in tasks) {
                    const task = tasks[taskId];
                    if (task.studentId === userId && task.professionalId === selectedProfessionalId && task.status === 'completed') {
                        hasCompletedTasks = true;
                        const completedItem = document.createElement('div');
                        completedItem.className = 'workflow-item completed';
                        completedItem.dataset.taskId = taskId;
                        let fileIcons = '';
                        if (task.files) {
                            fileIcons = Object.values(task.files).map(file => `
                                <a href="${file.url}" download="${file.name}" class="file-icon-container" title="${file.name}">
                                    <i class="${getFileIconClass(file.type)} file-icon" style="color: ${getFileIconColor(file.type)};"></i>
                                </a>
                            `).join('');
                        }
                        completedItem.innerHTML = `
                            <div class="task-header">
                                <h4>${task.title}</h4>
                                <div class="task-menu">
                                    <i class="fas fa-ellipsis-v task-menu-icon"></i>
                                    <div class="task-menu-dropdown">
                                        <button data-action="deleteTask" class="delete-task-btn">Delete Task</button>
                                    </div>
                                </div>
                            </div>
                            <span class="status-label completed">Completed</span>
                            <p>${task.description}</p>
                            <div class="file-icons">${fileIcons}</div>
                        `;
                        elements.completedTasksList.appendChild(completedItem);
                    }
                }
            }
            if (!hasCompletedTasks) {
                elements.completedTasksList.innerHTML = '<p>No completed tasks found.</p>';
            }
        });
    }
}

function toggleCompletedTasks() {
    if (elements.completedTasksList && document.querySelector('.completed-tasks .toggle-icon')) {
        elements.completedTasksList.classList.toggle('active');
        document.querySelector('.completed-tasks .toggle-icon').classList.toggle('active');
    }
}

async function updateStatus({ taskId, status }) {
    try {
        const taskRef = ref(db, `tasks/${taskId}`);
        await update(taskRef, { 
            status,
            updatedAt: new Date().toISOString()
        });
        loadWorkflows();
        loadCompletedTasks();
    } catch (error) {
        console.error("Error updating task status:", error);
        alert("Failed to update task status.");
    }
}

function calculateDaysLeft(deadline) {
    const now = new Date();
    const deadlineDate = new Date(deadline);
    const diffTime = deadlineDate - now;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays > 0 ? diffDays : 0;
}

function calculateDeadlineProgress(deadline) {
    const now = new Date();
    const deadlineDate = new Date(deadline);
    const diffTime = deadlineDate - now;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    if (diffDays <= 0) return 0;
    if (diffDays >= 30) return 100;
    return Math.round((diffDays / 30) * 100);
}

function getDeadlineColor(deadline) {
    const daysLeft = calculateDaysLeft(deadline);
    if (daysLeft <= 3) return '#FF5252';
    if (daysLeft <= 7) return '#FFC107';
    return '#4CAF50';
}

window.sendMessage = sendMessage;
window.sendFileMessage = sendFileMessage;
window.openTaskPopup = openTaskPopup;
window.toggleCompletedTasks = toggleCompletedTasks;
window.selectProfessional = selectProfessional;
window.updateStatus = updateStatus;
window.acceptRequest = acceptRequest;
window.deleteRequest = deleteRequest;
window.deleteConnection = deleteConnection;
window.deleteTask = deleteTask;
window.deleteMessage = deleteMessage;
window.confirmAction = confirmAction;
window.closeConfirmation = closeConfirmation;
window.toggleReaction = toggleReaction;

init();

</script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93b153f5ba4ebd25',t:'MTc0NjQ1OTUzOC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>