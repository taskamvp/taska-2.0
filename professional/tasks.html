<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workplace</title>
    <link rel="stylesheet" href="css/tasks.css">
    <link rel="stylesheet" href="../css/reset.css">
    <link rel="stylesheet" href="../css/global.css">
    <link rel="icon" type="image/png" href="../assets/logo.jpg">

    <link rel="stylesheet" href="../css/classified-navbar.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <nav class="navbar_classified">
        <a href="../index.html">
            <div class="logo"><img src="../assets/logo.png" alt="Taska Logo" style="height:48px;vertical-align:middle;"></div>
        </a>
        <ul class="nav-menu">
            <li><a href="explore.html">Explore</a></li>
            <li><a href="tasks.html" class="active">Workplace</a></li>
           
            <li><a href="profile.html">Account</a></li>
        </ul>
        <div class="hamburger">☰</div>
    </nav>

    <!-- Mobile Sidebar Toggle Button -->
    <button class="sidebar-toggle" id="sidebar-toggle" onclick="toggleSidebar()">
        <i class="fas fa-chevron-right"></i>
    </button>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebar-overlay" onclick="closeSidebar()"></div>

    <div class="dashboard-content">
        <div class="sidebar-left">
            <h3>Connected Students</h3>
            <div id="connections-list" class="skeleton-loading">
                <div class="skeleton-user-item"></div>
                <div class="skeleton-user-item"></div>
                <div class="skeleton-user-item"></div>
            </div>
            <div class="pending-requests" style="display: none;">
                <h3>Pending Requests</h3>
                <div id="pending-requests-list"></div>
            </div>
        </div>
        
        <!-- Choose Connection Message -->
        <div class="sidebar-right" id="choose-connection-message">
            <div class="choose-connection-content">
                <h3>Choose a Connection</h3>
                <p>Select a student from your connections to view and manage tasks together.</p>
                <div class="connection-steps">
                    <div class="step">
                        <div class="step-number">1</div>
                        <div class="step-text">Browse your student connections in the left sidebar</div>
                    </div>
                    <div class="step">
                        <div class="step-number">2</div>
                        <div class="step-text">Click on a student to start collaborating</div>
                    </div>
                    <div class="step">
                        <div class="step-number">3</div>
                        <div class="step-text">View tasks and chat with your selected student</div>
                    </div>
                </div>
                
                <!-- Invite to Connect Button - moved to bottom -->
                <div style="text-align: center; margin-top: 3rem; padding-top: 2rem; border-top: 1px solid #e0e0e0;">
                    <button id="invite-connect-btn-tasks" style="
                        font-size: 14px; 
                        padding: 10px 20px; 
                        background: #f8f9fa; 
                        border: 1px solid #dee2e6; 
                        color: #495057;
                        border-radius: 6px;
                        font-weight: 400;
                        cursor: pointer;
                        transition: all 0.2s;
                        font-family: 'Poppins', sans-serif;
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                    " onmouseover="this.style.background='#e9ecef'; this.style.borderColor='#adb5bd'" onmouseout="this.style.background='#f8f9fa'; this.style.borderColor='#dee2e6'">
                        <i class="fas fa-share-alt" style="font-size: 12px;"></i> Invite to Connect
                    </button>
                </div>
            </div>
        </div>
        
        <div class="sidebar-right" id="workflow-area">
            <div class="tasks-header">
                <h3>Tasks</h3>
                <button class="add-task-btn" onclick="openTaskPopup()">
                    <i class="fas fa-plus"></i> Add Task
                </button>
            </div>
            <div id="workflow-list" class="skeleton-loading">
                <div class="skeleton-task-item"></div>
                <div class="skeleton-task-item"></div>
            </div>
        </div>
        <div class="chat-area" id="chat-area">
            <div class="chat-header skeleton-loading" id="chat-header">
                <div class="skeleton-header"></div>
                <div class="chat-actions">
                    <button class="hide-chat-btn" onclick="hideChat()" title="Hide Chat">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
            </div>
            <div class="messages skeleton-loading" id="chat-messages">
                <div class="skeleton-message"></div>
                <div class="skeleton-message"></div>
            </div>
            <div class="chat-input">
                <div class="input-container">
                    <div class="upload-progress" id="upload-progress">
                        <div class="upload-progress-bar" id="upload-progress-bar"></div>
                    </div>
                    <textarea id="chat-input" placeholder="Type a message..." rows="1"></textarea>
                    <i class="fas fa-at mention-icon" id="mention-icon"></i>
                    <label for="file-input" class="file-input-label"><i class="fas fa-paperclip"></i></label>
                    <input type="file" id="file-input" class="file-input">
                    <div class="task-dropdown" id="task-dropdown"></div>
                </div>
                <button onclick="sendMessage()"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
        
        
    </div>
    <!-- Chat Toggle Button (appears when chat is hidden) -->
    <div class="chat-toggle-btn" id="chat-toggle-btn" onclick="showChat()">
        <i class="fas fa-comments"></i>
        <span>Chat</span>
        </div>

    <div class="confirmation-dialog" id="confirmation-dialog">
        <div class="dialog-box">
            <h3 id="dialog-title"></h3>
            <p id="dialog-message"></p>
            <div class="dialog-actions">
                <button class="cancel" onclick="closeConfirmation()">Cancel</button>
                <button id="confirm-button" class="confirm"></button>
            </div>
        </div>
    </div>

    <!-- File Viewer Modal -->
    <div class="file-viewer-modal" id="file-viewer-modal">
        <div class="modal-content">
            <button class="close-modal" onclick="closeFileViewer()">
                <i class="fas fa-times"></i>
            </button>
            <div class="file-content" id="file-content"></div>
        </div>
    </div>

    <!-- Task Popup -->
    <div class="task-popup" id="task-popup">
        <div class="task-popup-content">
            <div class="header">
                <h3 id="task-popup-title">Add Task</h3>
                <button onclick="closeTaskPopup()"><i class="fas fa-times"></i></button>
            </div>
            <div class="form-group">
                <label for="task-title">Task Title</label>
                <input type="text" id="task-title" placeholder="Enter task title">
            </div>
            <div class="form-group">
                <label for="task-description">Description</label>
                <textarea id="task-description" placeholder="Enter task description"></textarea>
            </div>
            <div class="form-group">
                <label for="task-deadline">Deadline</label>
                <input type="date" id="task-deadline">
            </div>
            <div class="form-group">
                <label for="task-files">Attach Files</label>
                <input type="file" id="task-files" multiple>
                <div id="task-files-list"></div>
            </div>
            <div class="actions">
                <button class="cancel-btn" onclick="closeTaskPopup()">Cancel</button>
                <button class="submit-btn" onclick="submitTask()">Submit</button>
            </div>
        </div>
        
        <!-- Task Popup Loading Overlay -->
        <div class="task-popup-loading" id="task-popup-loading">
            <div class="loading-content">
                <div class="loading-spinner"></div>
                <div class="loading-text" id="task-loading-text">Uploading files...</div>
                <div class="loading-progress">
                    <div class="progress-bar" id="task-progress-bar"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Files Popup -->
    <div class="files-popup" id="files-popup">
        <div class="popup-content">
            <div class="popup-header">
                <h4>Attached Files</h4>
                <button class="close-popup" onclick="closeFilesPopup()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="popup-body" id="files-popup-body">
                <!-- Files will be populated here -->
            </div>
        </div>
    </div>

    <!-- Comment Modal -->
    <div class="comment-modal" id="comment-modal">
        <div class="comment-modal-content">
            <div class="header">
                <h3>Add Comment</h3>
                <button onclick="closeCommentModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="form-group">
                <label for="comment-content">Comment</label>
                <textarea id="comment-content" placeholder="Enter your comment..."></textarea>
            </div>
            <div class="actions">
                <button class="cancel-btn" onclick="closeCommentModal()">Cancel</button>
                <button class="submit-btn" onclick="submitComment()">Submit</button>
            </div>
        </div>
    </div>

    <!-- Approval Modal -->
    <div class="approval-modal" id="approval-modal">
        <div class="approval-modal-content">
            <div class="header">
                <h3>Approve Submission</h3>
                <button onclick="closeApprovalModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="approval-body">
                <div class="approval-message">
                    <i class="fas fa-check-circle"></i>
                    <p>Please provide feedback before approving this submission.</p>
                </div>
                
                <div class="feedback-section">
                    <h4>Feedback (Optional)</h4>
                    <textarea id="approval-feedback" placeholder="Provide additional feedback for the student..."></textarea>
                </div>
            </div>
            <div class="actions">
                <button class="cancel-btn" onclick="closeApprovalModal()">Cancel</button>
                <button class="approve-btn" onclick="confirmApproval()">
                    <i class="fas fa-check"></i> Approve Submission
                </button>
            </div>
        </div>
    </div>

    <audio id="message-ding" src="../assets/dingg.mp3"></audio>

    <script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
import { getDatabase, ref, get, push, set, onValue, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";
import { getAuth } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
import { getStorage, ref as storageRef, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-storage.js";

const firebaseConfig = {
    apiKey: "AIzaSyDZIDlEtaNRxODoFhRw0xF2yYFBqqBexqo",
    authDomain: "taska-45011.firebaseapp.com",
    databaseURL: "https://taska-45011-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "taska-45011",
    storageBucket: "gs://taska-45011.firebasestorage.app",
    messagingSenderId: "205487498813",
    appId: "1:205487498813:web:0de2c9eab567482781ec54",
    measurementId: "G-G0G1F6GQ9B"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);
const storage = getStorage(app);

let userId = null;
let selectedStudentId = null;
let studentData = null;
let currentUserProfile = null;
let uploadedTaskFiles = [];
let isDataLoaded = { connections: false, chats: false, tasks: false };
let editingTaskId = null;
let currentChatListener = null;

// Add message cache
let messageCache = new Map(); // Cache for messages by chatId
let lastMessageTimestamps = new Map(); // Track last message timestamps by chatId

const elements = {
    connectionsList: document.getElementById('connections-list'),
    pendingRequestsList: document.getElementById('pending-requests-list'),
    chatArea: document.getElementById('chat-area'),
    chatHeader: document.getElementById('chat-header'),
    chatMessages: document.getElementById('chat-messages'),
    chatInput: document.getElementById('chat-input'),
    workflowArea: document.getElementById('workflow-area'),
    workflowList: document.getElementById('workflow-list'),
    completedTasksList: document.getElementById('completed-tasks-list'),
    confirmationDialog: document.getElementById('confirmation-dialog'),
    dialogTitle: document.getElementById('dialog-title'),
    dialogMessage: document.getElementById('dialog-message'),
    confirmButton: document.getElementById('confirm-button'),
    messageDing: document.getElementById('message-ding'),
    fileInput: document.getElementById('file-input'),
    uploadProgress: document.getElementById('upload-progress'),
    uploadProgressBar: document.getElementById('upload-progress-bar'),
    mentionIcon: document.getElementById('mention-icon'),
    taskDropdown: document.getElementById('task-dropdown'),
    taskPopup: document.getElementById('task-popup'),
    taskPopupTitle: document.getElementById('task-popup-title'),
    taskTitle: document.getElementById('task-title'),
    taskDescription: document.getElementById('task-description'),
    taskDeadline: document.getElementById('task-deadline'),
    taskFiles: document.getElementById('task-files'),
    taskFilesList: document.getElementById('task-files-list'),
    commentModal: document.getElementById('comment-modal'),
    commentContent: document.getElementById('comment-content')
};

// Function to load profile image from Firebase Storage
async function loadProfileImage(userId) {
    try {
        const profilePhotoRef = storageRef(storage, `profile/${userId}.webp`);
        const profilePhotoUrl = await getDownloadURL(profilePhotoRef);
        return profilePhotoUrl;
    } catch (error) {
        console.log(`No profile photo found for user ${userId}, using default avatar`);
        return "../assets/avatar/1.png";
    }
}

async function fetchStudentData() {
    if (studentData) return studentData;
    try {
        const snapshot = await get(ref(db, 'studentslist'));
        const data = snapshot.val() || {};
        studentData = Object.keys(data).map(id => ({
            id,
            ...data[id],
            personal: data[id].personal || {},
            education: data[id].education || {},
            skills: data[id].skills || '',
            profiles: data[id].profiles || {},
            portfolio: data[id].portfolio || []
        }));
        return studentData;
    } catch (error) {
        console.error('Error fetching student data:', error);
        return [];
    }
}

async function fetchCurrentUserProfile() {
    if (currentUserProfile) return currentUserProfile;
    try {
        const snapshot = await get(ref(db, `professionalslist/${userId}`));
        const user = snapshot.val() || {};
        const profilePic = await loadProfileImage(userId);
        currentUserProfile = {
            name: user.personal?.name || "Unnamed",
            profilePic: profilePic
        };
        return currentUserProfile;
    } catch (error) {
        console.error('Error fetching current user profile:', error);
        return { name: "Unnamed", profilePic: "../assets/avatar/1.png" };
    }
}

function confirmAction(action, title, message, actionParams = {}) {
    elements.dialogTitle.textContent = title;
    elements.dialogMessage.textContent = message;
    elements.confirmationDialog.classList.add('active');
    elements.confirmButton.textContent = title.includes('Delete') ? 'Delete' : 'Confirm';
    elements.confirmButton.className = title.includes('Delete') ? 'delete' : 'confirm';
    elements.confirmButton.onclick = () => {
        window[action](actionParams);
        closeConfirmation();
    };
}

function closeConfirmation() {
    elements.confirmationDialog.classList.remove('active');
}

function getFileIconClass(type) {
    if (type.includes('pdf')) return 'fas fa-file-pdf';
    if (type.includes('image')) return 'fas fa-file-image';
    if (type.includes('video')) return 'fas fa-file-video';
    if (type.includes('excel') || type.includes('spreadsheet')) return 'fas fa-file-excel';
    if (type.includes('word') || type.includes('doc')) return 'fas fa-file-word';
    return 'fas fa-file';
}

function getFileIconColor(type) {
    if (type.includes('pdf')) return '#FF5252';
    if (type.includes('image')) return '#4CAF50';
    if (type.includes('video')) return '#2196F3';
    if (type.includes('excel') || type.includes('spreadsheet')) return '#2E7D32';
    if (type.includes('word') || type.includes('doc')) return '#1976D2';
    return '#6c757d';
}

function checkAllDataLoaded() {
    if (isDataLoaded.connections && isDataLoaded.chats && isDataLoaded.tasks) {
        elements.connectionsList.classList.remove('skeleton-loading');
        elements.chatArea.classList.remove('skeleton-loading');
        elements.chatHeader.classList.remove('skeleton-loading');
        elements.chatMessages.classList.remove('skeleton-loading');
        elements.workflowList.classList.remove('skeleton-loading');
    }
}

async function init() {
    document.addEventListener('DOMContentLoaded', async () => {
        await fetchStudentData();
        setupEventListeners();
        
        // Show choose connection message by default
        const chooseConnectionMessage = document.getElementById('choose-connection-message');
        if (chooseConnectionMessage) {
            chooseConnectionMessage.style.display = 'flex';
        }
        
        // Hide workflow area initially
        if (elements.workflowArea) {
            elements.workflowArea.style.display = 'none';
        }
        
        // Add page unload event listener for cache cleanup
        window.addEventListener('beforeunload', () => {
            clearMessageCache();
            if (currentChatListener) {
                currentChatListener();
            }
        });
        
        // Add visibility change listener to manage cache when tab becomes hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                manageCacheSize();
            }
        });
        
        auth.onAuthStateChanged(user => {
            if (user) {
                userId = user.uid;
                fetchCurrentUserProfile().then(() => {
                    loadConnections();
                    loadPendingRequests();
                    loadCompletedTasks();
                });
            } else {
                console.error("User not authenticated");
                window.location.href = "../login.html";
            }
        });
    });
}

function setupEventListeners() {
    const hamburger = document.querySelector('.navbar_classified .hamburger');
    const navMenu = document.querySelector('.navbar_classified .nav-menu');
    if (hamburger && navMenu) {
        hamburger.addEventListener('click', () => navMenu.classList.toggle('active'));
    }

    document.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.closest('.user-item') && !target.closest('.pending-item')) {
            const studentId = target.closest('.user-item').dataset.studentId;
            selectStudent(studentId);
        }
        if (target.matches('.accept-btn')) {
            const studentId = target.closest('.pending-item').dataset.studentId;
            confirmAction('acceptRequest', 'Accept Request', 'Are you sure you want to accept this connection request?', { studentId });
        }
        if (target.matches('.delete-btn')) {
            const studentId = target.closest('.pending-item').dataset.studentId;
            confirmAction('deleteRequest', 'Delete Request', 'Are you sure you want to delete this connection request?', { studentId });
        }
        if (target.matches('.task-menu-icon')) {
            const dropdown = target.closest('.task-menu').querySelector('.task-menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (target.matches('.task-menu-dropdown button')) {
            const action = target.dataset.action;
            const taskId = target.closest('.workflow-item').dataset.taskId;
            if (action === 'editTask') {
                openTaskPopup(taskId);
            } else if (action === 'deleteTask') {
                confirmAction('deleteTask', 'Delete Task', 'Are you sure you want to delete this task?', { taskId });
            }
        }
        if (target.matches('.reaction-icon')) {
            const messageId = target.closest('.message').dataset.messageId;
            const reaction = target.dataset.reaction;
            toggleReaction(messageId, reaction);
        }
        if (target.matches('.message-menu-icon')) {
            const dropdown = target.closest('.message-menu').querySelector('.message-menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (target.matches('.message-menu-dropdown button')) {
            const action = target.dataset.action;
            const messageId = target.closest('.message').dataset.messageId;
            if (action === 'deleteMessage') {
                confirmAction('deleteMessage', 'Delete Message', 'Are you sure you want to delete this message?', { messageId });
            }
        }
        if (target.matches('.chat-header .menu-icon')) {
            const dropdown = target.closest('.menu').querySelector('.menu-dropdown');
            dropdown.classList.toggle('active');
        }
        if (target.matches('.chat-header .menu-dropdown button')) {
            const action = target.dataset.action;
            if (action === 'deleteConnection') {
                confirmAction('deleteConnection', 'Delete Connection', 'Are you sure you want to delete this connection?', { studentId: selectedStudentId });
            }
        }
        if (target.matches('.mention-icon')) {
            elements.taskDropdown.classList.toggle('active');
            if (elements.taskDropdown.classList.contains('active')) {
                await populateTaskDropdown();
            }
        }
        if (target.matches('.task-dropdown-item')) {
            const taskTitle = target.textContent;
            insertMention(taskTitle);
        }
        if (target.matches('.remove-file')) {
            const fileIndex = target.dataset.index;
            uploadedTaskFiles.splice(fileIndex, 1);
            updateTaskFilesList();
        }
    });

    if (elements.workflowList) {
        elements.workflowList.addEventListener('change', (e) => {
            if (e.target.matches('.status-select')) {
                const taskId = e.target.closest('.workflow-item').dataset.taskId;
                const newStatus = e.target.value;
                confirmAction('updateStatus', `Update Task Status`, `Are you sure you want to change the task status to "${newStatus}"?`, { taskId, status: newStatus });
            }
        });
    }

    if (elements.chatInput) {
        elements.chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        elements.chatInput.addEventListener('input', async () => {
            elements.chatInput.style.height = 'auto';
            elements.chatInput.style.height = `${Math.min(elements.chatInput.scrollHeight, 100)}px`;
            const value = elements.chatInput.value;
            if (value.endsWith('@') && !elements.taskDropdown.classList.contains('active')) {
                elements.taskDropdown.classList.add('active');
                await populateTaskDropdown();
            }
        });
        elements.chatInput.addEventListener('keydown', (e) => {
            if (elements.taskDropdown.classList.contains('active')) {
                const items = elements.taskDropdown.querySelectorAll('.task-dropdown-item');
                let selectedIndex = -1;
                items.forEach((item, index) => {
                    if (item.classList.contains('selected')) selectedIndex = index;
                });
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    items.forEach(item => item.classList.remove('selected'));
                    items[selectedIndex].classList.add('selected');
                    items[selectedIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, 0);
                    items.forEach(item => item.classList.remove('selected'));
                    items[selectedIndex].classList.add('selected');
                    items[selectedIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    const taskTitle = items[selectedIndex].textContent;
                    insertMention(taskTitle);
                } else if (e.key === 'Escape') {
                    elements.taskDropdown.classList.remove('active');
                }
            }
        });
    }

    if (elements.fileInput) {
        elements.fileInput.addEventListener('change', async () => {
            if (elements.fileInput.files.length > 0) {
                await sendFileMessage(elements.fileInput.files[0]);
                elements.fileInput.value = '';
            }
        });
    }

    if (elements.taskFiles) {
        elements.taskFiles.addEventListener('change', () => {
            const files = Array.from(elements.taskFiles.files);
            uploadedTaskFiles.push(...files);
            updateTaskFilesList();
            elements.taskFiles.value = '';
        });
    }

    document.addEventListener('click', (e) => {
        if (!e.target.closest('.task-menu')) {
            document.querySelectorAll('.task-menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        if (!e.target.closest('.message-menu')) {
            document.querySelectorAll('.message-menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        if (!e.target.closest('.chat-header .menu')) {
            document.querySelectorAll('.chat-header .menu-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        if (!e.target.closest('.input-container')) {
            elements.taskDropdown.classList.remove('active');
        }
        
        // Close chat when clicking outside
        const chatArea = document.getElementById('chat-area');
        const chatToggleBtn = document.getElementById('chat-toggle-btn');
        
        if (chatArea && chatArea.style.display === 'block' && 
            !e.target.closest('.chat-area') && 
            !e.target.closest('.chat-toggle-btn') &&
            !e.target.closest('.confirmation-dialog')) {
            hideChat();
        }
    });
}

function updateTaskFilesList() {
    elements.taskFilesList.innerHTML = '';
    uploadedTaskFiles.forEach((file, index) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'task-file-item';
        fileItem.innerHTML = `
            <i class="${getFileIconClass(file.type)}"></i>
            <span>${file.name}</span>
            <i class="fas fa-times remove-file" data-index="${index}"></i>
        `;
        elements.taskFilesList.appendChild(fileItem);
    });
}

async function loadConnections() {
    if (!elements.connectionsList) return;
    try {
        const connectionsRef = ref(db, `users/${userId}/connections`);
        const snapshot = await get(connectionsRef);
        elements.connectionsList.innerHTML = '';
        if (snapshot.exists()) {
            const connections = snapshot.val();
            let hasConnections = false;
            const students = await fetchStudentData();
            for (const studentId in connections) {
                if (connections[studentId].status === "connected") {
                    hasConnections = true;
                    const student = students.find(s => s.id === studentId) || {};
                    const userName = student.personal?.name || "Unnamed";
                    const profilePic = await loadProfileImage(studentId);
                    const chatId = [userId, studentId].sort().join("+");
                    const chatRef = ref(db, `chats/${chatId}/messages`);
                    let lastMessage = "No messages yet";
                    let hasUnread = false;
                    const chatSnapshot = await get(chatRef);
                    if (chatSnapshot.exists()) {
                        const messages = Object.values(chatSnapshot.val());
                        const lastMsg = messages[messages.length - 1];
                        lastMessage = lastMsg.file ? `[File] ${lastMsg.file.name}` : lastMsg.content || "No messages yet";
                        hasUnread = messages.some(msg => msg.senderId !== userId && !msg.read);
                    }
                    const userItem = document.createElement('div');
                    userItem.className = 'user-item';
                    userItem.dataset.studentId = studentId;
                    userItem.innerHTML = `
                        <img src="${profilePic}" class="profile-pic" onclick="handleProfilePictureClick('${studentId}', 'student')" style="cursor: pointer;">
                        <div class="user-info">
                            <div class="name">${userName}</div>
                            <div class="last-message">${lastMessage}</div>
                        </div>
                        ${hasUnread ? '<div class="unread-dot"></div>' : ''}
                    `;
                    elements.connectionsList.appendChild(userItem);
                }
            }
            if (!hasConnections) {
                elements.connectionsList.innerHTML = '<p>No connected students found.</p>';
            }
        } else {
            elements.connectionsList.innerHTML = '<p>No connected students found.</p>';
        }
        isDataLoaded.connections = true;
        checkAllDataLoaded();
    } catch (error) {
        console.error("Error loading connections:", error);
        elements.connectionsList.innerHTML = '<p>Error loading connections.</p>';
        isDataLoaded.connections = true;
        checkAllDataLoaded();
    }
}

async function loadPendingRequests() {
    if (!elements.pendingRequestsList) return;
    try {
        const connectionsRef = ref(db, `users/${userId}/connections`);
        const snapshot = await get(connectionsRef);
        elements.pendingRequestsList.innerHTML = '';
        const pendingRequestsSection = document.querySelector('.pending-requests');
        if (snapshot.exists()) {
            const connections = snapshot.val();
            let hasPending = false;
            const students = await fetchStudentData();
            for (const studentId in connections) {
                if (connections[studentId].status === "pending") {
                    hasPending = true;
                    const student = students.find(s => s.id === studentId) || {};
                    const userName = student.personal?.name || "Unnamed";
                    const profilePic = await loadProfileImage(studentId);
                    const pendingItem = document.createElement('div');
                    pendingItem.className = 'pending-item user-item';
                    pendingItem.dataset.studentId = studentId;
                    pendingItem.innerHTML = `
                        <div class="user-info">
                            <img src="${profilePic}" class="profile-pic" onclick="handleProfilePictureClick('${studentId}', 'student')" style="cursor: pointer;">
                            <div class="name">${userName}</div>
                        </div>
                        <div class="actions">
                          
                            <button class="delete-btn">Delete</button>
                        </div>
                    `;
                    elements.pendingRequestsList.appendChild(pendingItem);
                }
            }
            pendingRequestsSection.style.display = hasPending ? 'block' : 'none';
        } else {
            pendingRequestsSection.style.display = 'none';
        }
    } catch (error) {
        console.error("Error loading pending requests:", error);
        elements.pendingRequestsList.innerHTML = '<p>Error loading pending requests.</p>';
        document.querySelector('.pending-requests').style.display = 'none';
    }
}

async function acceptRequest({ studentId }) {
    try {
        const professionalConnectionRef = ref(db, `users/${userId}/connections/${studentId}`);
        const studentConnectionRef = ref(db, `users/${studentId}/connections/${userId}`);
        await update(professionalConnectionRef, { status: "connected" });
        await update(studentConnectionRef, { status: "connected" });
        loadConnections();
        loadPendingRequests();
    } catch (error) {
        console.error("Error accepting request:", error);
        alert("Failed to accept request.");
    }
}

async function deleteRequest({ studentId }) {
    try {
        const professionalConnectionRef = ref(db, `users/${userId}/connections/${studentId}`);
        const studentConnectionRef = ref(db, `users/${studentId}/connections/${userId}`);
        await remove(professionalConnectionRef);
        await remove(studentConnectionRef);
        // Remove the pending item from the DOM directly
        const pendingItem = document.querySelector(`.pending-item.user-item[data-student-id='${studentId}']`);
        if (pendingItem) {
            pendingItem.remove();
        }
        // If no more pending items, hide the section
        const pendingRequestsSection = document.querySelector('.pending-requests');
        const remaining = document.querySelectorAll('.pending-item.user-item').length;
        if (pendingRequestsSection && remaining === 0) {
            pendingRequestsSection.style.display = 'none';
        }
    } catch (error) {
        console.error("Error deleting request:", error);
        elements.pendingRequestsList.innerHTML = '<p>Error loading pending requests.</p>';
        document.querySelector('.pending-requests').style.display = 'none';
    }
}

async function deleteConnection({ studentId }) {
    try {
        const professionalConnectionRef = ref(db, `users/${userId}/connections/${studentId}`);
        const studentConnectionRef = ref(db, `users/${studentId}/connections/${userId}`);
        await remove(professionalConnectionRef);
        await remove(studentConnectionRef);
        loadConnections();
        loadPendingRequests();
        elements.chatArea.style.display = 'none';
        elements.workflowArea.style.display = 'none';
        
        // Hide chat toggle button when no student is selected
        const chatToggleBtn = document.getElementById('chat-toggle-btn');
        if (chatToggleBtn) {
            chatToggleBtn.style.display = 'none';
        }
        
        selectedStudentId = null;
    } catch (error) {
        console.error("Error deleting connection:", error);
        alert("Failed to delete connection.");
    }
}

async function deleteTask({ taskId }) {
    try {
        const taskRef = ref(db, `tasks/${taskId}`);
        await remove(taskRef);
        loadWorkflows();
        loadCompletedTasks();
    } catch (error) {
        console.error("Error deleting task:", error);
        alert("Failed to delete task.");
    }
}

async function deleteMessage({ messageId }) {
    try {
        const chatId = [userId, selectedStudentId].sort().join("+");
        const messageRef = ref(db, `chats/${chatId}/messages/${messageId}`);
        
        // Get the message data first to check if it contains a file
        const messageSnapshot = await get(messageRef);
        if (messageSnapshot.exists()) {
            const message = messageSnapshot.val();
            
            // If the message contains a file, delete it from Firebase Storage
            if (message.file && message.file.url) {
                try {
                    // Extract file path from URL and delete from storage
                    const fileUrl = message.file.url;
                    const filePath = fileUrl.split('/o/')[1]?.split('?')[0];
                    
                    if (filePath) {
                        const fileRef = storageRef(storage, decodeURIComponent(filePath));
                        await remove(fileRef);
                        console.log('File deleted from storage:', filePath);
                    }
                } catch (fileError) {
                    console.warn('Could not delete file from storage:', fileError);
                    // Continue with message deletion even if file deletion fails
                }
            }
        }
        
        // Delete the message from the database
        await remove(messageRef);
        
    } catch (error) {
        console.error("Error deleting message:", error);
        alert("Failed to delete message.");
    }
}

async function selectStudent(studentId) {
    // Clear all chat data when switching students
    clearAllChatData();
    
    selectedStudentId = studentId;
    document.querySelectorAll('.user-item').forEach(item => {
        const isActive = item.dataset.studentId === studentId;
        item.classList.toggle('active', isActive);
        const lastMessage = item.querySelector('.last-message');
        if (lastMessage) lastMessage.style.display = isActive ? 'none' : 'block';
        if (isActive) {
            const unreadDot = item.querySelector('.unread-dot');
            if (unreadDot) unreadDot.remove();
        }
    });
    
    // Hide choose connection message and show workflow area
    const chooseConnectionMessage = document.getElementById('choose-connection-message');
    if (chooseConnectionMessage) {
        chooseConnectionMessage.style.display = 'none';
    }
    
    // Show workflow area
    if (elements.workflowArea) {
        elements.workflowArea.style.display = 'block';
    }
    
    // Keep chat area hidden initially
    if (elements.chatArea) {
        elements.chatArea.style.display = 'none';
        elements.chatArea.classList.remove('chat-hidden');
    }
    
    // Show chat toggle button when student is selected
    const chatToggleBtn = document.getElementById('chat-toggle-btn');
    if (chatToggleBtn) {
        chatToggleBtn.style.display = 'flex';
    }
    
    // Close sidebar in mobile view when student is selected
    if (window.innerWidth <= 768) {
        closeSidebar();
    }
    
    loadChatHeader();
    loadChat();
    loadWorkflows();
    loadCompletedTasks();
}

async function loadChatHeader() {
    if (!elements.chatHeader) return;
    if (!selectedStudentId) {
        console.error("No student selected");
        return;
    }
    
    try {
        const students = await fetchStudentData();
        const student = students.find(s => s.id === selectedStudentId) || {};
        const userName = student.personal?.name || "Unnamed";
        const userTitle = student.education?.branch || "";
        const profilePic = await loadProfileImage(selectedStudentId);
        elements.chatHeader.innerHTML = `
            <div style="display: flex; align-items: center; gap: 1rem;">
                <a href="../workplace/view-profile.html?studentId=${encodeURIComponent(selectedStudentId)}" style="text-decoration: none; cursor: pointer;" title="View ${userName}'s profile">
                    <img src="${profilePic}" class="profile-pic" style="cursor: pointer;">
                </a>
                <div>
                    <div class="name">${userName}</div>
                    <div class="title">${userTitle}</div>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
            <button class="notify-btn" onclick="openNotifyPopup()" title="Notify about chat updates" style="background: #f5f5f5; border: 1px solid #ccc; border-radius: 4px; padding: 4px 10px; font-size: 13px; cursor: pointer; margin-right: 0.5rem;">
                <i class="fas fa-bell"></i> Notify
            </button>
            <div class="menu">
                <i class="fas fa-ellipsis-v menu-icon"></i>
                <div class="menu-dropdown">
                    <button data-action="deleteConnection">Delete Connection</button>
                </div>
                </div>
                <button class="hide-chat-btn" onclick="hideChat()">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        `;
    } catch (error) {
        console.error("Error loading chat header:", error);
        elements.chatHeader.innerHTML = `
            <div style="display: flex; align-items: center; gap: 1rem;">
                <a href="../workplace/view-profile.html?studentId=${encodeURIComponent(selectedStudentId)}" style="text-decoration: none; cursor: pointer;" title="View student's profile">
                    <img src="../assets/avatar/1.png" class="profile-pic" style="cursor: pointer;">
                </a>
                <div>
                    <div class="name">Unnamed</div>
                    <div class="title"></div>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
            <div class="menu">
                <i class="fas fa-ellipsis-v menu-icon"></i>
                <div class="menu-dropdown">
                    <button data-action="deleteConnection">Delete Connection</button>
                </div>
                </div>
                <button class="hide-chat-btn" onclick="hideChat()">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        `;
    }
}

function formatMessageDate(timestamp) {
    const now = new Date();
    const messageDate = new Date(timestamp);
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
    const messageDay = new Date(messageDate.getFullYear(), messageDate.getMonth(), messageDate.getDate());
    if (messageDay.getTime() === today.getTime()) {
        return 'Today';
    } else if (messageDay.getTime() === yesterday.getTime()) {
        return 'Yesterday';
    } else {
        return messageDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
}

async function loadChat() {
    if (!elements.chatMessages) return;
    // Clean up previous listener if it exists
    if (currentChatListener) {
        currentChatListener();
        currentChatListener = null;
    }
    
    if (!selectedStudentId) return;
    
    const chatId = [userId, selectedStudentId].sort().join("+");
    
    // Clear the chat messages area immediately when switching students
    elements.chatMessages.innerHTML = '';
    
    // Manage cache size before loading new chat
    manageCacheSize();
    
    // Show skeleton loading only if no cached messages
    if (!messageCache.has(chatId) || messageCache.get(chatId).length === 0) {
        elements.chatMessages.innerHTML = `
            <div class="skeleton-message"></div>
            <div class="skeleton-message"></div>
        `;
    }
    
    const currentUser = await fetchCurrentUserProfile();
    
    // Store the listener reference so we can clean it up later
    currentChatListener = onValue(ref(db, `chats/${chatId}/messages`), async (snapshot) => {
        if (!snapshot.exists()) {
            elements.chatMessages.innerHTML = '<div class="message">No messages yet</div>';
            messageCache.set(chatId, []);
            lastMessageTimestamps.set(chatId, {});
            isDataLoaded.chats = true;
            checkAllDataLoaded();
            return;
        }

        const newMessages = Object.entries(snapshot.val())
            .map(([id, msg]) => ({ id, ...msg }))
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        const cachedMessages = messageCache.get(chatId) || [];
        const lastTimestamps = lastMessageTimestamps.get(chatId) || {};
        
        // Check if we need to do a full render or incremental update
        const needsFullRender = shouldDoFullRender(cachedMessages, newMessages, lastTimestamps);
        
        if (needsFullRender) {
            // Full render - clear and rebuild everything
            await renderAllMessages(newMessages, currentUser, chatId);
        } else {
            // Incremental update - only update changed messages
            await updateChangedMessages(cachedMessages, newMessages, currentUser, chatId);
        }
        
        // Update cache and timestamps
        messageCache.set(chatId, newMessages);
        const newTimestamps = {};
        newMessages.forEach(msg => {
            newTimestamps[msg.id] = msg.timestamp;
        });
        lastMessageTimestamps.set(chatId, newTimestamps);
        
        // Mark messages as read
        newMessages.forEach(msg => {
            if (msg.senderId !== userId && !msg.read) {
                update(ref(db, `chats/${chatId}/messages/${msg.id}`), { read: true });
            }
        });
        
        isDataLoaded.chats = true;
        checkAllDataLoaded();
    });
}

// Helper function to determine if full render is needed
function shouldDoFullRender(cachedMessages, newMessages, lastTimestamps) {
    // If cache is empty, do full render
    if (cachedMessages.length === 0) return true;
    
    // If message count changed significantly, do full render
    if (Math.abs(newMessages.length - cachedMessages.length) > 3) return true;
    
    // If any message timestamps changed, check if it's a major change
    let changedCount = 0;
    for (const msg of newMessages) {
        const cachedTimestamp = lastTimestamps[msg.id];
        if (!cachedTimestamp || cachedTimestamp !== msg.timestamp) {
            changedCount++;
        }
    }
    
    // If more than 20% of messages changed, do full render (more aggressive)
    return changedCount > (newMessages.length * 0.2);
}

// Function to render all messages (full render)
async function renderAllMessages(messages, currentUser, chatId) {
    elements.chatMessages.innerHTML = '';
    
    if (messages.length === 0) {
        elements.chatMessages.innerHTML = '<div class="message">No messages yet</div>';
        return;
    }
    
    const students = await fetchStudentData();
    const student = students.find(s => s.id === selectedStudentId) || {};
    const tasksRef = ref(db, `tasks`);
    const tasksSnapshot = await get(tasksRef);
    const tasks = tasksSnapshot.exists() ? tasksSnapshot.val() : {};
    let taskTitles = [];
    for (const taskId in tasks) {
        if (tasks[taskId].professionalId === userId && tasks[taskId].studentId === selectedStudentId) {
            taskTitles.push(tasks[taskId].title);
        }
    }
    
    let lastDate = null;
    for (const msg of messages) {
        const messageElement = await createMessageElement(msg, currentUser, student, taskTitles, chatId);
        
        // Add date divider if needed
        const date = formatMessageDate(msg.timestamp);
        if (date !== lastDate) {
            const dateDivider = document.createElement('div');
            dateDivider.className = 'date-divider';
            dateDivider.innerHTML = `<span>${date}</span>`;
            elements.chatMessages.appendChild(dateDivider);
            lastDate = date;
        }
        
        elements.chatMessages.appendChild(messageElement);
    }
    
    elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
}

// Function to update only changed messages (incremental update)
async function updateChangedMessages(cachedMessages, newMessages, currentUser, chatId) {
    const lastTimestamps = lastMessageTimestamps.get(chatId) || {};
    const students = await fetchStudentData();
    const student = students.find(s => s.id === selectedStudentId) || {};
    const tasksRef = ref(db, `tasks`);
    const tasksSnapshot = await get(tasksRef);
    const tasks = tasksSnapshot.exists() ? tasksSnapshot.val() : {};
    let taskTitles = [];
    for (const taskId in tasks) {
        if (tasks[taskId].professionalId === userId && tasks[taskId].studentId === selectedStudentId) {
            taskTitles.push(tasks[taskId].title);
        }
    }
    
    // Find changed messages
    const changedMessages = [];
    const newMessageIds = new Set(newMessages.map(m => m.id));
    const cachedMessageIds = new Set(cachedMessages.map(m => m.id));
    
    // Check for new messages
    for (const msg of newMessages) {
        if (!cachedMessageIds.has(msg.id)) {
            changedMessages.push({ type: 'new', message: msg });
        }
    }
    
    // Check for updated messages
    for (const msg of newMessages) {
        const cachedTimestamp = lastTimestamps[msg.id];
        if (cachedTimestamp && cachedTimestamp !== msg.timestamp) {
            changedMessages.push({ type: 'updated', message: msg });
        }
    }
    
    // Check for deleted messages
    for (const msg of cachedMessages) {
        if (!newMessageIds.has(msg.id)) {
            changedMessages.push({ type: 'deleted', message: msg });
        }
    }
    
    // Batch DOM updates to improve performance
    const fragment = document.createDocumentFragment();
    const elementsToRemove = [];
    const elementsToAdd = [];
    const elementsToUpdate = [];
    
    // Prepare all changes
    for (const change of changedMessages) {
        const existingElement = elements.chatMessages.querySelector(`[data-message-id="${change.message.id}"]`);
        
        if (change.type === 'new') {
            // Prepare new message
            const messageElement = await createMessageElement(change.message, currentUser, student, taskTitles, chatId);
            
            // Check if we need to add a date divider
            const date = formatMessageDate(change.message.timestamp);
            const prevMessage = newMessages.find(m => m.id === change.message.id);
            const prevIndex = newMessages.indexOf(prevMessage);
            const prevDate = prevIndex > 0 ? formatMessageDate(newMessages[prevIndex - 1].timestamp) : null;
            
            if (date !== prevDate) {
                const dateDivider = document.createElement('div');
                dateDivider.className = 'date-divider';
                dateDivider.innerHTML = `<span>${date}</span>`;
                elementsToAdd.push({ element: dateDivider, before: existingElement });
            }
            
            elementsToAdd.push({ element: messageElement, before: existingElement });
        } else if (change.type === 'updated') {
            // Prepare updated message
            const messageElement = await createMessageElement(change.message, currentUser, student, taskTitles, chatId);
            elementsToUpdate.push({ oldElement: existingElement, newElement: messageElement });
        } else if (change.type === 'deleted') {
            // Prepare deleted message
            if (existingElement) {
                elementsToRemove.push(existingElement);
            }
        }
    }
    
    // Apply all changes in batch
    // Remove elements first
    elementsToRemove.forEach(element => element.remove());
    
    // Update elements
    elementsToUpdate.forEach(({ oldElement, newElement }) => {
        if (oldElement) {
            oldElement.replaceWith(newElement);
        }
    });
    
    // Add new elements
    elementsToAdd.forEach(({ element, before }) => {
        if (before) {
            elements.chatMessages.insertBefore(element, before);
        } else {
            elements.chatMessages.appendChild(element);
        }
    });
    
    // Scroll to bottom if new messages were added
    if (changedMessages.some(c => c.type === 'new')) {
        elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
    }
}

// Function to create a single message element
async function createMessageElement(msg, currentUser, student, taskTitles, chatId) {
    const isSent = msg.senderId === userId;
    const senderName = isSent ? currentUser.name : (student.personal?.name || "Unnamed");
    const profilePic = isSent 
        ? currentUser.profilePic
        : await loadProfileImage(selectedStudentId);
    const time = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${isSent ? 'sent' : 'received'} ${msg.file ? 'file-message' : ''}`;
    messageDiv.dataset.messageId = msg.id;
    
    let content = msg.content || '';
    taskTitles.forEach(title => {
        const regex = new RegExp(`@${title.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')}`, 'g');
        content = content.replace(regex, `<span class="mention">@${title}</span>`);
    });
    
    let reactionsHTML = '';
    if (msg.reactions && msg.reactions[userId]) {
        reactionsHTML = `<span class="reaction">${msg.reactions[userId]}</span>`;
    }
    
    if (msg.file) {
        const fileSize = msg.file.size ? (msg.file.size / 1024).toFixed(2) + ' KB' : 'Unknown size';
        const isImage = msg.file.type && msg.file.type.startsWith('image/');
        const fileName = msg.file.name.length > 25 ? msg.file.name.substring(0, 25) + '...' : msg.file.name;
        
        messageDiv.innerHTML = `
            <div class="message-header">
                <img src="${profilePic}" class="profile-pic" onclick="handleProfilePictureClick('${msg.senderId}', '${msg.senderId === userId ? 'professional' : 'student'}')" style="cursor: pointer;">
                <div class="name">${senderName}</div>
                <div class="time">${time}</div>
            </div>
            <a href="${msg.file.url}" download="${msg.file.name}" target="_blank">
                <div class="file-info">
                    ${isImage ? 
                        `<img src="${msg.file.url}" alt="${msg.file.name}" class="file-thumbnail">` :
                        `<i class="${getFileIconClass(msg.file.type)} file-icon" style="color: ${getFileIconColor(msg.file.type)};"></i>`
                    }
                    <div class="file-details">
                        <div class="file-name">${fileName}</div>
                        <div class="file-size">${fileSize}</div>
                    </div>
                </div>
            </a>
            <div class="read-status">${msg.read ? 'Seen' : 'Sent'}</div>
            <div class="reactions">${reactionsHTML}</div>
            <div class="reaction-bar" >
                <span class="reaction-icon" data-reaction="🤝" style="display: none;">🤝</span>
                <span class="reaction-icon" data-reaction="👍" style="display: none;">👍</span>
                <span class="reaction-icon" data-reaction="❤️" style="display: none;">❤️</span>
                <div class="message-menu">
                    <i class="fas fa-ellipsis-h message-menu-icon"></i>
                    <div class="message-menu-dropdown">
                        <button data-action="deleteMessage">Delete Message</button>
                    </div>
                </div>
            </div>
        `;
    } else {
        messageDiv.innerHTML = `
            <div class="message-header">
                <img src="${profilePic}" class="profile-pic" onclick="handleProfilePictureClick('${msg.senderId}', '${msg.senderId === userId ? 'professional' : 'student'}')" style="cursor: pointer;">
                <div class="name">${senderName}</div>
                <div class="time">${time}</div>
            </div>
            <div class="content">${content}</div>
            <div class="read-status">${msg.read ? 'Seen' : 'Sent'}</div>
            <div class="reactions">${reactionsHTML}</div>
            <div class="reaction-bar" >
                <span class="reaction-icon" data-reaction="🤝" style="display: none;">🤝</span>
                <span class="reaction-icon" data-reaction="👍" style="display: none;">👍</span>
                <span class="reaction-icon" data-reaction="❤️" style="display: none;">❤️</span>
                <div class="message-menu">
                    <i class="fas fa-ellipsis-h message-menu-icon"></i>
                    <div class="message-menu-dropdown">
                        <button data-action="deleteMessage">Delete Message</button>
                    </div>
                </div>
            </div>
        `;
    }
    
    return messageDiv;
}

async function toggleReaction(messageId, reaction) {
    try {
        const chatId = [userId, selectedStudentId].sort().join("+");
        const messageRef = ref(db, `chats/${chatId}/messages/${messageId}`);
        const snapshot = await get(messageRef);
        if (snapshot.exists()) {
            const message = snapshot.val();
            const reactions = message.reactions || {};
            if (reactions[userId] === reaction) {
                delete reactions[userId];
            } else {
                reactions[userId] = reaction;
            }
            await update(messageRef, { reactions });
        }
    } catch (error) {
        console.error("Error toggling reaction:", error);
        alert("Failed to toggle reaction.");
    }
}

async function sendMessage() {
    if (!elements.chatInput) return;
    const content = elements.chatInput.value.trim();
    if (!content || !selectedStudentId) return;
    const chatId = [userId, selectedStudentId].sort().join("+");
    const messageRef = ref(db, `chats/${chatId}/messages`);
    try {
        const currentUser = await fetchCurrentUserProfile();
        const newMessage = {
            senderId: userId,
            senderName: currentUser.name,
            content,
            timestamp: new Date().toISOString(),
            read: false
        };
        await push(messageRef, newMessage);
        elements.chatInput.value = '';
        elements.chatInput.style.height = 'auto';
        elements.taskDropdown.classList.remove('active');
        if (elements.messageDing) {
            elements.messageDing.play().catch(error => console.error("Error playing ding sound:", error));
        }
    } catch (error) {
        console.error("Error sending message:", error);
        alert("Failed to send message.");
    }
}

async function sendFileMessage(file) {
    if (!selectedStudentId) return;
    const chatId = [userId, selectedStudentId].sort().join("+");
    const messageRef = ref(db, `chats/${chatId}/messages`);
    try {
        const storagePath = `chats/${chatId}/${Date.now()}_${file.name}`;
        const fileRef = storageRef(storage, storagePath);
        const uploadTask = uploadBytesResumable(fileRef, file);

        elements.uploadProgress.classList.add('active');
        elements.uploadProgressBar.style.width = '0%';

        uploadTask.on('state_changed',
            (snapshot) => {
                const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                elements.uploadProgressBar.style.width = `${progress}%`;
            },
            (error) => {
                console.error('Error uploading file:', error);
                elements.uploadProgress.classList.remove('active');
                alert('Failed to upload file.');
            },
            async () => {
                const fileUrl = await getDownloadURL(fileRef);
                const currentUser = await fetchCurrentUserProfile();
                const newMessage = {
                    senderId: userId,
                    senderName: currentUser.name,
                    file: {
                        name: file.name,
                        url: fileUrl,
                        type: file.type,
                        size: file.size
                    },
                    timestamp: new Date().toISOString(),
                    read: false
                };
                await push(messageRef, newMessage);
                elements.uploadProgress.classList.remove('active');
                if (elements.messageDing) {
                    elements.messageDing.play().catch(error => console.error("Error playing ding sound:", error));
                }
            }
        );
    } catch (error) {
        console.error("Error initiating file upload:", error);
        elements.uploadProgress.classList.remove('active');
        alert("Failed to upload file.");
    }
}

async function openTaskPopup(taskId = null) {
    if (!selectedStudentId) {
        alert('Please select a student to assign a task.');
        return;
    }
    editingTaskId = taskId;
    elements.taskPopupTitle.textContent = taskId ? 'Edit Task' : 'Add Task';
    elements.taskTitle.value = '';
    elements.taskDescription.value = '';
    elements.taskDeadline.value = '';
    uploadedTaskFiles = [];
    elements.taskFilesList.innerHTML = '';

    if (taskId) {
        try {
            const taskRef = ref(db, `tasks/${taskId}`);
            const snapshot = await get(taskRef);
            if (snapshot.exists()) {
                const task = snapshot.val();
                elements.taskTitle.value = task.title || '';
                elements.taskDescription.value = task.description || '';
                elements.taskDeadline.value = task.deadline ? new Date(task.deadline).toISOString().split('T')[0] : '';
                if (task.files) {
                    uploadedTaskFiles = Object.values(task.files).map(file => ({
                        name: file.name,
                        url: file.url,
                        type: file.type,
                        size: file.size
                    }));
                    updateTaskFilesList();
                }
            }
        } catch (error) {
            console.error('Error loading task data:', error);
            alert('Failed to load task data.');
        }
    }

    elements.taskPopup.classList.add('active');
}

function closeTaskPopup() {
    elements.taskPopup.classList.remove('active');
    editingTaskId = null;
    elements.taskTitle.value = '';
    elements.taskDescription.value = '';
    elements.taskDeadline.value = '';
    uploadedTaskFiles = [];
    elements.taskFilesList.innerHTML = '';
}

async function submitTask() {
    const title = elements.taskTitle.value.trim();
    const description = elements.taskDescription.value.trim();
    const deadline = elements.taskDeadline.value;

    if (!title || !deadline) {
        alert('Please fill in the task title and deadline.');
        return;
    }

    // Get the submit button and show loading state
    const submitBtn = document.querySelector('.task-popup .actions .submit-btn');
    const originalText = submitBtn.textContent;
    submitBtn.textContent = editingTaskId ? 'Updating...' : 'Creating...';
    submitBtn.classList.add('loading');
    submitBtn.disabled = true;

    try {
        let taskRef;
        let taskData;

        if (editingTaskId) {
            // Editing existing task - preserve original data and only update necessary fields
            const existingTaskRef = ref(db, `tasks/${editingTaskId}`);
            const existingTaskSnapshot = await get(existingTaskRef);
            
            if (!existingTaskSnapshot.exists()) {
                alert('Task not found.');
                return;
            }
            
            const existingTask = existingTaskSnapshot.val();
            taskData = {
                ...existingTask, // Preserve all existing data
                title,
                description,
                deadline,
                updatedAt: new Date().toISOString()
            };
            
            // Handle files - preserve existing files and add new ones
            if (uploadedTaskFiles.length > 0) {
                submitBtn.textContent = 'Processing files...';
                taskData.files = {};
                
                // First, preserve existing files with their original structure
                if (existingTask.files) {
                    // Add existing files that are still in uploadedTaskFiles
                    Object.entries(existingTask.files).forEach(([key, existingFile]) => {
                        const stillExists = uploadedTaskFiles.some(file => 
                            file.url === existingFile.url && file.name === existingFile.name
                        );
                        if (stillExists) {
                            taskData.files[key] = existingFile; // Preserve original key
                        }
                    });
                }
                
                // Then add new files with new indices
                let newFileIndex = 0;
                for (let i = 0; i < uploadedTaskFiles.length; i++) {
                    const file = uploadedTaskFiles[i];
                    
                    // Check if this is a new file (no URL)
                    if (!file.url) {
                        // Find the next available index by checking all existing keys
                        const existingKeys = Object.keys(taskData.files).map(Number).sort((a, b) => a - b);
                        newFileIndex = 0;
                        for (const key of existingKeys) {
                            if (key === newFileIndex) {
                                newFileIndex++;
                            } else {
                                break;
                            }
                        }
                        
                        // New file - upload it
                        submitBtn.textContent = `Uploading file ${i + 1} of ${uploadedTaskFiles.length}...`;
                        const storagePath = `tasks/${editingTaskId}/${Date.now()}_${file.name}`;
                        const fileRef = storageRef(storage, storagePath);
                        const uploadTask = await uploadBytesResumable(fileRef, file);
                        const fileUrl = await getDownloadURL(fileRef);
                        taskData.files[newFileIndex] = {
                            name: file.name,
                            url: fileUrl,
                            type: file.type,
                            size: file.size
                        };
                        newFileIndex++;
                    }
                }
            } else {
                // No files selected - clear existing files
                taskData.files = {};
            }
            
            // Clean up removed files from Firebase Storage
            if (existingTask.files) {
                submitBtn.textContent = 'Cleaning up removed files...';
                const filesToDelete = [];
                
                // Find files that were removed
                Object.entries(existingTask.files).forEach(([key, existingFile]) => {
                    const stillExists = uploadedTaskFiles.some(file => 
                        file.url === existingFile.url && file.name === existingFile.name
                    );
                    if (!stillExists) {
                        filesToDelete.push(existingFile);
                    }
                });
                
                // Delete removed files from Firebase Storage
                for (const fileToDelete of filesToDelete) {
                    try {
                        // Extract the storage path from the URL
                        const urlParts = fileToDelete.url.split('/');
                        const fileName = urlParts[urlParts.length - 1].split('?')[0]; // Remove query parameters
                        const storagePath = `tasks/${editingTaskId}/${fileName}`;
                        const fileRef = storageRef(storage, storagePath);
                        await deleteObject(fileRef);
                        console.log(`Deleted file from storage: ${fileName}`);
                    } catch (error) {
                        console.error(`Error deleting file from storage: ${fileToDelete.name}`, error);
                        // Continue with other files even if one fails
                    }
                }
            }
            
            submitBtn.textContent = 'Saving task...';
            taskRef = existingTaskRef;
            await update(taskRef, taskData);
        } else {
            // Creating new task
            taskData = {
                professionalId: userId,
                studentId: selectedStudentId,
                title,
                description,
                deadline,
                status: 'pending',
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            if (uploadedTaskFiles.length > 0) {
                submitBtn.textContent = 'Uploading files...';
                taskData.files = {};
                for (let i = 0; i < uploadedTaskFiles.length; i++) {
                    const file = uploadedTaskFiles[i];
                    submitBtn.textContent = `Uploading file ${i + 1} of ${uploadedTaskFiles.length}...`;
                    const storagePath = `tasks/${Date.now()}_${file.name}`;
                    const fileRef = storageRef(storage, storagePath);
                    const uploadTask = await uploadBytesResumable(fileRef, file);
                    const fileUrl = await getDownloadURL(fileRef);
                    taskData.files[i] = {
                        name: file.name,
                        url: fileUrl,
                        type: file.type,
                        size: file.size
                    };
                }
            }
            
            submitBtn.textContent = 'Saving task...';
            taskRef = ref(db, `tasks`);
            await push(taskRef, taskData);

            // --- Send email to student ---
            try {
                // Fetch student data
                const studentSnapshot = await get(ref(db, `studentslist/${selectedStudentId}`));
                const student = studentSnapshot.exists() ? studentSnapshot.val() : null;
                const studentEmail = student?.personal?.email || student?.email;
                const studentName = student?.personal?.name || student?.name || 'Student';

                // Fetch employer (current user) data
                const employerSnapshot = await get(ref(db, `professionalslist/${userId}`));
                const employer = employerSnapshot.exists() ? employerSnapshot.val() : null;
                const employerName = employer?.personal?.name || employer?.name || 'Employer';

                if (studentEmail) {
                    await fetch('/api/added-task.js', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            to: studentEmail,
                            studentName,
                            employerName,
                            taskTitle: title
                        })
                    });
                }
            } catch (mailErr) {
                console.error('Error sending new task email:', mailErr);
            }
            // --- End email ---
        }

        closeTaskPopup();
        loadWorkflows();
        loadCompletedTasks();
    } catch (error) {
        console.error('Error submitting task:', error);
        // Remove the alert dialog - just log the error for debugging
    } finally {
        // Reset button state
        submitBtn.textContent = originalText;
        submitBtn.classList.remove('loading');
        submitBtn.disabled = false;
    }
}

async function populateTaskDropdown() {
    try {
        const tasksRef = ref(db, `tasks`);
        const snapshot = await get(tasksRef);
        elements.taskDropdown.innerHTML = '';
        if (snapshot.exists()) {
            const tasks = snapshot.val();
            let taskFound = false;
            for (const id in tasks) {
                if (tasks[id].professionalId === userId && tasks[id].studentId === selectedStudentId) {
                    taskFound = true;
                    const taskItem = document.createElement('div');
                    taskItem.className = 'task-dropdown-item';
                    taskItem.textContent = tasks[id].title;
                    elements.taskDropdown.appendChild(taskItem);
                }
            }
            if (!taskFound) {
                elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">No tasks available</div>';
            }
        } else {
            elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">No tasks available</div>';
        }
    } catch (error) {
        console.error("Error populating task dropdown:", error);
        elements.taskDropdown.innerHTML = '<div class="task-dropdown-item">Error loading tasks</div>';
    }
}

function insertMention(taskTitle) {
    const currentValue = elements.chatInput.value;
    const cursorPos = elements.chatInput.selectionStart;
    const textBefore = currentValue.substring(0, cursorPos);
    const textAfter = currentValue.substring(cursorPos);
    const lastAtIndex = textBefore.lastIndexOf('@');
    let newValue;
    if (lastAtIndex >= 0 && lastAtIndex === cursorPos - 1) {
        newValue = textBefore + taskTitle + ' ' + textAfter;
    } else {
        newValue = textBefore + '@' + taskTitle + ' ' + textAfter;
    }
    elements.chatInput.value = newValue;
    elements.chatInput.focus();
    const newCursorPos = lastAtIndex >= 0 ? lastAtIndex + taskTitle.length + 2 : cursorPos + taskTitle.length + 2;
    elements.chatInput.setSelectionRange(newCursorPos, newCursorPos);
    elements.taskDropdown.classList.remove('active');
    elements.chatInput.style.height = 'auto';
    elements.chatInput.style.height = `${Math.min(elements.chatInput.scrollHeight, 100)}px`;
}

function loadWorkflows() {
    if (!elements.workflowList) return;
    if (selectedStudentId) {
        const tasksRef = ref(db, `tasks`);
        onValue(tasksRef, (snapshot) => {
            elements.workflowList.innerHTML = '';
            let hasTasks = false;
            if (snapshot.exists()) {
                const tasks = snapshot.val();
                for (const taskId in tasks) {
                    const task = tasks[taskId];
                    if (task.professionalId === userId && task.studentId === selectedStudentId && task.status !== 'completed') {
                        hasTasks = true;
                        const workflowItem = document.createElement('div');
                        workflowItem.className = 'workflow-item';
                        workflowItem.dataset.taskId = taskId;
                        workflowItem.innerHTML = `
                            <div class="task-header">
                                <div class="task-info">
                                <h4>${task.title}</h4>
                                    <p class="task-description">${task.description}</p>
                                </div>
                                <div class="task-menu">
                                    <i class="fas fa-ellipsis-v task-menu-icon"></i>
                                    <div class="task-menu-dropdown">
                                        <button data-action="editTask">Edit Task</button>
                                        <button data-action="deleteTask" class="delete-task-btn">Delete Task</button>
                                    </div>
                                </div>
                            </div>
                            <div class="task-meta">
                            <div class="deadline-container">
                                    <div class="circular-progress">
                                        <div class="circular-progress-ring">
                                            <svg class="progress-ring" width="60" height="60">
                                                <circle class="progress-ring-circle-bg" cx="30" cy="30" r="24" stroke-width="4"></circle>
                                                <circle class="progress-ring-circle" cx="30" cy="30" r="24" stroke-width="4" 
                                                    stroke-dasharray="${2 * Math.PI * 24}" 
                                                    stroke-dashoffset="${2 * Math.PI * 24 * (1 - calculateDeadlineProgress(task.deadline) / 100)}"
                                                    style="stroke: ${getDeadlineColor(task.deadline)};"></circle>
                                            </svg>
                                            <div class="progress-text">
                                                <span class="days-number">${calculateDaysLeft(task.deadline)}</span>
                                                <span class="days-label">days</span>
                            </div>
                                        </div>
                                    </div>
                                </div>
                                ${task.files && Object.keys(task.files).length > 0 ? `
                                    <div class="files-count" onclick="toggleFilesPopup('${taskId}', event)">
                                        <i class="fas fa-paperclip"></i>
                                        <span>${Object.keys(task.files).length} ${getFileTypeLabel(task.files)}</span>
                                    </div>
                                ` : ''}
                            </div>
                            <div class="task-timeline">
                                <div class="timeline-header">
                                    <h5>Task Timeline</h5>
                                    <div class="timeline-actions">
                                        <button class="add-comment-btn" onclick="openCommentModal('${taskId}')">
                                            <i class="fas fa-comment"></i> Add Comment
                                        </button>
                                    </div>
                                </div>
                                <div class="timeline-content" id="timeline-${taskId}">
                                    ${generateTimelineHTML(task.submissions || {}, task.comments || {}, taskId)}
                                </div>
                            </div>
                        `;
                        elements.workflowList.appendChild(workflowItem);
                    }
                }
            }
            if (!hasTasks) {
                elements.workflowList.innerHTML = `
                    <div class="empty-tasks-state">
                        
                        <h3>Ready to Collaborate?</h3>
                        <p>Start working together creating your first task. Define clear objectives, set deadlines, and watch amazing results unfold!</p>
                        <div class="empty-tasks-actions">
                            <button class="create-task-btn" onclick="openTaskPopup()">
                                <i class="fas fa-plus"></i> Create Your First Task
                            </button>
                        </div>
                        <div class="empty-tasks-tips">
                            <h4>Quick Tips:</h4>
                            <ul>
                                <li>Be specific about what you need</li>
                                <li>Set realistic deadlines</li>
                                <li>Provide clear instructions</li>
                                <li>Stay engaged with regular feedback</li>
                            </ul>
                        </div>
                    </div>
                `;
            }
            isDataLoaded.tasks = true;
            checkAllDataLoaded();
        });
    }
}

function generateTimelineHTML(submissions, comments, taskId) {
    const allItems = [];
    
    // Add submissions
    if (submissions && Object.keys(submissions).length > 0) {
        Object.entries(submissions).forEach(([id, submission]) => {
            allItems.push({
                id,
                type: 'submission',
                ...submission
            });
        });
    }
    
    // Add comments
    if (comments && Object.keys(comments).length > 0) {
        Object.entries(comments).forEach(([id, comment]) => {
            allItems.push({
                id,
                type: 'comment',
                ...comment
            });
        });
    }
    
    if (allItems.length === 0) {
        return '<div class="timeline-empty">No submissions or comments yet</div>';
    }
    
    // Sort all items by timestamp (newest first)
    const sortedItems = allItems.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    return sortedItems.map(item => {
        if (item.type === 'submission') {
            return `
                <div class="timeline-item">
                    <div class="timeline-marker">
                        <i class="fas fa-upload"></i>
                    </div>
                    <div class="timeline-item-content">
                        <div class="timeline-header">
                            <span class="submission-author">${item.authorName}</span>
                            <span class="submission-date">${formatSubmissionDate(item.timestamp)}</span>
                        </div>
                        ${item.comment ? `<div class="submission-comment">${item.comment}</div>` : ''}
                        ${item.files ? `
                            <div class="submission-files">
                                ${Object.values(item.files).map(file => {
                                    const hasThumbnail = isImageFile(file.type) || isVideoFile(file.type);
                                    const displayFileName = hasThumbnail ? '' : truncateFileName(file.name);
                                    return `
                                        <div class="submission-file">
                                            <div class="file-thumbnail-container">
                                                ${generateFileThumbnail(file)}
                                            </div>
                                            ${!hasThumbnail ? `
                                                <div class="file-info">
                                                    <div class="file-name">${displayFileName}</div>
                                                    <div class="file-size">${file.size ? (file.size / 1024).toFixed(2) + ' KB' : 'Unknown size'}</div>
                                                </div>
                                            ` : ''}
                                            <div class="file-actions">
                                                <button onclick="downloadFile('${file.url}', '${file.name}')" class="download-btn" title="Download">
                                                    <i class="fas fa-download"></i>
                                                </button>
                                                ${isImageFile(file.type) || isVideoFile(file.type) ? `
                                                    <button class="view-btn" onclick="openFileViewer('${file.url}', '${file.type}', '${file.name}')" title="View">
                                                        <i class="fas fa-eye"></i>
                                                    </button>
                                                ` : ''}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : ''}
                        <div class="submission-actions">
                            ${item.status === 'approved' ? `
                                <button class="approve-submission-btn approved" disabled>
                                    <i class="fas fa-check-circle"></i> Approved
                                </button>
                                ${item.feedback ? `
                                    <div class="submission-feedback">
                                        <strong>Feedback:</strong> ${item.feedback}
                                    </div>
                                ` : ''}
                            ` : `
                                <button class="approve-submission-btn" onclick="approveSubmission('${item.id}')">
                                    <i class="fas fa-check"></i> Approve
                                </button>
                            `}
                        </div>
                    </div>
                </div>
            `;
        } else {
            return `
                <div class="timeline-item">
                    <div class="timeline-marker comment-marker">
                        <i class="fas fa-comment"></i>
                    </div>
                    <div class="timeline-item-content">
                        <div class="timeline-header">
                            <span class="comment-author">${item.authorName}</span>
                            <div class="timeline-item-actions">
                                <span class="comment-date">${formatSubmissionDate(item.timestamp)}</span>
                                <div class="timeline-item-menu">
                                    <i class="fas fa-ellipsis-v timeline-menu-icon" onclick="toggleTimelineMenu('comment-${item.id}')"></i>
                                    <div class="timeline-menu-dropdown" id="comment-${item.id}">
                                        <button onclick="deleteComment('${item.id}', '${taskId}')" class="delete-btn">
                                            <i class="fas fa-trash"></i> Delete Comment
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="comment-content">${item.content}</div>
                    </div>
                </div>
            `;
        }
    }).join('');
}

function formatSubmissionDate(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diffTime = now - date;
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) {
        return 'Today at ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else if (diffDays === 1) {
        return 'Yesterday at ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else if (diffDays < 7) {
        return diffDays + ' days ago';
    } else {
        return date.toLocaleDateString();
    }
}

function getFileTypeLabel(files) {
    const fileArray = Object.values(files);
    if (fileArray.length === 0) return 'files';
    
    const imageCount = fileArray.filter(file => isImageFile(file.type)).length;
    const videoCount = fileArray.filter(file => isVideoFile(file.type)).length;
    const pdfCount = fileArray.filter(file => file.type.includes('pdf')).length;
    const documentCount = fileArray.filter(file => 
        file.type.includes('word') || 
        file.type.includes('doc') || 
        file.type.includes('excel') || 
        file.type.includes('spreadsheet')
    ).length;
    
    if (imageCount === fileArray.length) {
        return imageCount === 1 ? 'image' : 'images';
    } else if (videoCount === fileArray.length) {
        return videoCount === 1 ? 'video' : 'videos';
    } else if (pdfCount === fileArray.length) {
        return pdfCount === 1 ? 'PDF' : 'PDFs';
    } else if (documentCount === fileArray.length) {
        return documentCount === 1 ? 'document' : 'documents';
    } else {
        return fileArray.length === 1 ? 'file' : 'files';
    }
}

function isImageFile(type) {
    return type.startsWith('image/');
}

function isVideoFile(type) {
    return type.startsWith('video/');
}

// Helper function to truncate file names
function truncateFileName(fileName, maxLength = 25) {
    if (fileName.length <= maxLength) return fileName;
    const extension = fileName.split('.').pop();
    const nameWithoutExt = fileName.substring(0, fileName.lastIndexOf('.'));
    const maxNameLength = maxLength - extension.length - 4; // 4 for "..."
    return nameWithoutExt.substring(0, maxNameLength) + '...' + extension;
}

function toggleFilesPopup(taskId, event) {
    event.stopPropagation();
    const popup = document.getElementById('files-popup');
    const popupBody = document.getElementById('files-popup-body');
    
    if (popup.classList.contains('active')) {
        closeFilesPopup();
        return;
    }
    
    // Get task files
    const taskRef = ref(db, `tasks/${taskId}`);
    get(taskRef).then(async (snapshot) => {
            if (snapshot.exists()) {
            const task = snapshot.val();
                        if (task.files) {
                // Debug: Log the files to check for duplicates
                console.log('Task files from database:', task.files);
                const fileValues = Object.values(task.files);
                console.log('File values:', fileValues);
                
                // Check for duplicates by URL
                const urls = fileValues.map(f => f.url);
                const uniqueUrls = [...new Set(urls)];
                if (urls.length !== uniqueUrls.length) {
                    console.warn('Duplicate files detected!', {
                        totalFiles: urls.length,
                        uniqueFiles: uniqueUrls.length,
                        duplicates: urls.length - uniqueUrls.length
                    });
                    
                    // Clean up duplicates
                    const cleanedFiles = await removeDuplicateFiles(taskId, task.files);
                    const cleanedFileValues = Object.values(cleanedFiles);
                    
                    const filesHTML = cleanedFileValues.map(file => `
                        <div class="popup-file-item">
                            <div class="file-thumbnail-container">
                                ${generateFileThumbnail(file)}
                            </div>
                            <div class="file-info">
                                <div class="file-name">${file.name}</div>
                                <div class="file-size">${file.size ? (file.size / 1024).toFixed(2) + ' KB' : 'Unknown size'}</div>
                            </div>
                            <div class="file-actions">
                                <button onclick="downloadFile('${file.url}', '${file.name}')" class="download-btn" title="Download">
                                    <i class="fas fa-download"></i>
                                </button>
                                ${isImageFile(file.type) || isVideoFile(file.type) ? `
                                    <button class="view-btn" onclick="openFileViewer('${file.url}', '${file.type}', '${file.name}')" title="View">
                                        <i class="fas fa-eye"></i>
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    `).join('');
                    
                    popupBody.innerHTML = filesHTML;
                } else {
                    // No duplicates found, display files normally
                    const filesHTML = fileValues.map(file => `
                        <div class="popup-file-item">
                            <div class="file-thumbnail-container">
                                ${generateFileThumbnail(file)}
                            </div>
                            <div class="file-info">
                                <div class="file-name">${file.name}</div>
                                <div class="file-size">${file.size ? (file.size / 1024).toFixed(2) + ' KB' : 'Unknown size'}</div>
                            </div>
                            <div class="file-actions">
                                <button onclick="downloadFile('${file.url}', '${file.name}')" class="download-btn" title="Download">
                                    <i class="fas fa-download"></i>
                                </button>
                                ${isImageFile(file.type) || isVideoFile(file.type) ? `
                                    <button class="view-btn" onclick="openFileViewer('${file.url}', '${file.type}', '${file.name}')" title="View">
                                        <i class="fas fa-eye"></i>
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    `).join('');
                    
                    popupBody.innerHTML = filesHTML;
                }
            } else {
                popupBody.innerHTML = '<div class="no-files">No files attached</div>';
            }
        }
    });
    
    // Position popup based on screen size
    const rect = event.target.getBoundingClientRect();
    const popupWidth = 450;
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    
    // Check if it's mobile (width <= 768px)
    if (screenWidth <= 768) {
        // Mobile: Center the popup
        const leftPosition = (screenWidth - popupWidth) / 2;
        const topPosition = Math.max(20, (screenHeight - 400) / 2); // 400px is approximate popup height
        
        popup.style.top = topPosition + 'px';
        popup.style.left = leftPosition + 'px';
    } else {
        // Desktop: Position near the button
        // Force popup to the left of the cursor
        let leftPosition = rect.left - popupWidth - 20; // 20px gap from cursor
        
        // Only if popup would go off-screen to the left, then position it to the right
        if (leftPosition < 20) {
            leftPosition = rect.right + 20;
        }
        
        // Ensure popup doesn't go off-screen to the right
        if (leftPosition + popupWidth > screenWidth - 20) {
            leftPosition = screenWidth - popupWidth - 20;
        }
        
        // Final safety check
        leftPosition = Math.max(20, leftPosition);
        
        popup.style.top = rect.top + 'px';
        popup.style.left = leftPosition + 'px';
    }
    
    popup.classList.add('active');
}

function closeFilesPopup() {
    const popup = document.getElementById('files-popup');
    popup.classList.remove('active');
}

// Function to remove duplicate files from a task
async function removeDuplicateFiles(taskId, taskFiles) {
    const fileValues = Object.values(taskFiles);
    const uniqueFiles = [];
    const seenUrls = new Set();
    
    // Keep only unique files based on URL
    for (const file of fileValues) {
        if (!seenUrls.has(file.url)) {
            seenUrls.add(file.url);
            uniqueFiles.push(file);
        }
    }
    
    // If we found duplicates, update the database
    if (uniqueFiles.length !== fileValues.length) {
        console.log(`Removing ${fileValues.length - uniqueFiles.length} duplicate files from task ${taskId}`);
        
        // Rebuild the files object with sequential indices
        const cleanedFiles = {};
        uniqueFiles.forEach((file, index) => {
            cleanedFiles[index] = file;
        });
        
        // Update the task in the database
        const taskRef = ref(db, `tasks/${taskId}`);
        await update(taskRef, { files: cleanedFiles });
        
        return cleanedFiles;
    }
    
    return taskFiles;
}

function generateFileThumbnail(file) {
    if (isImageFile(file.type)) {
        return `
            <div class="file-thumbnail image-thumbnail">
                <img src="${file.url}" alt="${file.name}" loading="lazy">
                <div class="file-overlay">
                    <i class="fas fa-eye"></i>
                                    </div>
                                </div>
        `;
    } else if (isVideoFile(file.type)) {
        return `
            <div class="file-thumbnail video-thumbnail">
                <video src="${file.url}" preload="metadata"></video>
                <div class="file-overlay">
                    <i class="fas fa-play"></i>
                            </div>
            </div>
        `;
    } else {
        return `
            <a href="${file.url}" download="${file.name}" class="file-icon-container" title="${file.name}">
                <i class="${getFileIconClass(file.type)} file-icon" style="color: ${getFileIconColor(file.type)};"></i>
            </a>
        `;
    }
}

function openFileViewer(fileUrl, fileType, fileName) {
    const fileViewerModal = document.getElementById('file-viewer-modal');
    const fileContent = document.getElementById('file-content');
    
    if (fileViewerModal && fileContent) {
        let content = '';
        if (isImageFile(fileType)) {
            content = `<img src="${fileUrl}" alt="${fileName}" style="max-width: 100%; max-height: 80vh; object-fit: contain;">`;
        } else if (isVideoFile(fileType)) {
            content = `<video src="${fileUrl}" controls style="max-width: 100%; max-height: 80vh;"></video>`;
        }
        fileContent.innerHTML = content;
        fileViewerModal.classList.add('active');
    }
}

function closeFileViewer() {
    const fileViewerModal = document.getElementById('file-viewer-modal');
    if (fileViewerModal) {
        fileViewerModal.classList.remove('active');
        const fileContent = document.getElementById('file-content');
        if (fileContent) {
            fileContent.innerHTML = '';
        }
    }
}

// Function to download file directly to local system
async function downloadFile(fileUrl, fileName) {
    try {
        const response = await fetch(fileUrl);
        const blob = await response.blob();
        
        // Create a temporary link element
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        link.style.display = 'none';
        
        // Append to body, click, and remove
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Clean up the object URL
        URL.revokeObjectURL(link.href);
    } catch (error) {
        console.error('Error downloading file:', error);
        // Fallback to direct link if fetch fails
        const link = document.createElement('a');
        link.href = fileUrl;
        link.download = fileName;
        link.target = '_blank';
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}

function hideChat() {
    const chatArea = document.getElementById('chat-area');
    const chatToggleBtn = document.getElementById('chat-toggle-btn');
    
    if (chatArea) {
        chatArea.classList.add('chat-hidden');
        setTimeout(() => {
            chatArea.style.display = 'none';
        }, 300);
    }
    if (chatToggleBtn) {
        chatToggleBtn.style.display = 'flex';
    }
}

function showChat() {
    const chatArea = document.getElementById('chat-area');
    const chatToggleBtn = document.getElementById('chat-toggle-btn');
    
    if (chatArea) {
        chatArea.style.display = 'block';
        chatArea.classList.remove('chat-hidden');
    }
    if (chatToggleBtn) {
        chatToggleBtn.style.display = 'none';
    }
}

// Comment Modal Functions
let currentCommentTaskId = null;

function openCommentModal(taskId) {
    currentCommentTaskId = taskId;
    elements.commentContent.value = '';
    elements.commentModal.classList.add('active');
}

function closeCommentModal() {
    elements.commentModal.classList.remove('active');
    currentCommentTaskId = null;
    elements.commentContent.value = '';
}

async function submitComment() {
    const content = elements.commentContent.value.trim();
    
    if (!content) {
        alert('Please enter a comment.');
        return;
    }
    
    if (!currentCommentTaskId) {
        alert('No task selected for comment.');
        return;
    }
    
    try {
        const currentUser = await fetchCurrentUserProfile();
        const commentData = {
            content: content,
            authorId: userId,
            authorName: currentUser.name,
            timestamp: new Date().toISOString()
        };
        
        const taskRef = ref(db, `tasks/${currentCommentTaskId}`);
        const taskSnapshot = await get(taskRef);
        
        if (taskSnapshot.exists()) {
            const task = taskSnapshot.val();
            const comments = task.comments || {};
            const commentId = Date.now().toString();
            comments[commentId] = commentData;
            
            await update(taskRef, { comments: comments });
            
            closeCommentModal();
            loadWorkflows(); // Refresh the timeline
        } else {
            alert('Task not found.');
        }
    } catch (error) {
        console.error('Error submitting comment:', error);
        alert('Failed to submit comment.');
    }
}

async function updateStatus({ taskId, status }) {
    try {
        const taskRef = ref(db, `tasks/${taskId}`);
        await update(taskRef, { 
            status: status,
            updatedAt: new Date().toISOString()
        });
        loadWorkflows();
        loadCompletedTasks();
    } catch (error) {
        console.error("Error updating task status:", error);
        alert("Failed to update task status.");
    }
}

function calculateDaysLeft(deadline) {
    const now = new Date();
    const deadlineDate = new Date(deadline);
    const diffTime = deadlineDate - now;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays > 0 ? diffDays : 0;
}

function calculateDeadlineProgress(deadline) {
    const now = new Date();
    const deadlineDate = new Date(deadline);
    const diffTime = deadlineDate - now;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    if (diffDays <= 0) return 0;
    if (diffDays >= 30) return 100;
    return Math.round((diffDays / 30) * 100);
}

function getDeadlineColor(deadline) {
    const daysLeft = calculateDaysLeft(deadline);
    if (daysLeft <= 3) return '#FF5252';
    if (daysLeft <= 7) return '#FFC107';
    return '#4CAF50';
}

// Approval Modal Functions
let currentApprovalSubmissionId = null;

function openApprovalModal(submissionId) {
    currentApprovalSubmissionId = submissionId;
    
    // Reset feedback
    document.getElementById('approval-feedback').value = '';
    
    // Show modal
    document.getElementById('approval-modal').classList.add('active');
}

function closeApprovalModal() {
    document.getElementById('approval-modal').classList.remove('active');
    currentApprovalSubmissionId = null;
}

async function confirmApproval() {
    const feedback = document.getElementById('approval-feedback').value.trim();
    
    try {
        // Find the task that contains this submission
        const tasksRef = ref(db, `tasks`);
        const tasksSnapshot = await get(tasksRef);
        
        if (tasksSnapshot.exists()) {
            const tasks = tasksSnapshot.val();
            let taskFound = false;
            
            for (const taskId in tasks) {
                const task = tasks[taskId];
                if (task.professionalId === userId && task.studentId === selectedStudentId && task.submissions && task.submissions[currentApprovalSubmissionId]) {
                    // Update the submission with approval data
                    const submissionRef = ref(db, `tasks/${taskId}/submissions/${currentApprovalSubmissionId}`);
                    await update(submissionRef, { 
                        status: 'approved',
                        approvedAt: new Date().toISOString(),
                        approvedBy: userId,
                        feedback: feedback || null
                    });
                    
                    taskFound = true;
                    break;
                }
            }
            
            if (taskFound) {
                closeApprovalModal();
                loadWorkflows(); // Refresh the timeline
                alert('Submission approved successfully!');
            } else {
                alert('Submission not found.');
            }
        }
    } catch (error) {
        console.error('Error approving submission:', error);
        alert('Failed to approve submission.');
    }
}

async function approveSubmission(submissionId) {
    // Open the approval modal instead of directly approving
    openApprovalModal(submissionId);
}

window.sendMessage = sendMessage;
window.sendFileMessage = sendFileMessage;
window.openTaskPopup = openTaskPopup;
window.closeTaskPopup = closeTaskPopup;
window.submitTask = submitTask;
window.selectStudent = selectStudent;
window.updateStatus = updateStatus;
window.acceptRequest = acceptRequest;
window.deleteRequest = deleteRequest;
window.deleteConnection = deleteConnection;
window.deleteTask = deleteTask;
window.deleteMessage = deleteMessage;
window.confirmAction = confirmAction;
window.closeConfirmation = closeConfirmation;
window.toggleReaction = toggleReaction;
window.hideChat = hideChat;
window.showChat = showChat;
window.openFileViewer = openFileViewer;
window.closeFileViewer = closeFileViewer;
window.toggleFilesPopup = toggleFilesPopup;
window.closeFilesPopup = closeFilesPopup;
window.openCommentModal = openCommentModal;
window.closeCommentModal = closeCommentModal;
window.submitComment = submitComment;
window.approveSubmission = approveSubmission;
window.openApprovalModal = openApprovalModal;
window.closeApprovalModal = closeApprovalModal;
window.confirmApproval = confirmApproval;
window.downloadFile = downloadFile;

// Cache management functions for debugging
window.clearMessageCache = clearMessageCache;
window.clearChatCache = clearChatCache;
window.clearAllChatData = clearAllChatData;
window.manageCacheSize = manageCacheSize;
window.messageCache = messageCache;
window.lastMessageTimestamps = lastMessageTimestamps;

// Mobile Sidebar Functions
window.toggleSidebar = toggleSidebar;
window.closeSidebar = closeSidebar;

// Timeline Menu Functions
window.toggleTimelineMenu = toggleTimelineMenu;
window.deleteComment = deleteComment;
window.confirmDeleteComment = confirmDeleteComment;

function toggleSidebar() {
    const sidebar = document.querySelector('.sidebar-left');
    const toggle = document.getElementById('sidebar-toggle');
    const overlay = document.getElementById('sidebar-overlay');
    const dashboard = document.querySelector('.dashboard-content');
    
    if (sidebar.classList.contains('active')) {
        closeSidebar();
    } else {
        sidebar.classList.add('active');
        toggle.classList.add('active');
        overlay.classList.add('active');
        dashboard.classList.add('sidebar-open');
    }
}

function closeSidebar() {
    const sidebar = document.querySelector('.sidebar-left');
    const toggle = document.getElementById('sidebar-toggle');
    const overlay = document.getElementById('sidebar-overlay');
    const dashboard = document.querySelector('.dashboard-content');
    
    sidebar.classList.remove('active');
    toggle.classList.remove('active');
    overlay.classList.remove('active');
    dashboard.classList.remove('sidebar-open');
}

function toggleTimelineMenu(menuId) {
    // Close all other menus first
    document.querySelectorAll('.timeline-menu-dropdown.active').forEach(menu => {
        if (menu.id !== menuId) {
            menu.classList.remove('active');
        }
    });
    
    // Toggle the clicked menu
    const menu = document.getElementById(menuId);
    if (menu) {
        menu.classList.toggle('active');
    }
}

// Close timeline menus when clicking outside
document.addEventListener('click', (e) => {
    if (!e.target.closest('.timeline-item-menu')) {
        document.querySelectorAll('.timeline-menu-dropdown.active').forEach(menu => {
            menu.classList.remove('active');
        });
    }
});

async function deleteComment(commentId, taskId) {
    try {
        // Show confirmation dialog
        confirmAction('confirmDeleteComment', 'Delete Comment', 'Are you sure you want to delete this comment? This action cannot be undone.', { commentId, taskId });
    } catch (error) {
        console.error('Error showing delete confirmation:', error);
        alert('Failed to show confirmation dialog.');
    }
}

async function confirmDeleteComment({ commentId, taskId }) {
    try {
        if (!taskId) {
            alert('No task selected.');
            return;
        }
        
        // Delete the comment from Firebase
        const commentRef = ref(db, `tasks/${taskId}/comments/${commentId}`);
        await remove(commentRef);
        
        // Refresh the timeline
        loadWorkflows();
        
        // Show success message
        alert('Comment deleted successfully!');
        
    } catch (error) {
        console.error('Error deleting comment:', error);
        alert('Failed to delete comment. Please try again.');
    }
}

// Add cache management functions
function clearMessageCache() {
    messageCache.clear();
    lastMessageTimestamps.clear();
}

function clearChatCache(chatId) {
    messageCache.delete(chatId);
    lastMessageTimestamps.delete(chatId);
}

// Clear all chat data when switching students
function clearAllChatData() {
    // Clear all caches
    messageCache.clear();
    lastMessageTimestamps.clear();
    
    // Clear chat listener
    if (currentChatListener) {
        currentChatListener();
        currentChatListener = null;
    }
    
    // Clear chat messages area
    if (elements.chatMessages) {
        elements.chatMessages.innerHTML = '';
    }
}

// Cache size management
function manageCacheSize() {
    const maxCacheSize = 10; // Maximum number of chat caches to keep
    if (messageCache.size > maxCacheSize) {
        const chatIds = Array.from(messageCache.keys());
        const oldestChatIds = chatIds.slice(0, messageCache.size - maxCacheSize);
        oldestChatIds.forEach(chatId => {
            clearChatCache(chatId);
        });
    }
}

// Global function to handle profile picture clicks
function handleProfilePictureClick(userId, userRole) {
    if (!userId) return;
    
    let profileUrl;
    if (userRole === 'professional') {
        profileUrl = `view-profile.html?id=${encodeURIComponent(userId)}`;
    } else {
        profileUrl = `../workplace/view-profile.html?studentId=${encodeURIComponent(userId)}`;
    }
    
    window.open(profileUrl, '_blank');
}

// Make function globally accessible
window.handleProfilePictureClick = handleProfilePictureClick;

// === Invite to Connect Modal for Tasks Page ===
// Create the invite modal dynamically
const inviteConnectModalTasks = document.createElement('div');
inviteConnectModalTasks.id = 'invite-connect-modal-tasks';
inviteConnectModalTasks.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    font-family: 'Poppins', sans-serif;
`;

inviteConnectModalTasks.innerHTML = `
    <div style="
        background: white;
        border-radius: 12px;
        padding: 2rem;
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        position: relative;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    ">
        <div style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e0e0e0;
        ">
            <h2 style="
                margin: 0;
                font-size: 1.5rem;
                font-weight: 600;
                color: #333;
            ">Invite to Connect</h2>
            <button id="close-invite-modal-tasks" style="
                background: none;
                border: none;
                font-size: 1.5rem;
                cursor: pointer;
                color: #6e6e73;
                padding: 0;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                transition: background 0.2s;
            " onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='transparent'" onclick="closeInviteModalTasks()">×</button>
        </div>
        
        <div style="margin-bottom: 1.5rem;">
            <p style="
                margin: 0 0 1rem 0;
                color: #666;
                line-height: 1.6;
                font-size: 0.95rem;
            ">
                Share this invite link with students you'd like to connect with. They can use this link to send you a connection request.
            </p>
            
            <div style="margin-bottom: 1rem;">
                <label for="invite-link-tasks" style="
                    display: block;
                    margin-bottom: 0.5rem;
                    font-weight: 500;
                    color: #333;
                    font-size: 0.9rem;
                ">Invite Link</label>
                <div style="
                    display: flex;
                    gap: 0.5rem;
                    align-items: center;
                ">
                    <input type="text" id="invite-link-tasks" readonly style="
                        flex: 1;
                        padding: 0.75rem;
                        border: 1px solid #ddd;
                        border-radius: 6px;
                        font-size: 0.9rem;
                        background: #f8f9fa;
                        color: #333;
                        font-family: 'Courier New', monospace;
                    ">
                    <button onclick="copyInviteLinkTasks()" style="
                        padding: 0.75rem 1rem;
                        background: #007bff;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 0.9rem;
                        font-weight: 500;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#0056b3'" onmouseout="this.style.background='#007bff'">
                        Copy
                    </button>
                </div>
            </div>
            
            <div style="
                background: #f8f9fa;
                border: 1px solid #e9ecef;
                border-radius: 8px;
                padding: 1rem;
                margin-bottom: 1rem;
            ">
                <h4 style="
                    margin: 0 0 0.5rem 0;
                    font-size: 1rem;
                    color: #333;
                ">How it works:</h4>
                <ol style="
                    margin: 0;
                    padding-left: 1.2rem;
                    color: #666;
                    font-size: 0.9rem;
                    line-height: 1.5;
                ">
                    <li>Share the invite link with a student</li>
                    <li>They click the link and sign up/login</li>
                    <li>They can send you a connection request</li>
                    <li>You'll receive a notification to accept</li>
                    <li>Once connected, you can collaborate on tasks</li>
                </ol>
            </div>
            
            <div style="text-align: center;">
                <button onclick="shareInviteLinkTasks()" style="
                    padding: 0.75rem 1.5rem;
                    background: #28a745;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 0.95rem;
                    font-weight: 500;
                    transition: background 0.2s;
                    display: inline-flex;
                    align-items: center;
                    gap: 0.5rem;
                " onmouseover="this.style.background='#218838'" onmouseout="this.style.background='#28a745'">
                    <i class="fas fa-share-alt"></i>
                    Share via WhatsApp
                </button>
            </div>
        </div>
    </div>
`;

// Add the modal to the page
document.body.appendChild(inviteConnectModalTasks);

// Add event listeners for the tasks page invite modal
document.addEventListener('DOMContentLoaded', function() {
    // Add event listener for the invite button in tasks page
    const inviteBtnTasks = document.getElementById('invite-connect-btn-tasks');
    if (inviteBtnTasks) {
        inviteBtnTasks.addEventListener('click', function() {
            openInviteModalTasks();
        });
    }
    
    // Add event listener for the close button
    const closeBtnTasks = document.getElementById('close-invite-modal-tasks');
    if (closeBtnTasks) {
        closeBtnTasks.addEventListener('click', function() {
            closeInviteModalTasks();
        });
    }
    
    // Close modal when clicking outside
    inviteConnectModalTasks.addEventListener('click', function(e) {
        if (e.target === inviteConnectModalTasks) {
            closeInviteModalTasks();
        }
    });
    
    // Add event listener for copy button
    const copyBtnTasks = document.querySelector('#invite-connect-modal-tasks button[onclick="copyInviteLinkTasks()"]');
    if (copyBtnTasks) {
        copyBtnTasks.addEventListener('click', function() {
            copyInviteLinkTasks();
        });
    }
});

// Functions for tasks page invite modal
function openInviteModalTasks() {
    const userId = localStorage.getItem('userId');
    if (!userId) {
        alert('You must be logged in to generate an invite link.');
        return;
    }
    
    try {
        // Generate invite link
        let inviteLink;
        
        // User is a professional - invite to checkinvite.html
        inviteLink = `${window.location.origin}/checkinvite.html?invite=${userId}`;
        
        // Set the invite link in the input field
        document.getElementById('invite-link-tasks').value = inviteLink;
        
        // Show the modal
        inviteConnectModalTasks.style.display = 'flex';
        
        // Generate QR code if needed
        generateQRCodeTasks(inviteLink);
        
    } catch (error) {
        console.error('Error generating invite link:', error);
        alert('Failed to generate invite link. Please try again.');
    }
}

function closeInviteModalTasks() {
    inviteConnectModalTasks.style.display = 'none';
}

function generateQRCodeTasks(inviteLink) {
    // QR code generation logic can be added here if needed
    // For now, we'll skip QR code generation
}

function copyInviteLinkTasks() {
    const inviteLink = document.getElementById('invite-link-tasks');
    inviteLink.select();
    inviteLink.setSelectionRange(0, 99999);
    
    try {
        document.execCommand('copy');
        
        // Show success message
        const copyBtn = document.querySelector('#invite-connect-modal-tasks button[onclick="copyInviteLinkTasks()"]');
        const originalText = copyBtn.textContent;
        copyBtn.textContent = 'Copied!';
        copyBtn.style.background = '#28a745';
        
        setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.style.background = '#007bff';
        }, 2000);
        
    } catch (err) {
        console.error('Failed to copy: ', err);
        alert('Failed to copy link. Please copy it manually.');
    }
}

function shareInviteLinkTasks() {
    const inviteLink = document.getElementById('invite-link-tasks').value;
    const message = `Hi! I'd like to connect with you on Taska. Here's my invite link: ${inviteLink}`;
    
    // Create WhatsApp share URL
    const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(message)}`;
    
    // Open WhatsApp in new window
    window.open(whatsappUrl, '_blank');
}

// Make functions globally accessible
window.openInviteModalTasks = openInviteModalTasks;
window.closeInviteModalTasks = closeInviteModalTasks;
window.copyInviteLinkTasks = copyInviteLinkTasks;
window.shareInviteLinkTasks = shareInviteLinkTasks;

// Add JS functions for notify popup
function openNotifyPopup() {
    document.getElementById('notify-modal').style.display = 'flex';
    document.getElementById('notify-modal-message').style.display = 'none';
    document.getElementById('notify-modal-message').textContent = '';
}
function closeNotifyPopup() {
    document.getElementById('notify-modal').style.display = 'none';
}
window.openNotifyPopup = openNotifyPopup;
window.closeNotifyPopup = closeNotifyPopup;

async function sendNotify() {
    const notifyMsg = document.getElementById('notify-modal-message');
    notifyMsg.style.display = 'none';
    notifyMsg.textContent = '';
    if (!selectedStudentId || !userId) {
        notifyMsg.textContent = 'No chat selected.';
        notifyMsg.style.display = 'block';
        return;
    }
    try {
        // Determine chatId (sorted)
        const chatId = [userId, selectedStudentId].sort().join("+");
        // Check last notified time
        const notifRef = ref(db, `notifications/${chatId}`);
        const notifSnap = await get(notifRef);
        const now = Date.now();
        if (notifSnap.exists() && notifSnap.val().lastNotified) {
            const last = notifSnap.val().lastNotified;
            if (now - last < 30 * 60 * 1000) {
                notifyMsg.textContent = 'You can only notify once every 30 minutes.';
                notifyMsg.style.display = 'block';
                return;
            }
        }
        // Get receiver info (is professional or student)
        let receiverId = selectedStudentId;
        let receiverType = 'student';
        // If current user is student, receiver is professional
        if (window.location.pathname.includes('/workplace/')) {
            receiverId = userId;
            receiverType = 'professional';
        }
        // Fetch receiver email and name
        let receiverEmail = '';
        let receiverName = '';
        if (receiverType === 'professional') {
            const profSnap = await get(ref(db, `professionalslist/${receiverId}`));
            if (profSnap.exists()) {
                receiverEmail = profSnap.val().personal?.email || profSnap.val().email || '';
                receiverName = profSnap.val().personal?.name || profSnap.val().name || 'Employer';
            }
        } else {
            const stuSnap = await get(ref(db, `studentslist/${receiverId}`));
            if (stuSnap.exists()) {
                receiverEmail = stuSnap.val().personal?.email || stuSnap.val().email || '';
                receiverName = stuSnap.val().personal?.name || stuSnap.val().name || 'Student';
            }
        }
        if (!receiverEmail) {
            notifyMsg.textContent = 'Could not find receiver email.';
            notifyMsg.style.display = 'block';
            return;
        }
        // Call backend API to send email
        const resp = await fetch('/api/new-chatnotify.js', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                to: receiverEmail,
                receiverName,
                receiverType
            })
        });
        const data = await resp.json();
        if (!resp.ok) throw new Error(data.error || 'Failed to send notification');
        // Update last notified time
        await set(notifRef, { lastNotified: now });
        notifyMsg.textContent = 'Notification sent!';
        notifyMsg.style.color = '#388e3c';
        notifyMsg.style.display = 'block';
        setTimeout(() => {
            closeNotifyPopup();
            notifyMsg.style.color = '#d32f2f';
        }, 1500);
    } catch (err) {
        notifyMsg.textContent = err.message || 'Failed to send notification.';
        notifyMsg.style.display = 'block';
    }
}
window.sendNotify = sendNotify;

init();
    </script>
    <!-- Notify Confirmation Modal -->
    <div class="notify-modal" id="notify-modal">
        <div class="notify-modal-content">
            <h3>Notify Student?</h3>
            <p>Do you want to notify the student about new chats or the updates in the work?</p>
            <div class="notify-modal-actions">
                <button class="notify-cancel-btn" onclick="closeNotifyPopup()">Cancel</button>
                <button class="notify-confirm-btn" onclick="sendNotify()">Notify</button>
            </div>
            <div id="notify-modal-message"></div>
        </div>
    </div>
</body>
</html>