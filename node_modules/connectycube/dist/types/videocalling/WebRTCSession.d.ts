import WebRTCPeerConnection from './WebRTCPeerConnection';
import WebRTCSignalingProvider from './WebRTCSignalingProvider';
import { Calls, CallSessionConnectionState, CallSessionState, CallType, Media, MediaType, PeerConnectionState } from '../types';
export default class WebRTCSession {
    ID: string | null;
    state: CallSessionState;
    callType: CallType;
    initiatorID: number;
    currentUserID: number;
    opponentsIDs: number[];
    maxBandwidth: number;
    peerConnections: {
        [userID: number]: WebRTCPeerConnection;
    };
    localStream?: MediaStream;
    mediaParams: MediaStreamConstraints;
    signalingProvider: WebRTCSignalingProvider;
    answerTimer: NodeJS.Timeout | null;
    waitingOfferOrAnswerTimer: NodeJS.Timeout | null;
    startCallTime: number;
    acceptCallTime: number;
    onUserNotAnswerListener: Calls.OnUserNotAnswerListener;
    onRemoteStreamListener: Calls.OnRemoteStreamListener;
    onSessionCloseListener: Calls.OnSessionCloseListener;
    onCallStatsReportListener: Calls.OnCallStatsReportListener;
    onSessionConnectionStateChangedListener: Calls.OnSessionConnectionStateChangedListener;
    constructor(params: Calls.SessionParams);
    getDisplayMedia(params: Media.DisplayParams): Promise<MediaStream>;
    getUserMedia(params: Media.UserParams): Promise<MediaStream>;
    private upsertStream;
    private replaceTracks;
    setMaxBandwidth(maxBandwidth: number): Promise<void[]>;
    connectionStateForUser(userID: number): PeerConnectionState | null;
    attachMediaStream(elementId: string, stream: MediaStream, opt?: Media.ElementOptions): void;
    detachMediaStream(elementId: string, opt?: Media.ElementOptions): void;
    switchMediaTracks(options?: Media.TrackConstraintsOrDeviceIds): Promise<MediaStream>;
    call(extension?: Calls.UserInfo): void;
    private callInternal;
    accept(extension?: Calls.UserInfo): void;
    private acceptInternal;
    reject(extension?: Calls.UserInfo): void;
    stop(extension?: Calls.UserInfo): void;
    canInitiateIceRestart(userID: number): boolean;
    iceRestart(userID: number): Promise<void>;
    processOnCall(callerID: number, extension: Calls.ExtensionParams): void;
    processOnAccept(userID: number, extension: Calls.ExtensionParams): Promise<void>;
    processOnReject(userID: number): void;
    processOnStop(userID: number): void;
    processOnIceCandidates(userID: number, extension: Calls.ExtensionParams): Promise<void>;
    processOnIceRestart(userID: number, extension: Calls.ExtensionParams): Promise<void>;
    processOnIceRestartAccept(userID: number, extension: Calls.ExtensionParams): Promise<void>;
    processCall(peerConnection: WebRTCPeerConnection, extension?: Calls.ExtensionParams): void;
    processIceCandidates(userID: number, iceCandidates: RTCIceCandidateInit[]): void;
    processOnNotAnswer(peerConnection: WebRTCPeerConnection): void;
    onRemoteStream(userID: number, stream: MediaStream): void;
    onCallStatsReport(userID: number, stats: any, error?: Error): void;
    onSessionConnectionStateChanged(userID: number, connectionState: CallSessionConnectionState): void;
    private close;
    closeSessionIfAllConnectionsClosed(): void;
    private closeLocalMediaStream;
    mute(type: MediaType): void;
    unmute(type: MediaType): void;
    private muteStream;
    private clearAnswerTimer;
    private startAnswerTimer;
    private clearWaitingOfferOrAnswerTimer;
    private startWaitingOfferOrAnswerTimer;
    toString(): string;
}
//# sourceMappingURL=WebRTCSession.d.ts.map